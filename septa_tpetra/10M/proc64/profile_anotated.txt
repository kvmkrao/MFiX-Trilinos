*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_ParameterEntry.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                
                #ifndef TEUCHOS_PARAMETER_ENTRY_H
                #define TEUCHOS_PARAMETER_ENTRY_H
                
                /*! \file Teuchos_ParameterEntry.hpp
                    \brief Object held as the "value" in the Teuchos::ParameterList std::map.
                */
                
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_any.hpp"
                #include "Teuchos_RCP.hpp"
                #include "Teuchos_ParameterEntryValidator.hpp"
                
                namespace Teuchos {
                
                #ifndef DOXYGEN_SHOULD_SKIP_THIS
                class ParameterList; // another parameter type (forward declaration)
                #endif
                
                /*! \brief This object is held as the "value" in the Teuchos::ParameterList std::map.
                
                    This structure holds a \c Teuchos::any value and information on the status of this
                    parameter (isUsed, isDefault, etc.).  The type of parameter is chosen through the
                    templated Set/Get methods.
                */
          19 -> class TEUCHOSPARAMETERLIST_LIB_DLL_EXPORT ParameterEntry {
                
                public:
                
                  /** \name Public types */
                  //@{
                  
                  /** \brief . */
                  typedef unsigned int ParameterEntryID;
                  
                  //@}
                
                  //! @name Constructors/Destructor 
                  //@{
                
                  //! Default Constructor
                  ParameterEntry();
                  
                  //! Copy constructor
                  ParameterEntry(const ParameterEntry& source);
                
                  //! Templated constructor
                  template<typename T>
                  explicit ParameterEntry(
                    T value, bool isDefault = false, bool isList = false,
                    const std::string &docString = "",
                    RCP<const ParameterEntryValidator> const& validator = null
                    );
                
                  //@}
                
                  //! @name Set Methods 
                  //@{
                
                  //! Replace the current parameter entry with \c source.
                  ParameterEntry& operator=(const ParameterEntry& source);
                
                  /*! \brief Templated set method that uses the input value type to determine the type of parameter.  
                      
                      \note <ul>
                	    <li> Invalidates any previous values stored by this object although it doesn't necessarily erase them.  
                            <li> Resets 'isUsed' functionality.  
                	    </ul>
                  */
                  template<typename T>
                  void setValue(
                    T value, bool isDefault = false,
                    const std::string &docString = "",
                    RCP<const ParameterEntryValidator> const& validator = null
                    );
                
                  /*! \brief Set the value as an any object.
                  *
                  * This wipes all other data including documentation strings.
                  *
                  * Warning! Do not use function ths to set a sublist!
                  */
                  void setAnyValue(
                    const any &value, bool isDefault = false
                    );
                
                  /*! \brief Set the validator. */
                  void setValidator(
                    RCP<const ParameterEntryValidator> const& validator
                    );
                
                  /*! \brief Set the documentation std::string. */
                  void setDocString(const std::string &docString);
                
                  //! Create a parameter entry that is an empty list.
                  ParameterList& setList(
                    bool isDefault = false,
                    const std::string &docString = ""
                    );
                
                  //@}
                
                  //! @name Get Methods 
                  //@{
                   
                  /*! \brief Templated get method that uses the input pointer type to determine the type of parameter to return.  
                
                      \note This method will cast the value to the type requested.  If that type is incorrect, 
                	    an std::exception will be thrown by the any_cast.
                  */
                  template<typename T>
                  inline
                  T& getValue(T *ptr) const;
                
                  /*! \brief Direct access to the Teuchos::any data value underlying this
                   *  object. The bool argument \c activeQry (default: true) indicates that the 
                   *  call to getAny() will set the isUsed() value of the ParameterEntry to true.
                   */
                  inline
                  any& getAny(bool activeQry = true);
                
                  /*! \brief Constant direct access to the Teuchos::any data value underlying this
                   *  object. The bool argument \c activeQry (default: true) indicates that the 
                   *  call to getAny() will set the isUsed() value of the ParameterEntry to true.
                   */
                  inline
                  const any& getAny(bool activeQry = true) const;
                
                  //@}
                
                  //! @name Attribute/Query Methods 
                  //@{
                  
                  //! Return whether or not the value has been used; i.e., whether or not the value has been retrieved via a get function.
                  inline
                  bool isUsed() const;
                
                  //! Return whether or not the value itself is a list.
                  bool isList() const;
                  
                  //! Test the type of the data being contained.
                  template <typename T>
                  inline
                  bool isType() const;
                
                  //! Test if the type of data being contained is a Teuchos::Array.
                  bool isArray() const;
                  //
                  //! Test if the type of data being contained is a Teuchos::TwoDArray.
                  bool isTwoDArray() const;
                
                  //! Indicate whether this entry takes on the default value.
                  inline
                  bool isDefault() const;
                
                  //! Return the (optional) documentation std::string
                  inline
                  std::string docString() const;
                
                  //! Return the (optional) validator object
                  inline
                  RCP<const ParameterEntryValidator> validator() const;
                
                  //@}
                
                  //! @name I/O Methods 
                  //@{
                  /*! \brief Output a non-list parameter to the given output stream.  
                
                      The parameter is followed by "[default]" if it is the default value given through a 
                      Set method.  Otherwise, if the parameter was unused (not accessed through a Get method), 
                      it will be followed by "[unused]".  This function is called by the "std::ostream& operator<<". 
                  */
                  std::ostream& leftshift(std::ostream& os, bool printFlags = true) const;
                
                  /*! \brief Get the string that should be used as the tag name for all parameters when they are serialized
                   * to xml.
                   */
                  static const std::string& getTagName(){
                      static const std::string tagName = "Parameter";
                      return tagName;
                  }
                  
                  //@}
                  
                private:
                
                  //! Reset the entry
                  void reset();
                  
                  //! Templated Datatype
                  any val_;
                
                  //! Has this parameter been accessed by a "get" function?
                  mutable bool isUsed_;
                
                  //! Was this parameter a default value assigned by a "get" function?
                  mutable bool isDefault_;
                
                  //! Optional documentation field
                  std::string  docString_;
                
                  //! Optional validator object
                //use pragmas to disable some false positive warnings for windows sharedlib export
                #ifdef _MSC_VER
                #pragma warning(push)
                #pragma warning(disable:4251)
                #endif
                  RCP<const ParameterEntryValidator> validator_;
                #ifdef _MSC_VER
                #pragma warning(pop)
                #endif
                
                };
                
                /*! \relates ParameterEntry 
                    \brief A templated helper function for returning the value of type \c T held in the ParameterEntry object,
                    where the type \c T can be specified in the call.  This is an easier way to call the getValue method
                    in the ParameterEntry class, since the user does not have to pass in a pointer of type \c T.
                */
                template<typename T>
                inline T& getValue( const ParameterEntry &entry )
                {
                  return entry.getValue(static_cast<T*>(0));
                }
                
                /*! \relates ParameterEntry 
                    \brief A templated helper function for returning the value of type \c T held in the ParameterEntry object,
                    where the type \c T can be specified in the call.  This is an easier way to call the getValue method
                    in the ParameterEntry class, since the user does not have to pass in a pointer of type \c T.
                */
                template<typename T>
                inline T& getValue(RCP<const ParameterEntry> entry)
                {
                  return entry->getValue(static_cast<T*>(0));
                }
                
                /*! \relates ParameterEntry 
                    \brief Returns true if two ParameterEntry objects are equal.
                */
                inline bool operator==(const ParameterEntry& e1, const ParameterEntry& e2) 
                { 
                  return (
                    e1.getAny() == e2.getAny()
                    && e1.isList()== e2.isList()
                    && e1.isUsed() == e2.isUsed()
                    && e1.isDefault() == e2.isDefault()
                    );
                }
                
                /*! \relates ParameterEntry 
                    \brief Returns true if two ParameterEntry objects are <b>not</b> equal.
                */
                inline bool operator!=(const ParameterEntry& e1, const ParameterEntry& e2) 
                { 
                  return !( e1 == e2 );
                }
                
                /*! \relates ParameterEntry 
                    \brief Output stream operator for handling the printing of parameter entries.  
                */
                inline std::ostream& operator<<(std::ostream& os, const ParameterEntry& e) 
                { 
                  return e.leftshift(os);
                }
                
                // ///////////////////////////////////////////
                // Inline and Template Function Definitions
                
                // Constructor/Destructor
                
                template<typename T>
                inline
                ParameterEntry::ParameterEntry(
                  T value_in,
                  bool isDefault_in,
                  bool /*isList_in*/, // 2007/11/26: rabartl: ToDo: This arg is ignored and should be removed!
                  const std::string &docString_in,
                  RCP<const ParameterEntryValidator> const& validator_in
                  )
                  : val_(value_in),
                    isUsed_(false),
                    isDefault_(isDefault_in),
                    docString_(docString_in),
                    validator_(validator_in)
                {}
                
                // Set Methods
                
                template<typename T>
                inline
                void ParameterEntry::setValue(
                  T value_in, bool isDefault_in, const std::string &docString_in,
                  RCP<const ParameterEntryValidator> const& validator_in
                  )
                {
                  val_ = value_in;
                  isDefault_ = isDefault_in;
                  if(docString_in.length())
                    docString_ = docString_in;
                  if(validator_in.get())
                    validator_ = validator_in;
                }
                
                // Get Methods
                
                template<typename T>
                inline
                T& ParameterEntry::getValue(T * /*ptr*/) const
                {
                  isUsed_ = true;
                  return const_cast<T&>(Teuchos::any_cast<T>( val_ ));
                }
                
                inline
                any& ParameterEntry::getAny(bool activeQry)
                { 
                  if (activeQry == true) {
                    isUsed_ = true;
                  }
                  return val_; 
                }
                
                inline
                const any& ParameterEntry::getAny(bool activeQry) const
                { 
                  if (activeQry == true) {
                    isUsed_ = true;
                  }
                  return val_; 
                }
                
                // Attribute Methods
                
                inline
                bool ParameterEntry::isUsed() const
                { return isUsed_; }
                
                template <typename T>
                inline
                bool ParameterEntry::isType() const
                { return val_.type() == typeid(T); }
                
                inline
                bool ParameterEntry::isDefault() const
                { return isDefault_; }
                
                inline
                std::string ParameterEntry::docString() const
                { return docString_; }
                
                inline
                RCP<const ParameterEntryValidator>
                ParameterEntry::validator() const
                { return validator_; }
                
                
                } // namespace Teuchos
                
                
                #endif


Top 10 Lines:

     Line      Count

       67         19

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       19   Total number of line executions
    19.00   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
           2 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, ++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
                        __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      typedef typename iterator_traits<_InputIterator>::reference _RefType;
                      const bool __assignable = is_assignable<_ValueType1, _RefType>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static void
       ##### ->         __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static void
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { std::fill_n(__first, __n, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
                    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    void
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline void
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill(__first, __last, _ValueType());
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static void
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static void
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill_n(__first, __n, _ValueType());
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default constructed value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline void
                    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_n_1<__is_trivial(_ValueType)
                				       && __assignable>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s), constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with n default constructed value_types(s),
                  // constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    void
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { std::__uninitialized_default_n(__first, __n); }
                
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

       68          2

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/basic_string.tcc:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                // Written by Jason Merrill based upon the specification by Takanori Adachi
                // in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
                
                #ifndef _BASIC_STRING_TCC
                #define _BASIC_STRING_TCC 1
                
                #pragma GCC system_header
                
                #include <bits/cxxabi_forced.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const _CharT
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_terminal = _CharT();
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
                  // at static init time (before static ctors are run).
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
                    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
                      sizeof(size_type)];
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   input_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// Avoid reallocation for common case.
                	_CharT __buf[128];
                	size_type __len = 0;
                	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
                	  {
                	    __buf[__len++] = *__beg;
                	    ++__beg;
                	  }
                	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
                	_M_copy(__r->_M_refdata(), __buf, __len);
                	__try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __r->_M_capacity)
                		  {
                		    // Allocate more space.
                		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
                		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
                		    __r->_M_destroy(__a);
                		    __r = __another;
                		  }
                		__r->_M_refdata()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__len);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template <typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   forward_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// NB: Not required, but considered best practice.
                	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                	  __throw_logic_error(__N("basic_string::_S_construct null not valid"));
                
                	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
                								      __end));
                	// Check for out_of_range and length_error exceptions.
                	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
                	__try
                	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__dnew);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::
                    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (__n == 0 && __a == _Alloc())
                	return _S_empty_rep()._M_refdata();
                #endif
                      // Check for out_of_range and length_error exceptions.
                      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
                      if (__n)
                	_M_assign(__r->_M_refdata(), __n, __c);
                
                      __r->_M_set_length_and_sharable(__n);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str)
                    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
                					  __str.get_allocator()),
                		  __str.get_allocator())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _Alloc& __a)
                    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos, size_type __n)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, _Alloc()), _Alloc())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos,
                		 size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                			       __s + npos, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__n, __c, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
                    { }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
                    { }
                #endif
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const basic_string& __str)
                    {
                      if (_M_rep() != __str._M_rep())
                	{
                	  // XXX MT
                	  const allocator_type __a = this->get_allocator();
                	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      _M_check_length(this->size(), __n, "basic_string::assign");
                      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                	return _M_replace_safe(size_type(0), this->size(), __s, __n);
                      else
                	{
                	  // Work in-place.
                	  const size_type __pos = __s - _M_data();
                	  if (__pos >= __n)
                	    _M_copy(_M_data(), __s, __n);
                	  else if (__pos)
                	    _M_move(_M_data(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__n);
                	  return *this;
                	}
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(size_type __n, _CharT __c)
                    {
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");	  
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_assign(_M_data() + this->size(), __n, __c);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    {
                	      if (_M_disjunct(__s))
                		this->reserve(__len);
                	      else
                		{
                		  const size_type __off = __s - _M_data();
                		  this->reserve(__len);
                		  __s = _M_data() + __off;
                		}
                	    }
                	  _M_copy(_M_data() + this->size(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str)
                    {
                      const size_type __size = __str.size();
                      if (__size)
                	{
                	  const size_type __len = __size + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }    
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str, size_type __pos, size_type __n)
                    {
                      __str._M_check(__pos, "basic_string::append");
                      __n = __str._M_limit(__pos, __n);
                      if (__n)
                	{
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);	  
                	}
                      return *this;
                    }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     insert(size_type __pos, const _CharT* __s, size_type __n)
                     {
                       __glibcxx_requires_string_len(__s, __n);
                       _M_check(__pos, "basic_string::insert");
                       _M_check_length(size_type(0), __n, "basic_string::insert");
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, size_type(0), __s, __n);
                       else
                         {
                           // Work in-place.
                           const size_type __off = __s - _M_data();
                           _M_mutate(__pos, 0, __n);
                           __s = _M_data() + __off;
                           _CharT* __p = _M_data() + __pos;
                           if (__s  + __n <= __p)
                             _M_copy(__p, __s, __n);
                           else if (__s >= __p)
                             _M_copy(__p, __s + __n, __n);
                           else
                             {
                	       const size_type __nleft = __p - __s;
                               _M_copy(__p, __s, __nleft);
                               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
                             }
                           return *this;
                         }
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     typename basic_string<_CharT, _Traits, _Alloc>::iterator
                     basic_string<_CharT, _Traits, _Alloc>::
                     erase(iterator __first, iterator __last)
                     {
                       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last
                				&& __last <= _M_iend());
                
                       // NB: This isn't just an optimization (bail out early when
                       // there is nothing to do, really), it's also a correctness
                       // issue vs MT, see libstdc++/40518.
                       const size_type __size = __last - __first;
                       if (__size)
                	 {
                	   const size_type __pos = __first - _M_ibegin();
                	   _M_mutate(__pos, __size, size_type(0));
                	   _M_rep()->_M_set_leaked();
                	   return iterator(_M_data() + __pos);
                	 }
                       else
                	 return __first;
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     replace(size_type __pos, size_type __n1, const _CharT* __s,
                	     size_type __n2)
                     {
                       __glibcxx_requires_string_len(__s, __n2);
                       _M_check(__pos, "basic_string::replace");
                       __n1 = _M_limit(__pos, __n1);
                       _M_check_length(__n1, __n2, "basic_string::replace");
                       bool __left;
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, __n1, __s, __n2);
                       else if ((__left = __s + __n2 <= _M_data() + __pos)
                		|| _M_data() + __pos + __n1 <= __s)
                	 {
                	   // Work in-place: non-overlapping case.
                	   size_type __off = __s - _M_data();
                	   __left ? __off : (__off += __n2 - __n1);
                	   _M_mutate(__pos, __n1, __n2);
                	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
                	   return *this;
                	 }
                       else
                	 {
                	   // Todo: overlapping case.
                	   const basic_string __tmp(__s, __n2);
                	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
                	 }
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_destroy(const _Alloc& __a) throw ()
                    {
                      const size_type __size = sizeof(_Rep_base) +
                	                       (this->_M_capacity + 1) * sizeof(_CharT);
                      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_leak_hard()
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (_M_rep() == &_S_empty_rep())
                	return;
                #endif
                      if (_M_rep()->_M_is_shared())
                	_M_mutate(0, 0, 0);
                      _M_rep()->_M_set_leaked();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
                    {
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                      const size_type __how_much = __old_size - __pos - __len1;
                
                      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
                	{
                	  // Must reallocate.
                	  const allocator_type __a = get_allocator();
                	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
                
                	  if (__pos)
                	    _M_copy(__r->_M_refdata(), _M_data(), __pos);
                	  if (__how_much)
                	    _M_copy(__r->_M_refdata() + __pos + __len2,
                		    _M_data() + __pos + __len1, __how_much);
                
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__r->_M_refdata());
                	}
                      else if (__how_much && __len1 != __len2)
                	{
                	  // Work in-place.
                	  _M_move(_M_data() + __pos + __len2,
                		  _M_data() + __pos + __len1, __how_much);
                	}
                      _M_rep()->_M_set_length_and_sharable(__new_size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      if (__res != this->capacity() || _M_rep()->_M_is_shared())
                        {
                	  // Make sure we don't shrink below the current size
                	  if (__res < this->size())
                	    __res = this->size();
                	  const allocator_type __a = get_allocator();
                	  _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                        }
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s)
                    {
                      if (_M_rep()->_M_is_leaked())
                	_M_rep()->_M_set_sharable();
                      if (__s._M_rep()->_M_is_leaked())
                	__s._M_rep()->_M_set_sharable();
                      if (this->get_allocator() == __s.get_allocator())
                	{
                	  _CharT* __tmp = _M_data();
                	  _M_data(__s._M_data());
                	  __s._M_data(__tmp);
                	}
                      // The code below can usually be optimized away.
                      else
                	{
                	  const basic_string __tmp1(_M_ibegin(), _M_iend(),
                				    __s.get_allocator());
                	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                				    this->get_allocator());
                	  *this = __tmp2;
                	  __s = __tmp1;
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _S_create(size_type __capacity, size_type __old_capacity,
                	      const _Alloc& __alloc)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > _S_max_size)
                	__throw_length_error(__N("basic_string::_S_create"));
                
                      // The standard places no restriction on allocating more memory
                      // than is strictly needed within this layer at the moment or as
                      // requested by an explicit application call to reserve().
                
                      // Many malloc implementations perform quite poorly when an
                      // application attempts to allocate memory in a stepwise fashion
                      // growing each allocation size by only 1 char.  Additionally,
                      // it makes little sense to allocate less linear memory than the
                      // natural blocking size of the malloc implementation.
                      // Unfortunately, we would need a somewhat low-level calculation
                      // with tuned parameters to get this perfect for any particular
                      // malloc implementation.  Fortunately, generalizations about
                      // common features seen among implementations seems to suffice.
                
                      // __pagesize need not match the actual VM page size for good
                      // results in practice, thus we pick a common value on the low
                      // side.  __malloc_header_size is an estimate of the amount of
                      // overhead per memory allocation (in practice seen N * sizeof
                      // (void*) where N is 0, 2 or 4).  According to folklore,
                      // picking this value on the high side is better than
                      // low-balling it (especially when this algorithm is used with
                      // malloc implementations that allocate memory blocks rounded up
                      // to a size which is a power of 2).
                      const size_type __pagesize = 4096;
                      const size_type __malloc_header_size = 4 * sizeof(void*);
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      // It's active for allocations requiring an amount of memory above
                      // system pagesize. This is consistent with the requirements of the
                      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	__capacity = 2 * __old_capacity;
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element, plus enough for the _Rep data structure.
                      // Whew. Seemingly so needy, yet so elemental.
                      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                
                      const size_type __adj_size = __size + __malloc_header_size;
                      if (__adj_size > __pagesize && __capacity > __old_capacity)
                	{
                	  const size_type __extra = __pagesize - __adj_size % __pagesize;
                	  __capacity += __extra / sizeof(_CharT);
                	  // Never allocate a string bigger than _S_max_size.
                	  if (__capacity > _S_max_size)
                	    __capacity = _S_max_size;
                	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                	}
                
                      // NB: Might throw, but no worries about a leak, mate: _Rep()
                      // does not throw.
                      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
                      _Rep *__p = new (__place) _Rep;
                      __p->_M_capacity = __capacity;
                      // ABI compatibility - 3.4.x set in _S_create both
                      // _M_refcount and _M_length.  All callers of _S_create
                      // in basic_string.tcc then set just _M_length.
                      // In 4.0.x and later both _M_refcount and _M_length
                      // are initialized in the callers, unfortunately we can
                      // have 3.4.x compiled code with _S_create callers inlined
                      // calling 4.0.x+ _S_create.
                      __p->_M_set_sharable();
                      return __p;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_clone(const _Alloc& __alloc, size_type __res)
                    {
                      // Requested capacity of the clone.
                      const size_type __requested_cap = this->_M_length + __res;
                      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
                				  __alloc);
                      if (this->_M_length)
                	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
                
                      __r->_M_set_length_and_sharable(this->_M_length);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      _M_check_length(__size, __n, "basic_string::resize");
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->erase(__n);
                      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			  _InputIterator __k2, __false_type)
                      {
                	const basic_string __s(__k1, __k2);
                	const size_type __n1 = __i2 - __i1;
                	_M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
                	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
                			       __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_assign(_M_data() + __pos1, __n2, __c);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		    size_type __n2)
                    {
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_copy(_M_data() + __pos1, __s, __n2);
                      return *this;
                    }
                   
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
          12 ->     operator+(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      __glibcxx_requires_string(__lhs);
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      const __size_type __len = _Traits::length(__lhs);
                      __string_type __str;
                      __str.reserve(__len + __rhs.size());
                      __str.append(__lhs, __len);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      __string_type __str;
                      const __size_type __len = __rhs.size();
                      __str.reserve(__len + 1);
                      __str.append(__size_type(1), __lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_M_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      const _CharT* __data = _M_data();
                
                      if (__n == 0)
                	return __pos <= __size ? __pos : npos;
                
                      if (__n <= __size)
                	{
                	  for (; __pos <= __size - __n; ++__pos)
                	    if (traits_type::eq(__data[__pos], __s[0])
                		&& traits_type::compare(__data + __pos + 1,
                					__s + 1, __n - 1) == 0)
                	      return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __ret = npos;
                      const size_type __size = this->size();
                      if (__pos < __size)
                	{
                	  const _CharT* __data = _M_data();
                	  const size_type __n = __size - __pos;
                	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
                	  if (__p)
                	    __ret = __p - __data;
                	}
                      return __ret;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      if (__n <= __size)
                	{
                	  __pos = std::min(size_type(__size - __n), __pos);
                	  const _CharT* __data = _M_data();
                	  do
                	    {
                	      if (traits_type::compare(__data + __pos, __s, __n) == 0)
                		return __pos;
                	    }
                	  while (__pos-- > 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  for (++__size; __size-- > 0; )
                	    if (traits_type::eq(_M_data()[__size], __c))
                	      return __size;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __n && __pos < this->size(); ++__pos)
                	{
                	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
                	  if (__p)
                	    return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size && __n)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size-- != 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::find(__s, __n, _M_data()[__pos]))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::eq(_M_data()[__pos], __c))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::eq(_M_data()[__size], __c))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n, const basic_string& __str) const
                    {
                      _M_check(__pos, "basic_string::compare");
                      __n = _M_limit(__pos, __n);
                      const size_type __osize = __str.size();
                      const size_type __len = std::min(__n, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
                      if (!__r)
                	__r = _S_compare(__n, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	    size_type __pos2, size_type __n2) const
                    {
                      _M_check(__pos1, "basic_string::compare");
                      __str._M_check(__pos2, "basic_string::compare");
                      __n1 = _M_limit(__pos1, __n1);
                      __n2 = __str._M_limit(__pos2, __n2);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos1,
                				     __str.data() + __pos2, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      const size_type __size = this->size();
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__size, __osize);
                      int __r = traits_type::compare(_M_data(), __s, __len);
                      if (!__r)
                	__r = _S_compare(__size, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__n1, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s,
                	    size_type __n2) const
                    {
                      __glibcxx_requires_string_len(__s, __n2);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  // 21.3.7.9 basic_string::getline and operators
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __in,
                	       basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                      typedef ctype<_CharT>				__ctype_type;
                      typedef typename __ctype_type::ctype_base         __ctype_base;
                
                      __size_type __extracted = 0;
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, false);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      // Avoid reallocation for common case.
                	      __str.erase();
                	      _CharT __buf[128];
                	      __size_type __len = 0;	      
                	      const streamsize __w = __in.width();
                	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                		                              : __str.max_size();
                	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !__ct.is(__ctype_base::space,
                				 _Traits::to_char_type(__c)))
                		{
                		  if (__len == sizeof(__buf) / sizeof(_CharT))
                		    {
                		      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                		      __len = 0;
                		    }
                		  __buf[__len++] = _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                	      __str.append(__buf, __len);
                
                	      if (_Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      __in.width(0);
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      // 211.  operator>>(istream&, string&) doesn't set failbit
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __in,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                
                      __size_type __extracted = 0;
                      const __size_type __n = __str.max_size();
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, true);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      __str.erase();
                	      const __int_type __idelim = _Traits::to_int_type(__delim);
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !_Traits::eq_int_type(__c, __idelim))
                		{
                		  __str += _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                
                	      if (_Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      else if (_Traits::eq_int_type(__c, __idelim))
                		{
                		  ++__extracted;		  
                		  __in.rdbuf()->sbumpc();
                		}
                	      else
                		__err |= __ios_base::failbit;
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE > 0
                  extern template class basic_string<char>;
                  extern template
                    basic_istream<char>&
                    operator>>(basic_istream<char>&, string&);
                  extern template
                    basic_ostream<char>&
                    operator<<(basic_ostream<char>&, const string&);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&, char);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  extern template class basic_string<wchar_t>;
                  extern template
                    basic_istream<wchar_t>&
                    operator>>(basic_istream<wchar_t>&, wstring&);
                  extern template
                    basic_ostream<wchar_t>&
                    operator<<(basic_ostream<wchar_t>&, const wstring&);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&);
                #endif
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      692         12

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       12   Total number of line executions
    12.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_Map.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef XPETRA_MAP_HPP
                #define XPETRA_MAP_HPP
                
                /* this file is automatically generated - do not edit (see script/interfaces.py) */
                
                #include "Xpetra_ConfigDefs.hpp"
                #include <Kokkos_DefaultNode.hpp>
                #include <Teuchos_Describable.hpp>
                
                #ifdef HAVE_XPETRA_EPETRA
                #include "Epetra_config.h"
                #endif
                
                namespace Xpetra {
                
                  // TODO move this typedef to another place
                  // Node which is used for Epetra. This can be either the
                  // Serial node or OpenMP node (but not both)
                #ifdef HAVE_XPETRA_EPETRA
                # ifdef EPETRA_HAVE_OMP
                  typedef Kokkos::Compat::KokkosOpenMPWrapperNode EpetraNode;
                # else
                  typedef Kokkos::Compat::KokkosSerialWrapperNode EpetraNode;
                # endif
                #endif
                
                  enum UnderlyingLib {
                    UseEpetra,
                    UseTpetra,
                    NotSpecified
                  };
                
                  template <class LocalOrdinal = int,
                            class GlobalOrdinal = LocalOrdinal,
                            class Node = KokkosClassic::DefaultNode::DefaultNodeType>
                  class Map
                    : public Teuchos::Describable
                  {
                  public:
                    typedef LocalOrdinal local_ordinal_type;
                    typedef GlobalOrdinal global_ordinal_type;
                    typedef Node node_type;
                
                    //! @name Constructor/Destructor Methods
                    //@{
                
                    //! Destructor.
                    virtual ~Map() { }
                
                   //@}
                
                    //! @name Attributes
                    //@{
                
                    //! The number of elements in this Map.
                    virtual global_size_t getGlobalNumElements() const = 0;
                
                    //! The number of elements belonging to the calling process.
                    virtual size_t getNodeNumElements() const = 0;
                
                    //! The index base for this Map.
                    virtual GlobalOrdinal getIndexBase() const = 0;
                
                    //! The minimum local index.
                    virtual LocalOrdinal getMinLocalIndex() const = 0;
                
                    //! The maximum local index on the calling process.
                    virtual LocalOrdinal getMaxLocalIndex() const = 0;
                
                    //! The minimum global index owned by the calling process.
                    virtual GlobalOrdinal getMinGlobalIndex() const = 0;
                
                    //! The maximum global index owned by the calling process.
                    virtual GlobalOrdinal getMaxGlobalIndex() const = 0;
                
                    //! The minimum global index over all processes in the communicator.
                    virtual GlobalOrdinal getMinAllGlobalIndex() const = 0;
                
                    //! The maximum global index over all processes in the communicator.
                    virtual GlobalOrdinal getMaxAllGlobalIndex() const = 0;
                
                    //! The local index corresponding to the given global index.
                    virtual LocalOrdinal getLocalElement(GlobalOrdinal globalIndex) const = 0;
                
                    //! The global index corresponding to the given local index.
                    virtual GlobalOrdinal getGlobalElement(LocalOrdinal localIndex) const = 0;
                
                    //! Return the process ranks and corresponding local indices for the given global indices.
                    virtual LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList, const Teuchos::ArrayView< LocalOrdinal > &LIDList) const = 0;
                
                    //! Return the process ranks for the given global indices.
                    virtual LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList) const = 0;
                
                    //! Return a view of the global indices owned by this process.
                    virtual Teuchos::ArrayView< const GlobalOrdinal > getNodeElementList() const = 0;
                
                    //@}
                
                    //! @name Boolean tests
                    //@{
                
                    //! Whether the given local index is valid for this Map on this process.
                    virtual bool isNodeLocalElement(LocalOrdinal localIndex) const = 0;
                
                    //! Whether the given global index is valid for this Map on this process.
                    virtual bool isNodeGlobalElement(GlobalOrdinal globalIndex) const = 0;
                
                    //! True if this Map is distributed contiguously, else false.
                    virtual bool isContiguous() const = 0;
                
                    //! Whether this Map is globally distributed or locally replicated.
                    virtual bool isDistributed() const = 0;
                
                    //! True if and only if map is compatible with this Map.
                    virtual bool isCompatible(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const = 0;
                
                    //! True if and only if map is identical to this Map.
                    virtual bool isSameAs(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const = 0;
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Get this Map's Comm object.
                    virtual Teuchos::RCP< const Teuchos::Comm< int > > getComm() const = 0;
                
                    //! Get this Map's Node object.
                    virtual Teuchos::RCP< Node > getNode() const = 0;
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Return a simple one-line description of this object.
                    virtual std::string description() const = 0;
                
                    //! Print this object with the given verbosity level to the given Teuchos::FancyOStream.
                    virtual void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const = 0;
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Return a new Map with processes with zero elements removed.
                    virtual RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > removeEmptyProcesses() const = 0;
                
                    //! Replace this Map's communicator with a subset communicator.
                    virtual RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > replaceCommWithSubset(const Teuchos::RCP< const Teuchos::Comm< int > > &newComm) const = 0;
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! Get the library used by this object (Tpetra or Epetra?)
                    virtual UnderlyingLib lib() const = 0;
                
                    // TODO: find a better solution for this hack
                    // The problem is that EpetraMap, TpetraMap and StridedMap all inherit Map. To have proper toEpetra() we
                    // need to understand the type of underlying matrix. But in src/Map we have no knowledge of StridedMaps, so
                    // we cannot check for it by casting. This function allows us to avoid the restriction, as StridedMap redefines
                    // it to return the base map.
           1 ->     virtual RCP<const Xpetra::Map<LocalOrdinal, GlobalOrdinal, Node> > getMap() const { return rcpFromRef(*this); }
                
                    //@}
                
                  }; // Map class
                
                } // Xpetra namespace
                
                #define XPETRA_MAP_SHORT
                #endif // XPETRA_MAP_HPP


Top 10 Lines:

     Line      Count

      211          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/KokkosCompat_ClassicNodeAPI_Wrapper.hpp:
                #ifndef KOKKOSCOMPAT_CLASSICNODEAPI_WRAPPER_HPP
                #define KOKKOSCOMPAT_CLASSICNODEAPI_WRAPPER_HPP
                
                #include "TeuchosKokkosCompat_config.h"
                #include "KokkosCompat_View.hpp"
                #include "Kokkos_Core.hpp"
                #include "Teuchos_ParameterList.hpp"
                
                #ifdef KOKKOS_HAVE_CUDA
                  #ifndef KERNEL_PREFIX
                    #ifdef __CUDACC__
                    #define KERNEL_PREFIX __host__ __device__
                    #endif
                  #endif
                #endif
                
                namespace Kokkos {
                namespace Compat {
                namespace Details {
                
                /// \brief Get the value of the "Verbose" parameter as a \c bool.
                ///
                /// This method lets the "Verbose" parameter have type either \c int
                /// or \c bool, and returns its value as \c bool.  If the "Verbose"
                /// parameter does not exist in the given list, return the default
                /// value, which is \c false.
                bool
                getVerboseParameter (const Teuchos::ParameterList& params);
                
                Teuchos::ParameterList getDefaultNodeParameters ();
                
                } // namespace Details
                
                /// \brief Node that wraps a new Kokkos execution space.
                /// \tparam ExecutionSpace The type of the Kokkos execution space to wrap.
                /// \tparam MemorySpace The Kokkos memory space in which to work.
                ///   Defaults to the default memory space of ExecutionSpace.
                /// \ingroup kokkos_node_api
                template<class ExecutionSpace,
                         class MemorySpace = typename ExecutionSpace::memory_space>
                class KokkosDeviceWrapperNode {
                public:
                  //! The Node's Kokkos execution space.
                  typedef ExecutionSpace execution_space;
                  //! The Node's Kokkos memory space.
                  typedef MemorySpace memory_space;
                  /// \brief The Node's Kokkos::Device specialization.
                  ///
                  /// This is just an (execution space, memory space) pair.
                  typedef Kokkos::Device<execution_space, memory_space> device_type;
                
                  /// \brief This is NOT a "classic" Node type.
                  ///
                  /// We will deprecate the "classic" Node types with the 11.14
                  /// release of Trilinos, and remove them entirely with the 12.0
                  /// release.  This Node type is safe to use.
                  static const bool classic = false;
                
                  /// \brief Reference count of Node instances.
                  ///
                  /// \warning Do NOT read or modify this.  This is an implementation
                  ///   detail of the class.
                  ///
                  /// If Node originally called ExecutionSpace::initialize() (see
                  /// Github Issue #510), and if the count reaches zero in the
                  /// destructor, we call ExecutionSpace::finalize().
                  static int count;
                
                  /// \brief Is the Node responsible for finalizing its execution space?
                  ///
                  /// \warning Do NOT read or modify this.  This is an implementation
                  ///   detail of the class.
                  ///
                  /// In Node's constructor, was it ever true that count == 0 and
                  /// execution_space::is_initialized()?  If so, this means that
                  /// somebody else (the user, or some other library) initialized the
                  /// execution space before Node got to it.  In that case, the Node's
                  /// destructor should NOT call (is not responsible for calling)
                  /// execution_space::finalize().
                  ///
                  /// This fixes Github Issue #510.
                  static bool nodeResponsibleForFinalizingExecutionSpace_;
                
                  /// \brief Constructor (that takes a Teuchos::ParameterList).
                  ///
                  /// \param [in/out] params List of Node configuration parameters.
                  ///   If empty, we use defaults.
                  KokkosDeviceWrapperNode (Teuchos::ParameterList& params);
                
                  //! Default constructor (sets default parameters).
                  KokkosDeviceWrapperNode ();
                
                  //! Destructor
                  ~KokkosDeviceWrapperNode ();
                
                  //! Get a filled-in set of parameters for Node, with their default values.
                  static Teuchos::ParameterList getDefaultParameters ()
                  {
                    return Details::getDefaultNodeParameters ();
                  }
                
                  /// \brief Initialize the Node
                  ///
                  /// \warning This is an implementation detail; do not call it directly!
                  void init (int numthreads, int numnuma, int numcorespernuma, int device);
                
                  void sync () const { ExecutionSpace::fence (); }
                
                  /// \brief Return the human-readable name of this Node.
                  ///
                  /// See \ref kokkos_node_api "Kokkos Node API"
                  static std::string name();
                
                private:
                  //! Make sure that the constructor initialized everything.
                  void checkConstructorEnd () const;
                
                  //! Make sure that the destructor did its job.
                  void checkDestructorEnd () const;
                };
                
                #ifdef KOKKOS_HAVE_CUDA
                  typedef KokkosDeviceWrapperNode<Kokkos::Cuda> KokkosCudaWrapperNode;
                #endif
                
                #ifdef KOKKOS_HAVE_OPENMP
                  typedef KokkosDeviceWrapperNode<Kokkos::OpenMP> KokkosOpenMPWrapperNode;
                #endif
                
                #ifdef KOKKOS_HAVE_PTHREAD
                  typedef KokkosDeviceWrapperNode<Kokkos::Threads> KokkosThreadsWrapperNode;
                #endif
                
                #ifdef KOKKOS_HAVE_SERIAL
                  typedef KokkosDeviceWrapperNode<Kokkos::Serial> KokkosSerialWrapperNode;
                #endif // KOKKOS_HAVE_SERIAL
                
                  // These definitions / initializations of class (static) variables
                  // need to precede the first use of these variables.  Otherwise,
                  // CUDA 7.5 with GCC 4.8.4 emits a warning ("explicit specialization
                  // of member ... must precede its first use").
                
                  template<class ExecutionSpace, class MemorySpace>
                  int KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::count = 0;
                
                  template<class ExecutionSpace, class MemorySpace>
                  bool KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::nodeResponsibleForFinalizingExecutionSpace_ = true;
                
                  template<class ExecutionSpace, class MemorySpace>
           1 ->   KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::
                  KokkosDeviceWrapperNode (Teuchos::ParameterList& params)
                  {
                    // Fix for Github Issue #510.  If count is zero, yet the execution
                    // space is already initialized, then Node is not responsible for
                    // finalizing the execution space.
                    if (count == 0 && ExecutionSpace::is_initialized ()) {
                      nodeResponsibleForFinalizingExecutionSpace_ = false;
                    }
                #ifdef KOKKOS_HAVE_CUDA
                    // The Cuda Node also handles its host execution space.
                    typedef ::Kokkos::HostSpace::execution_space host_execution_space;
                    if (count == 0 &&
                        std::is_same<ExecutionSpace, ::Kokkos::Cuda>::value &&
                        host_execution_space::is_initialized ()) {
                      KokkosDeviceWrapperNode<host_execution_space>::nodeResponsibleForFinalizingExecutionSpace_ = false;
                    }
                #endif // KOKKOS_HAVE_CUDA
                
                    // Kokkos insists that if Kokkos::Cuda is initialized, then its
                    // host execution space must also be initialized.  Thus, it
                    // suffices to check whether Kokkos::Cuda has been initialized; we
                    // don't also have to check the host execution space.
                    if (count == 0 && nodeResponsibleForFinalizingExecutionSpace_) {
                      int curNumThreads = -1; // -1 says "let Kokkos pick"
                      if (params.isType<int> ("Num Threads")) {
                        curNumThreads = params.get<int> ("Num Threads");
                      }
                      int curNumNUMA = -1; // -1 says "let Kokkos pick"
                      if (params.isType<int> ("Num NUMA")) {
                        curNumNUMA = params.get<int> ("Num NUMA");
                      }
                      int curNumCoresPerNUMA = -1; // -1 says "let Kokkos pick"
                      if (params.isType<int> ("Num CoresPerNUMA")) {
                        curNumCoresPerNUMA = params.get<int> ("Num CoresPerNUMA");
                      }
                      int curDevice = 0; // -1 does NOT say "let Kokkos pick" for Cuda Devices
                      if (params.isType<int> ("Device")) {
                        curDevice = params.get<int> ("Device");
                      }
                      const bool verbose = Details::getVerboseParameter (params);
                
                      if (verbose) {
                        std::ostream& out = std::cout;
                        out << "DeviceWrapperNode with ExecutionSpace = "
                            << typeid (ExecutionSpace).name () << " initializing with "
                            << "\"Num Threads\" = " << curNumThreads
                            << ", \"Num NUMA\" = " << curNumNUMA
                            << ", \"Num CoresPerNUMA\" = " << curNumCoresPerNUMA
                            << " \"Device\" = " << curDevice << std::endl;
                      }
                      init (curNumThreads, curNumNUMA, curNumCoresPerNUMA, curDevice);
                    }
                    count++;
                    checkConstructorEnd ();
                  }
                
                  template<class ExecutionSpace, class MemorySpace>
                  KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::
                  KokkosDeviceWrapperNode ()
                  {
                    if (count == 0 && nodeResponsibleForFinalizingExecutionSpace_) {
                      const int curNumThreads = -1; // -1 means "let Kokkos pick"
                      const int curNumNUMA = -1;
                      const int curNumCoresPerNUMA = -1;
                      const int curDevice = 0;
                
                      init (curNumThreads, curNumNUMA, curNumCoresPerNUMA, curDevice);
                    }
                    count++;
                    checkConstructorEnd ();
                  }
                
                  template<class ExecutionSpace, class MemorySpace>
                  void
           1 ->   KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::
                  checkConstructorEnd () const
                  {
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (count <= 0, std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace="
                       << typeid (ExecutionSpace).name () << ", MemorySpace="
                       << typeid (MemorySpace).name () << " > constructor: "
                       "count = " << count << " <= 0 at end of constructor.  "
                       "Please report this bug to the Tpetra developers.");
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (! ExecutionSpace::is_initialized (), std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace="
                       << typeid (ExecutionSpace).name () << ", MemorySpace="
                       << typeid (MemorySpace).name () << " > constructor: "
                       "Failed to initialize ExecutionSpace.");
                #ifdef KOKKOS_HAVE_CUDA
                    // This must be outside the macro, since it has a comma.
                    constexpr bool isCuda =
                      std::is_same<ExecutionSpace, Kokkos::Cuda>::value;
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (isCuda && ! Kokkos::HostSpace::execution_space::is_initialized (),
                       std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace=Kokkos::Cuda, "
                       "MemorySpace=" << typeid (MemorySpace).name () << " > constructor: "
                       "Failed to initialize Kokkos::HostSpace::execution_space.");
                #endif // KOKKOS_HAVE_CUDA
                  }
                
                  template<class ExecutionSpace, class MemorySpace>
                  void
                  KokkosDeviceWrapperNode<ExecutionSpace, MemorySpace>::
                  checkDestructorEnd () const
                  {
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (count < 0, std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace="
                       << typeid (ExecutionSpace).name () << ", MemorySpace="
                       << typeid (MemorySpace).name () << " > destructor: "
                       "count = " << count << " < 0 at end of destructor.  "
                       "Please report this bug to the Tpetra developers.");
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (count == 0 &&
                       nodeResponsibleForFinalizingExecutionSpace_ &&
                       ExecutionSpace::is_initialized (),
                       std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace="
                       << typeid (ExecutionSpace).name () << ", MemorySpace="
                       << typeid (MemorySpace).name () << " > destructor: "
                       "count == 0 and the Node is responsible for finalizing ExecutionSpace, "
                       "but its destructor did not.  "
                       "Please report this bug to the Tpetra developers.");
                #ifdef KOKKOS_HAVE_CUDA
                    // This must be outside the macro, since it has a comma.
                    constexpr bool isCuda =
                      std::is_same<ExecutionSpace, Kokkos::Cuda>::value;
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (isCuda &&
                       count == 0 &&
                       KokkosDeviceWrapperNode<Kokkos::HostSpace::execution_space>::nodeResponsibleForFinalizingExecutionSpace_ &&
                       Kokkos::HostSpace::execution_space::is_initialized (),
                       std::logic_error,
                       "Kokkos::Compat::KokkosDeviceWrapperNode<ExecutionSpace=Kokkos::Cuda, "
                       "MemorySpace=" << typeid (MemorySpace).name () << " > destructor: "
                       "count == 0 and the Node is responsible for finalizing "
                       "Kokkos::HostSpace::execution_space, but its destructor did not.  "
                       "Please report this bug to the Tpetra developers.");
                #endif // KOKKOS_HAVE_CUDA
                  }
                
                } // namespace Compat
                } // namespace Kokkos
                #endif


Top 10 Lines:

     Line      Count

      150          1
      225          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/deque.tcc:
                // Deque implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/deque.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{deque}
                 */
                
                #ifndef _DEQUE_TCC
                #define _DEQUE_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201103L
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_default_initialize()
                    {
                      _Map_pointer __cur;
                      __try
                        {
                          for (__cur = this->_M_impl._M_start._M_node;
                	       __cur < this->_M_impl._M_finish._M_node;
                	       ++__cur)
                            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
                					   _M_get_Tp_allocator());
                          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
                					 this->_M_impl._M_finish._M_cur,
                					 _M_get_Tp_allocator());
                        }
                      __catch(...)
                        {
                          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                			_M_get_Tp_allocator());
                          __throw_exception_again;
                        }
                    }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    deque<_Tp, _Alloc>&
                    deque<_Tp, _Alloc>::
                    operator=(const deque& __x)
                    {
                      const size_type __len = size();
                      if (&__x != this)
                	{
                	  if (__len >= __x.size())
                	    _M_erase_at_end(std::copy(__x.begin(), __x.end(),
                				      this->_M_impl._M_start));
                	  else
                	    {
                	      const_iterator __mid = __x.begin() + difference_type(__len);
                	      std::copy(__x.begin(), __mid, this->_M_impl._M_start);
                	      insert(this->_M_impl._M_finish, __mid, __x.end());
                	    }
                	}
                      return *this;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      deque<_Tp, _Alloc>::
                      emplace_front(_Args&&... __args)
                      {
                	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                	  {
                	    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1,
                				    std::forward<_Args>(__args)...);
                	    --this->_M_impl._M_start._M_cur;
                	  }
                	else
                	  _M_push_front_aux(std::forward<_Args>(__args)...);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      deque<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish._M_cur
                	    != this->_M_impl._M_finish._M_last - 1)
                	  {
                	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
                				    std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish._M_cur;
                	  }
                	else
                	  _M_push_back_aux(std::forward<_Args>(__args)...);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      emplace(const_iterator __position, _Args&&... __args)
                      {
                	if (__position._M_cur == this->_M_impl._M_start._M_cur)
                	  {
                	    emplace_front(std::forward<_Args>(__args)...);
                	    return this->_M_impl._M_start;
                	  }
                	else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                	  {
                	    emplace_back(std::forward<_Args>(__args)...);
                	    iterator __tmp = this->_M_impl._M_finish;
                	    --__tmp;
                	    return __tmp;
                	  }
                	else
                	  return _M_insert_aux(__position._M_const_cast(),
                			       std::forward<_Args>(__args)...);
                      }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      if (__position._M_cur == this->_M_impl._M_start._M_cur)
                	{
                	  push_front(__x);
                	  return this->_M_impl._M_start;
                	}
                      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                	{
                	  push_back(__x);
                	  iterator __tmp = this->_M_impl._M_finish;
                	  --__tmp;
                	  return __tmp;
                	}
                      else
                	return _M_insert_aux(__position._M_const_cast(), __x);
                   }
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      iterator __next = __position;
                      ++__next;
                      const difference_type __index = __position - begin();
                      if (static_cast<size_type>(__index) < (size() >> 1))
                	{
                	  if (__position != begin())
                	    _GLIBCXX_MOVE_BACKWARD3(begin(), __position, __next);
                	  pop_front();
                	}
                      else
                	{
                	  if (__next != end())
                	    _GLIBCXX_MOVE3(__next, end(), __position);
                	  pop_back();
                	}
                      return begin() + __index;
                    }
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first == __last)
                	return __first;
                      else if (__first == begin() && __last == end())
                	{
                	  clear();
                	  return end();
                	}
                      else
                	{
                	  const difference_type __n = __last - __first;
                	  const difference_type __elems_before = __first - begin();
                	  if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
                	    {
                	      if (__first != begin())
                		_GLIBCXX_MOVE_BACKWARD3(begin(), __first, __last);
                	      _M_erase_at_begin(begin() + __n);
                	    }
                	  else
                	    {
                	      if (__last != end())
                		_GLIBCXX_MOVE3(__last, end(), __first);
                	      _M_erase_at_end(end() - __n);
                	    }
                	  return begin() + __elems_before;
                	}
                    }
                
                  template <typename _Tp, class _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                        iterator __cur = begin();
                        for (; __first != __last && __cur != end(); ++__cur, ++__first)
                          *__cur = *__first;
                        if (__first == __last)
                          _M_erase_at_end(__cur);
                        else
                          insert(end(), __first, __last);
                      }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
                    {
                      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                	{
                	  iterator __new_start = _M_reserve_elements_at_front(__n);
                	  __try
                	    {
                	      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
                					  __x, _M_get_Tp_allocator());
                	      this->_M_impl._M_start = __new_start;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(__new_start._M_node,
                			       this->_M_impl._M_start._M_node);
                	      __throw_exception_again;
                	    }
                	}
                      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  __try
                	    {
                	      std::__uninitialized_fill_a(this->_M_impl._M_finish,
                					  __new_finish, __x,
                					  _M_get_Tp_allocator());
                	      this->_M_impl._M_finish = __new_finish;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                      else
                        _M_insert_aux(__pos, __n, __x);
                    }
                
                #if __cplusplus >= 201103L
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n)
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  __try
                	    {
                	      std::__uninitialized_default_a(this->_M_impl._M_finish,
                					     __new_finish,
                					     _M_get_Tp_allocator());
                	      this->_M_impl._M_finish = __new_finish;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                    }
                
                  template <typename _Tp, typename _Alloc>
                    bool
                    deque<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      const difference_type __front_capacity
                	= (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
                      if (__front_capacity == 0)
                	return false;
                
                      const difference_type __back_capacity
                	= (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
                      if (__front_capacity + __back_capacity < _S_buffer_size())
                	return false;
                
                      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
                    }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_fill_initialize(const value_type& __value)
                    {
                      _Map_pointer __cur;
                      __try
                        {
                          for (__cur = this->_M_impl._M_start._M_node;
                	       __cur < this->_M_impl._M_finish._M_node;
                	       ++__cur)
                            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
                					__value, _M_get_Tp_allocator());
                          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
                				      this->_M_impl._M_finish._M_cur,
                				      __value, _M_get_Tp_allocator());
                        }
                      __catch(...)
                        {
                          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                			_M_get_Tp_allocator());
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                                          std::input_iterator_tag)
                      {
                        this->_M_initialize_map(0);
                        __try
                          {
                            for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                              push_back(*__first);
                #endif
                          }
                        __catch(...)
                          {
                            clear();
                            __throw_exception_again;
                          }
                      }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                                          std::forward_iterator_tag)
                      {
                        const size_type __n = std::distance(__first, __last);
                        this->_M_initialize_map(__n);
                
                        _Map_pointer __cur_node;
                        __try
                          {
                            for (__cur_node = this->_M_impl._M_start._M_node;
                                 __cur_node < this->_M_impl._M_finish._M_node;
                                 ++__cur_node)
                	      {
                		_ForwardIterator __mid = __first;
                		std::advance(__mid, _S_buffer_size());
                		std::__uninitialized_copy_a(__first, __mid, *__cur_node,
                					    _M_get_Tp_allocator());
                		__first = __mid;
                	      }
                            std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_finish._M_first,
                					_M_get_Tp_allocator());
                          }
                        __catch(...)
                          {
                            std::_Destroy(this->_M_impl._M_start,
                			  iterator(*__cur_node, __cur_node),
                			  _M_get_Tp_allocator());
                            __throw_exception_again;
                          }
                      }
                
                  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      void
          40 ->       deque<_Tp, _Alloc>::
                      _M_push_back_aux(_Args&&... __args)
                #else
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_back_aux(const value_type& __t)
                #endif
                      {
                	_M_reserve_map_at_back();
                	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
                	__try
                	  {
                #if __cplusplus >= 201103L
                	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
                				    std::forward<_Args>(__args)...);
                #else
                	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
                #endif
                	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
                						+ 1);
                	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
                	  }
                	__catch(...)
                	  {
                	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
                	    __throw_exception_again;
                	  }
                      }
                
                  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_first.
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_front_aux(_Args&&... __args)
                #else
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_front_aux(const value_type& __t)
                #endif
                      {
                	_M_reserve_map_at_front();
                	*(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
                	__try
                	  {
                	    this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
                					       - 1);
                	    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
                #if __cplusplus >= 201103L
                	    this->_M_impl.construct(this->_M_impl._M_start._M_cur,
                				    std::forward<_Args>(__args)...);
                #else
                	    this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
                #endif
                	  }
                	__catch(...)
                	  {
                	    ++this->_M_impl._M_start;
                	    _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
                	    __throw_exception_again;
                	  }
                      }
                
                  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.
                  template <typename _Tp, typename _Alloc>
       ##### ->     void deque<_Tp, _Alloc>::
                    _M_pop_back_aux()
                    {
                      _M_deallocate_node(this->_M_impl._M_finish._M_first);
                      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
                      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
                      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
                    }
                
                  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.
                  // Note that if the deque has at least one element (a precondition for this
                  // member function), and if
                  //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
                  // then the deque must have at least two nodes.
                  template <typename _Tp, typename _Alloc>
                    void deque<_Tp, _Alloc>::
                    _M_pop_front_aux()
                    {
                      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
                      _M_deallocate_node(this->_M_impl._M_start._M_first);
                      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
                      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_insert_aux(iterator __pos,
                                          _InputIterator __first, _InputIterator __last,
                                          std::input_iterator_tag)
                      { std::copy(__first, __last, std::inserter(*this, __pos)); }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_insert_aux(iterator __pos,
                                          _ForwardIterator __first, _ForwardIterator __last,
                                          std::forward_iterator_tag)
                      {
                        const size_type __n = std::distance(__first, __last);
                        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                	  {
                	    iterator __new_start = _M_reserve_elements_at_front(__n);
                	    __try
                	      {
                		std::__uninitialized_copy_a(__first, __last, __new_start,
                					    _M_get_Tp_allocator());
                		this->_M_impl._M_start = __new_start;
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(__new_start._M_node,
                				 this->_M_impl._M_start._M_node);
                		__throw_exception_again;
                	      }
                	  }
                        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                	  {
                	    iterator __new_finish = _M_reserve_elements_at_back(__n);
                	    __try
                	      {
                		std::__uninitialized_copy_a(__first, __last,
                					    this->_M_impl._M_finish,
                					    _M_get_Tp_allocator());
                		this->_M_impl._M_finish = __new_finish;
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                				 __new_finish._M_node + 1);
                		__throw_exception_again;
                	      }
                	  }
                        else
                          _M_insert_aux(__pos, __first, __last, __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos, _Args&&... __args)
                      {
                	value_type __x_copy(std::forward<_Args>(__args)...); // XXX copy
                #else
                    typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos, const value_type& __x)
                      {
                	value_type __x_copy = __x; // XXX copy
                #endif
                	difference_type __index = __pos - this->_M_impl._M_start;
                	if (static_cast<size_type>(__index) < size() / 2)
                	  {
                	    push_front(_GLIBCXX_MOVE(front()));
                	    iterator __front1 = this->_M_impl._M_start;
                	    ++__front1;
                	    iterator __front2 = __front1;
                	    ++__front2;
                	    __pos = this->_M_impl._M_start + __index;
                	    iterator __pos1 = __pos;
                	    ++__pos1;
                	    _GLIBCXX_MOVE3(__front2, __pos1, __front1);
                	  }
                	else
                	  {
                	    push_back(_GLIBCXX_MOVE(back()));
                	    iterator __back1 = this->_M_impl._M_finish;
                	    --__back1;
                	    iterator __back2 = __back1;
                	    --__back2;
                	    __pos = this->_M_impl._M_start + __index;
                	    _GLIBCXX_MOVE_BACKWARD3(__pos, __back2, __back1);
                	  }
                	*__pos = _GLIBCXX_MOVE(__x_copy);
                	return __pos;
                      }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
                    {
                      const difference_type __elems_before = __pos - this->_M_impl._M_start;
                      const size_type __length = this->size();
                      value_type __x_copy = __x;
                      if (__elems_before < difference_type(__length / 2))
                	{
                	  iterator __new_start = _M_reserve_elements_at_front(__n);
                	  iterator __old_start = this->_M_impl._M_start;
                	  __pos = this->_M_impl._M_start + __elems_before;
                	  __try
                	    {
                	      if (__elems_before >= difference_type(__n))
                		{
                		  iterator __start_n = (this->_M_impl._M_start
                					+ difference_type(__n));
                		  std::__uninitialized_move_a(this->_M_impl._M_start,
                					      __start_n, __new_start,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_start = __new_start;
                		  _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                		  std::fill(__pos - difference_type(__n), __pos, __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_move_fill(this->_M_impl._M_start,
                						 __pos, __new_start,
                						 this->_M_impl._M_start,
                						 __x_copy,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_start = __new_start;
                		  std::fill(__old_start, __pos, __x_copy);
                		}
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(__new_start._M_node,
                			       this->_M_impl._M_start._M_node);
                	      __throw_exception_again;
                	    }
                	}
                      else
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  iterator __old_finish = this->_M_impl._M_finish;
                	  const difference_type __elems_after =
                	    difference_type(__length) - __elems_before;
                	  __pos = this->_M_impl._M_finish - __elems_after;
                	  __try
                	    {
                	      if (__elems_after > difference_type(__n))
                		{
                		  iterator __finish_n = (this->_M_impl._M_finish
                					 - difference_type(__n));
                		  std::__uninitialized_move_a(__finish_n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                		  std::fill(__pos, __pos + difference_type(__n), __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_fill_move(this->_M_impl._M_finish,
                						 __pos + difference_type(__n),
                						 __x_copy, __pos,
                						 this->_M_impl._M_finish,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  std::fill(__pos, __old_finish, __x_copy);
                		}
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos,
                                    _ForwardIterator __first, _ForwardIterator __last,
                                    size_type __n)
                      {
                        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
                        const size_type __length = size();
                        if (static_cast<size_type>(__elemsbefore) < __length / 2)
                	  {
                	    iterator __new_start = _M_reserve_elements_at_front(__n);
                	    iterator __old_start = this->_M_impl._M_start;
                	    __pos = this->_M_impl._M_start + __elemsbefore;
                	    __try
                	      {
                		if (__elemsbefore >= difference_type(__n))
                		  {
                		    iterator __start_n = (this->_M_impl._M_start
                					  + difference_type(__n));
                		    std::__uninitialized_move_a(this->_M_impl._M_start,
                						__start_n, __new_start,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_start = __new_start;
                		    _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                		    std::copy(__first, __last, __pos - difference_type(__n));
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, difference_type(__n) - __elemsbefore);
                		    std::__uninitialized_move_copy(this->_M_impl._M_start,
                						   __pos, __first, __mid,
                						   __new_start,
                						   _M_get_Tp_allocator());
                		    this->_M_impl._M_start = __new_start;
                		    std::copy(__mid, __last, __old_start);
                		  }
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(__new_start._M_node,
                				 this->_M_impl._M_start._M_node);
                		__throw_exception_again;
                	      }
                	  }
                        else
                        {
                          iterator __new_finish = _M_reserve_elements_at_back(__n);
                          iterator __old_finish = this->_M_impl._M_finish;
                          const difference_type __elemsafter =
                            difference_type(__length) - __elemsbefore;
                          __pos = this->_M_impl._M_finish - __elemsafter;
                          __try
                            {
                              if (__elemsafter > difference_type(__n))
                		{
                		  iterator __finish_n = (this->_M_impl._M_finish
                					 - difference_type(__n));
                		  std::__uninitialized_move_a(__finish_n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                		  std::copy(__first, __last, __pos);
                		}
                              else
                		{
                		  _ForwardIterator __mid = __first;
                		  std::advance(__mid, __elemsafter);
                		  std::__uninitialized_copy_move(__mid, __last, __pos,
                						 this->_M_impl._M_finish,
                						 this->_M_impl._M_finish,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  std::copy(__first, __mid, __pos);
                		}
                            }
                          __catch(...)
                            {
                              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                              __throw_exception_again;
                            }
                        }
                      }
                
                   template<typename _Tp, typename _Alloc>
                     void
                     deque<_Tp, _Alloc>::
                     _M_destroy_data_aux(iterator __first, iterator __last)
                     {
                       for (_Map_pointer __node = __first._M_node + 1;
                	    __node < __last._M_node; ++__node)
                	 std::_Destroy(*__node, *__node + _S_buffer_size(),
                		       _M_get_Tp_allocator());
                
                       if (__first._M_node != __last._M_node)
                	 {
                	   std::_Destroy(__first._M_cur, __first._M_last,
                			 _M_get_Tp_allocator());
                	   std::_Destroy(__last._M_first, __last._M_cur,
                			 _M_get_Tp_allocator());
                	 }
                       else
                	 std::_Destroy(__first._M_cur, __last._M_cur,
                		       _M_get_Tp_allocator());
                     }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_new_elements_at_front(size_type __new_elems)
                    {
                      if (this->max_size() - this->size() < __new_elems)
                	__throw_length_error(__N("deque::_M_new_elements_at_front"));
                
                      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                				     / _S_buffer_size());
                      _M_reserve_map_at_front(__new_nodes);
                      size_type __i;
                      __try
                        {
                          for (__i = 1; __i <= __new_nodes; ++__i)
                            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
                        }
                      __catch(...)
                        {
                          for (size_type __j = 1; __j < __i; ++__j)
                            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_new_elements_at_back(size_type __new_elems)
                    {
                      if (this->max_size() - this->size() < __new_elems)
                	__throw_length_error(__N("deque::_M_new_elements_at_back"));
                
                      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                				     / _S_buffer_size());
                      _M_reserve_map_at_back(__new_nodes);
                      size_type __i;
                      __try
                        {
                          for (__i = 1; __i <= __new_nodes; ++__i)
                            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
                        }
                      __catch(...)
                        {
                          for (size_type __j = 1; __j < __i; ++__j)
                            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    void
       ##### ->     deque<_Tp, _Alloc>::
                    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
                    {
                      const size_type __old_num_nodes
                	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
                      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
                
                      _Map_pointer __new_nstart;
                      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
                	{
                	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
                					 - __new_num_nodes) / 2
                	                 + (__add_at_front ? __nodes_to_add : 0);
                	  if (__new_nstart < this->_M_impl._M_start._M_node)
                	    std::copy(this->_M_impl._M_start._M_node,
                		      this->_M_impl._M_finish._M_node + 1,
                		      __new_nstart);
                	  else
                	    std::copy_backward(this->_M_impl._M_start._M_node,
                			       this->_M_impl._M_finish._M_node + 1,
                			       __new_nstart + __old_num_nodes);
                	}
                      else
                	{
                	  size_type __new_map_size = this->_M_impl._M_map_size
                	                             + std::max(this->_M_impl._M_map_size,
                						__nodes_to_add) + 2;
                
                	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
                	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                	                 + (__add_at_front ? __nodes_to_add : 0);
                	  std::copy(this->_M_impl._M_start._M_node,
                		    this->_M_impl._M_finish._M_node + 1,
                		    __new_nstart);
                	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                
                	  this->_M_impl._M_map = __new_map;
                	  this->_M_impl._M_map_size = __new_map_size;
                	}
                
                      this->_M_impl._M_start._M_set_node(__new_nstart);
                      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
                    }
                
                  // Overload for deque::iterators, exploiting the "segmented-iterator
                  // optimization".
                  template<typename _Tp>
                    void
                    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
                	 const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                
                      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
                           __node < __last._M_node; ++__node)
                	std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
                
                      if (__first._M_node != __last._M_node)
                	{
                	  std::fill(__first._M_cur, __first._M_last, __value);
                	  std::fill(__last._M_first, __last._M_cur, __value);
                	}
                      else
                	std::fill(__first._M_cur, __last._M_cur, __value);
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  const difference_type __clen
                	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                				       __result._M_last - __result._M_cur));
                	  std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                	  __first += __clen;
                	  __result += __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  difference_type __llen = __last._M_cur - __last._M_first;
                	  _Tp* __lend = __last._M_cur;
                
                	  difference_type __rlen = __result._M_cur - __result._M_first;
                	  _Tp* __rend = __result._M_cur;
                
                	  if (!__llen)
                	    {
                	      __llen = _Self::_S_buffer_size();
                	      __lend = *(__last._M_node - 1) + __llen;
                	    }
                	  if (!__rlen)
                	    {
                	      __rlen = _Self::_S_buffer_size();
                	      __rend = *(__result._M_node - 1) + __rlen;
                	    }
                
                	  const difference_type __clen = std::min(__len,
                						  std::min(__llen, __rlen));
                	  std::copy_backward(__lend - __clen, __lend, __rend);
                	  __last -= __clen;
                	  __result -= __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  const difference_type __clen
                	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                				       __result._M_last - __result._M_cur));
                	  std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                	  __first += __clen;
                	  __result += __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  difference_type __llen = __last._M_cur - __last._M_first;
                	  _Tp* __lend = __last._M_cur;
                
                	  difference_type __rlen = __result._M_cur - __result._M_first;
                	  _Tp* __rend = __result._M_cur;
                
                	  if (!__llen)
                	    {
                	      __llen = _Self::_S_buffer_size();
                	      __lend = *(__last._M_node - 1) + __llen;
                	    }
                	  if (!__rlen)
                	    {
                	      __rlen = _Self::_S_buffer_size();
                	      __rend = *(__result._M_node - 1) + __rlen;
                	    }
                
                	  const difference_type __clen = std::min(__len,
                						  std::min(__llen, __rlen));
                	  std::move_backward(__lend - __clen, __lend, __rend);
                	  __last -= __clen;
                	  __result -= __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      443         40

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       40   Total number of line executions
    13.33   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_CreateXpetraPreconditioner.hpp:
                /*
                 * MueLu_CreateXpetraPreconditioner.hpp
                 *
                 *  Created on: Feb 5, 2016
                 *      Author: tawiesn
                 */
                
                #ifndef PACKAGES_MUELU_ADAPTERS_XPETRA_MUELU_CREATEXPETRAPRECONDITIONER_HPP_
                #define PACKAGES_MUELU_ADAPTERS_XPETRA_MUELU_CREATEXPETRAPRECONDITIONER_HPP_
                
                #include <Teuchos_XMLParameterListHelpers.hpp>
                #include <Xpetra_CrsMatrix.hpp>
                #include <Xpetra_MultiVector.hpp>
                #include <Xpetra_MultiVectorFactory.hpp>
                
                #include <MueLu.hpp>
                
                #include <MueLu_Exceptions.hpp>
                #include <MueLu_Hierarchy.hpp>
                #include <MueLu_MasterList.hpp>
                #include <MueLu_MLParameterListInterpreter.hpp>
                #include <MueLu_ParameterListInterpreter.hpp>
                #include <MueLu_Utilities.hpp>
                #include <MueLu_HierarchyUtils.hpp>
                
                namespace MueLu {
                
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  Teuchos::RCP<MueLu::Hierarchy<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
           1 ->   CreateXpetraPreconditioner(Teuchos::RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > op,
                                             const Teuchos::ParameterList& inParamList,
                                             Teuchos::RCP<Xpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node> > coords = Teuchos::null,
                                             Teuchos::RCP<Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > nullspace = Teuchos::null) {
                    typedef MueLu::HierarchyManager<Scalar,LocalOrdinal,GlobalOrdinal,Node> HierarchyManager;
                    typedef MueLu::HierarchyUtils<Scalar,LocalOrdinal,GlobalOrdinal,Node> HierarchyUtils;
                    typedef MueLu::Hierarchy<Scalar,LocalOrdinal,GlobalOrdinal,Node> Hierarchy;
                    typedef MueLu::MLParameterListInterpreter<Scalar,LocalOrdinal,GlobalOrdinal,Node> MLParameterListInterpreter;
                    typedef MueLu::ParameterListInterpreter<Scalar,LocalOrdinal,GlobalOrdinal,Node> ParameterListInterpreter;
                    typedef Xpetra::MultiVectorFactory<Scalar,LocalOrdinal,GlobalOrdinal,Node> MultiVectorFactory;
                
                    std::string timerName = "MueLu setup time";
                    RCP<Teuchos::Time> tm = Teuchos::TimeMonitor::getNewTimer(timerName);
                    tm->start();
                
                    ParameterList paramList = inParamList;
                
                    bool hasParamList = paramList.numParams();
                
                    RCP<HierarchyManager> mueLuFactory;
                
                    std::string syntaxStr = "parameterlist: syntax";
                    if (hasParamList && paramList.isParameter(syntaxStr) && paramList.get<std::string>(syntaxStr) == "ml") {
                      paramList.remove(syntaxStr);
                      mueLuFactory = rcp(new MLParameterListInterpreter(paramList));
                    } else {
                      mueLuFactory = rcp(new ParameterListInterpreter(paramList,op->getDomainMap()->getComm()));
                    }
                
                    RCP<Hierarchy> H = mueLuFactory->CreateHierarchy();
                    H->setlib(op->getDomainMap()->lib());
                
                
                    // Set fine level operator
                    H->GetLevel(0)->Set("A", op);
                
                    // Set coordinates if available
                    if (coords != Teuchos::null) {
                      H->GetLevel(0)->Set("Coordinates", coords);
                    }
                
                    // Wrap nullspace if available, otherwise use constants
                    if (nullspace == Teuchos::null) {
                      int nPDE = MueLu::MasterList::getDefault<int>("number of equations");
                      if (paramList.isSublist("Matrix")) {
                        // Factory style parameter list
                        const Teuchos::ParameterList& operatorList = paramList.sublist("Matrix");
                        if (operatorList.isParameter("PDE equations"))
                          nPDE = operatorList.get<int>("PDE equations");
                
                      } else if (paramList.isParameter("number of equations")) {
                        // Easy style parameter list
                        nPDE = paramList.get<int>("number of equations");
                      }
                
                      nullspace = MultiVectorFactory::Build(op->getDomainMap(), nPDE);
                      if (nPDE == 1) {
                        nullspace->putScalar(Teuchos::ScalarTraits<Scalar>::one());
                
                      } else {
                        for (int i = 0; i < nPDE; i++) {
                          Teuchos::ArrayRCP<Scalar> nsData = nullspace->getDataNonConst(i);
                          for (int j = 0; j < nsData.size(); j++) {
                            GlobalOrdinal GID = op->getDomainMap()->getGlobalElement(j) - op->getDomainMap()->getIndexBase();
                
                            if ((GID-i) % nPDE == 0)
                              nsData[j] = Teuchos::ScalarTraits<Scalar>::one();
                          }
                        }
                      }
                    }
                    H->GetLevel(0)->Set("Nullspace", nullspace);
                
                
                    Teuchos::ParameterList nonSerialList,dummyList;
                    MueLu::ExtractNonSerializableData(paramList, dummyList, nonSerialList);
                    HierarchyUtils::AddNonSerializableDataToHierarchy(*mueLuFactory,*H, nonSerialList);
                
                    mueLuFactory->SetupHierarchy(*H);
                
                    tm->stop();
                    tm->incrementNumCalls();
                
                    if (H->GetVerbLevel() & Statistics0) {
                      const bool alwaysWriteLocal = true;
                      const bool writeGlobalStats = true;
                      const bool writeZeroTimers  = false;
                      const bool ignoreZeroTimers = true;
                      const std::string filter    = timerName;
                      Teuchos::TimeMonitor::summarize(op->getRowMap()->getComm().ptr(), std::cout, alwaysWriteLocal, writeGlobalStats,
                                                      writeZeroTimers, Teuchos::Union, filter, ignoreZeroTimers);
                    }
                
                    tm->reset();
                
                    return H;
                  }
                
                  /*!
                    @brief Helper function to reuse an existing MueLu preconditioner.
                    @ingroup MueLuAdapters
                
                    @param[in] inA Matrix
                    @param[in] Op  Existing MueLu preconditioner.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  void ReuseXpetraPreconditioner(const Teuchos::RCP<Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& A,
                                                 Teuchos::RCP<MueLu::Hierarchy<Scalar,LocalOrdinal,GlobalOrdinal,Node>>& H) {
                    std::string timerName = "MueLu setup time";
                    RCP<Teuchos::Time> tm = Teuchos::TimeMonitor::getNewTimer(timerName);
                    tm->start();
                
                    typedef Scalar          SC;
                    typedef LocalOrdinal    LO;
                    typedef GlobalOrdinal   GO;
                    typedef Node            NO;
                
                    typedef Xpetra::Matrix<SC,LO,GO,NO>     Matrix;
                    typedef Xpetra::Operator<SC,LO,GO,NO>   Operator;
                
                    TEUCHOS_TEST_FOR_EXCEPTION(!H->GetNumLevels(), Exceptions::RuntimeError,
                                               "MueLu::ReuseXpetraPreconditioner: Hierarchy has no levels in it");
                    TEUCHOS_TEST_FOR_EXCEPTION(!H->GetLevel(0)->IsAvailable("A"), Exceptions::RuntimeError,
                                               "MueLu::ReuseXpetraPreconditioner: Hierarchy has no fine level operator");
                    RCP<Level> level0 = H->GetLevel(0);
                
                    RCP<Operator> O0 = level0->Get<RCP<Operator> >("A");
                    RCP<Matrix>   A0 = Teuchos::rcp_dynamic_cast<Matrix>(O0);
                
                    if (!A0.is_null()) {
                      // If a user provided a "number of equations" argument in a parameter list
                      // during the initial setup, we must honor that settings and reuse it for
                      // all consequent setups.
                      A->SetFixedBlockSize(A0->GetFixedBlockSize());
                    }
                    level0->Set("A", A);
                
                    H->SetupRe();
                
                    tm->stop();
                    tm->incrementNumCalls();
                
                    if (H->GetVerbLevel() & Statistics0) {
                      const bool alwaysWriteLocal = true;
                      const bool writeGlobalStats = true;
                      const bool writeZeroTimers  = false;
                      const bool ignoreZeroTimers = true;
                      const std::string filter    = timerName;
                      Teuchos::TimeMonitor::summarize(A->getRowMap()->getComm().ptr(), std::cout, alwaysWriteLocal, writeGlobalStats,
                                                      writeZeroTimers, Teuchos::Union, filter, ignoreZeroTimers);
                    }
                
                    tm->reset();
                  }
                
                } //namespace
                
                #endif /* PACKAGES_MUELU_ADAPTERS_XPETRA_MUELU_CREATEXPETRAPRECONDITIONER_HPP_ */


Top 10 Lines:

     Line      Count

       30          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <debug/debug.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single %pair of inline functions, which each compile to
                   *  a single @a add instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character %array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static <em>empty string</em> _Rep object already @a constructed before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_type::size_type	    size_type;
                      typedef typename _CharT_alloc_type::difference_type   difference_type;
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                      typedef typename _CharT_alloc_type::pointer	    pointer;
                      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep() _GLIBCXX_NOEXCEPT
                        { 
                	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
                	  // _S_empty_rep_storage is never modified and the punning should
                	  // be reasonably safe in this case.
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount < 0; }
                
                        bool
                	_M_is_shared() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount > 0; }
                
                        void
                	_M_set_leaked() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      this->_M_set_sharable();  // One reference.
                	      this->_M_length = __n;
                	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	      // grrr. (per 21.3.4)
                	      // You cannot leave those LWG people alone for a second.
                	    }
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      // Be race-detector-friendly.  For more info see bits/c++config.
                	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
                	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
                							 -1) <= 0)
                		{
                		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
                		  _M_destroy(__a);
                		}
                	    }
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const _GLIBCXX_NOEXCEPT
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const _GLIBCXX_NOEXCEPT
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                	_GLIBCXX_NOEXCEPT
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep() _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_empty_rep(); }
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
                #else
                      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }
                #endif
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a);
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str)
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      noexcept // FIXME C++11: should always be noexcept.
                #endif
                      : _M_dataplus(__str._M_dataplus)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	__str._M_data(_S_empty_rep()._M_refdata());
                #else
                	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
                #endif
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string() _GLIBCXX_NOEXCEPT
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str) 
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // PR 58265, this should be noexcept.
                      basic_string&
                      operator=(basic_string&& __str)
                      {
                	// NB: DR 1204.
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() _GLIBCXX_NOEXCEPT
                      {
                	if (capacity() > size())
                	  {
                	    __try
                	      { reserve(0); }
                	    __catch(...)
                	      { }
                	  }
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      // PR 56166: this should not throw.
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front()
                      { return operator[](0); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      { return operator[](0); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back()
                      { return operator[](this->size() - 1); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      { return operator[](this->size() - 1); }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      // PR 58265, this should be noexcept.
                      basic_string&
                      assign(basic_string&& __str)
                      {
                	this->swap(__str);
                	return *this;
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last);
                 
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() // FIXME C++11: should be noexcept.
                      { erase(size()-1, 1); }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                      
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(iterator __i1, iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<class _Integer>
                        static _CharT*
                        _S_construct_aux(_Integer __beg, _Integer __end,
                			 const _Alloc& __a, __true_type)
                        { return _S_construct_aux_2(static_cast<size_type>(__beg),
                				    __end, __a); }
                
                      static _CharT*
                      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
                      { return _S_construct(__req, __c, __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      // PR 58265, this should be noexcept.
                      void
                      swap(basic_string& __s);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
          18 ->     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	     const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    {
                      const auto __size = __lhs.size() + __rhs.size();
                      const bool __cond = (__size > __lhs.capacity()
                			   && __size <= __rhs.capacity());
                      return __cond ? std::move(__rhs.insert(0, __lhs))
                	            : std::move(__lhs.append(__rhs));
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, 1, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const _CharT* __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      _CharT __rhs)
                    { return std::move(__lhs.append(1, __rhs)); }
                #endif
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  template<typename _CharT>
                    inline
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
                    operator==(const basic_string<_CharT>& __lhs,
                	       const basic_string<_CharT>& __rhs)
                    { return (__lhs.size() == __rhs.size()
                	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
                						    __lhs.size())); }
                
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return !(__lhs == __rhs); }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *
                   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { __lhs.swap(__rhs); }
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until whitespace is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  If is.width() is non-zero, that is the limit on the
                   *  number of characters stored into @a __str.  Any previous
                   *  contents of @a __str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param __os  Output stream.
                   *  @param __str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a __str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 586. string inserter not a formatted function
                      return __ostream_insert(__os, __str.data(), __str.size());
                    }
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @param __delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until @a __delim is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  @a __delim is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a __str until &apos;\n&apos; is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  end of line is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str, __is.widen('\n')); }
                
                #if __cplusplus >= 201103L
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    { return std::getline(__is, __str, __delim); }
                
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str); }
                #endif
                
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if ((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \
                     && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
                
                #include <ext/string_conversions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // 21.4 Numeric Conversions [string.conversions].
                  inline int
                  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long
                  stol(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: strtof vs strtod.
                  inline float
                  stof(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
                
                  // NB: (v)snprintf vs sprintf.
                
                  // DR 1261.
                  inline string
                  to_string(int __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
                					   "%d", __val); }
                
                  inline string
                  to_string(unsigned __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned),
                					   "%u", __val); }
                
                  inline string
                  to_string(long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
                					   "%ld", __val); }
                
                  inline string
                  to_string(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long),
                					   "%lu", __val); }
                
                  inline string
                  to_string(long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(long long),
                					   "%lld", __val); }
                
                  inline string
                  to_string(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long long),
                					   "%llu", __val); }
                
                  inline string
                  to_string(float __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(long double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%Lf", __val);
                  }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  inline int 
                  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long 
                  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: wcstof vs wcstod.
                  inline float
                  stof(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
                
                  // DR 1261.
                  inline wstring
                  to_wstring(int __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                					    L"%d", __val); }
                
                  inline wstring
                  to_wstring(unsigned __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned),
                					    L"%u", __val); }
                
                  inline wstring
                  to_wstring(long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                					    L"%ld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long),
                					    L"%lu", __val); }
                
                  inline wstring
                  to_wstring(long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(long long),
                					    L"%lld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long long),
                					    L"%llu", __val); }
                
                  inline wstring
                  to_wstring(float __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(long double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%Lf", __val);
                  }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* C++11 && _GLIBCXX_USE_C99 ... */
                
                #if __cplusplus >= 201103L
                
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                
                #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
                  /// std::hash specialization for string.
                  template<>
                    struct hash<string>
                    : public __hash_base<size_t, string>
                    {
                      size_t
                      operator()(const string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<string>> : std::false_type
                    { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// std::hash specialization for wstring.
                  template<>
                    struct hash<wstring>
                    : public __hash_base<size_t, wstring>
                    {
                      size_t
                      operator()(const wstring& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(wchar_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<wstring>> : std::false_type
                    { };
                #endif
                #endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /// std::hash specialization for u16string.
                  template<>
                    struct hash<u16string>
                    : public __hash_base<size_t, u16string>
                    {
                      size_t
                      operator()(const u16string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char16_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u16string>> : std::false_type
                    { };
                
                  /// std::hash specialization for u32string.
                  template<>
                    struct hash<u32string>
                    : public __hash_base<size_t, u32string>
                    {
                      size_t
                      operator()(const u32string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char32_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u32string>> : std::false_type
                    { };
                #endif
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_string_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace string_literals
                  {
                
                    inline basic_string<char>
                    operator""s(const char* __str, size_t __len)
                    { return basic_string<char>{__str, __len}; }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                    inline basic_string<wchar_t>
                    operator""s(const wchar_t* __str, size_t __len)
                    { return basic_string<wchar_t>{__str, __len}; }
                #endif
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                    inline basic_string<char16_t>
                    operator""s(const char16_t* __str, size_t __len)
                    { return basic_string<char16_t>{__str, __len}; }
                
                    inline basic_string<char32_t>
                    operator""s(const char32_t* __str, size_t __len)
                    { return basic_string<char32_t>{__str, __len}; }
                #endif
                
                  } // inline namespace string_literals
                  } // inline namespace literals
                
                #endif // __cplusplus > 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

     2421         18

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       18   Total number of line executions
    18.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_basic_oblackholestream.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_BASIC_O_BLACK_HOLE_STREAM_H
                #define TEUCHOS_BASIC_O_BLACK_HOLE_STREAM_H
                
                #include "Teuchos_ConfigDefs.hpp"
                
                namespace Teuchos {
                
                /** \brief <tt>basic_ostream<></tt> subclass that does nothing but discard output.
                 *
                 * \ingroup teuchos_outputting_grp
                 *
                 * Use the class anytime you must pass an <tt>basic_ostream<></tt> object
                 * but don't want the output for any reason.
                 *
                 * This subclass just sets the stream buffer to NULL and that is all you need to do!
                 */
                template<typename _CharT, typename _Traits>
           3 -> class basic_oblackholestream
                	: virtual public std::basic_ostream<_CharT, _Traits>
                {
                public:
                  /** \brief . */
                	explicit basic_oblackholestream() : std::basic_ostream<_CharT, _Traits>(NULL) {}
                }; // end class basic_oblackholestream
                
                } // end namespace Teuchos
                
                #endif // TEUCHOS_BASIC_O_BLACK_HOLE_STREAM_H


Top 10 Lines:

     Line      Count

       59          3

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        3   Total number of line executions
     3.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_StringIndexedOrderedValueObjectContainer.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                
                #ifndef TEUCHOS_STRING_INDEXED_ORDERED_VALUE_OBJECT_CONTAINER_HPP
                #define TEUCHOS_STRING_INDEXED_ORDERED_VALUE_OBJECT_CONTAINER_HPP
                
                
                #include "Teuchos_Array.hpp"
                #include "Teuchos_FilteredIterator.hpp"
                
                
                namespace Teuchos {
                
                
                
                /** \brief Base types for StringIndexedOrderedValueObjectContainer.
                 */
                class StringIndexedOrderedValueObjectContainerBase {
                public:
                
                  /** \brief Ordinal used for the index. */
                  typedef Teuchos_Ordinal Ordinal;
                
                  /** \brief Return the value for invalid ordinal. */
                  static Ordinal getInvalidOrdinal() { return -1; }
                
                  /** \brief Destructor */
                  virtual ~StringIndexedOrderedValueObjectContainerBase() {};
                
                public: // Public members (but only for unit testing purposes!)
                
                  /** \brief A safe ordinal index type that default initializes to a special
                   * value.
                   */
                  class OrdinalIndex {
                  public:
                    /** \brief . */
                    typedef StringIndexedOrderedValueObjectContainerBase::Ordinal Ordinal;
                    /** \brief . */
                    Ordinal idx;
                    /** \brief . */
                    OrdinalIndex()
                      : idx(StringIndexedOrderedValueObjectContainerBase::getInvalidOrdinal())
                      {}
                    /** \brief . */
                    OrdinalIndex(const Ordinal idx_in)
                      : idx(idx_in)
                      {}
                  };
                
                  /** \brief A simple aggregate type to bind a key string and and objects value.
                   *
                   * This is meant to be a drop-in replacement for std::pair<std::string,
                   * ObjType>.  That is why the key and the object are called 'first' and
                   * 'second'.
                   *
                   * Note that there is no invariant on the key and the object value so there is
                   * no need to encapsulate them.  This is good because we can't since we need
                   * to provide 'first' and 'second' as raw data members to match std::pair.
                   * However, we don't want to allow users to be able to change the 'first' key
                   * string (like you can't with the std::map::value_type returned in the
                   * iterator) so we use a const reference for 'first'.
                   */
                  template<class ObjType>
           3 ->   class KeyObjectPair {
                  public:
                    /**  \brief . */
                    const std::string &first;
                    /**  \brief . */
                    ObjType second;
                    /** \brief . */
                    std::string key;
                    /** \brief . */
                    KeyObjectPair() : first(key), second(ObjType()), key(""), isActive_(true) {}
                    /** \brief . */
                    KeyObjectPair(const std::string &key_in, const ObjType &obj_in, bool isActive_in = true)
                      : first(key), second(obj_in), key(key_in), isActive_(isActive_in) {}
                    /** \brief . */
                    KeyObjectPair(const KeyObjectPair<ObjType> &kop)
                      : first(key), second(kop.second), key(kop.key), isActive_(kop.isActive_) {}
                    /** \brief . */
                    KeyObjectPair<ObjType>& operator=(const KeyObjectPair<ObjType> &kop)
                      {
                        second = kop.second;
                        key = kop.key;
                        isActive_ = kop.isActive_;
                        return *this;
                      }
                    /** \brief . */
                    static KeyObjectPair<ObjType> makeInvalid()
                      { return KeyObjectPair("", ObjType(), false); }
                    /** \brief . */
                    bool isActive() const { return isActive_; }
                  private:
                    bool isActive_;
                  };
                
                  /** \brief Predicate for selecting active object entries in filtered iterator. */
                  template<class ObjType>
                  class SelectActive {
                  public:
                    bool operator()(const KeyObjectPair<ObjType> &key_and_obj) const
                      { return key_and_obj.isActive(); }
                  };
                
                  /** \brief Thrown if an invalid ordinal index is passed in. */
       ##### ->   class InvalidOrdinalIndexError : public ExceptionBase
                  {public:InvalidOrdinalIndexError(const std::string& what_arg) : ExceptionBase(what_arg) {}};
                
                  /** \brief Thrown if an invalid string is passed in. */
                  class InvalidKeyError : public ExceptionBase
                  {public:InvalidKeyError(const std::string& what_arg) : ExceptionBase(what_arg) {}};
                
                };
                
                
                /** \brief String indexed ordered value-type object container class.
                 *
                 * This class is a simple utility class for managing the storage and retrievel
                 * of value-type objects which the following features/properties:
                 * <ul>
                 * <li> Objects are held by-value (i.e., like std::vector, std::map, etc.) </li>
                 * <li> Objects are indexed by a unique string key value. </li>
                 * <li> Objects can also be indexed by a unique ordering ordinal. </li>
                 * <li> Iterators are orderded according to insertion order. </li>
                 * </ul>
                 *
                 * The design of this class comes with a few important limitations:
                 * <ul>
                 * <li> Storage grows accoding to the number of insertions and removing
                 *    objects does not decrease it.  This is a result of the simple
                 *    implementation needed to preserve ordering <li>
                 * </ul>
                 *
                 * \todo Implement compression of unused entries.  This will invalidate the
                 * indexes but will allow handling of lots of inserts and deletes of elements.
                 */
                template<class ObjType>
                class StringIndexedOrderedValueObjectContainer
                  : private StringIndexedOrderedValueObjectContainerBase
                {
                private:
                
                  /** \brief . */
                  typedef KeyObjectPair<ObjType> key_and_obj_t;
                  /** \brief . */
                  typedef std::deque<key_and_obj_t> key_and_obj_array_t; // See notes below!
                  /** \brief . */
                  typedef std::map<std::string, OrdinalIndex> key_to_idx_map_t;
                
                public:
                
                  /** \name Public types. */
                  //@{
                
                  /** \brief Ordinal used for the index. */
                  typedef StringIndexedOrderedValueObjectContainerBase::Ordinal Ordinal;
                
                  /** \brief The non-const iterator type. */
                  typedef FilteredIterator<typename key_and_obj_array_t::iterator, SelectActive<ObjType> >
                  Iterator;
                
                  /** \brief The const iterator type. */
                  typedef FilteredIterator<typename key_and_obj_array_t::const_iterator, SelectActive<ObjType> >
                  ConstIterator;
                
                  //@}
                
                  /** \name Constructors/Destructors/Info */
                  //@{
                
                  /** \brief . */
                  StringIndexedOrderedValueObjectContainer();
                
                  /** \brief . */
                  Ordinal numObjects() const;
                
                  /** \brief . */
                  Ordinal numStorage() const;
                
                  //@}
                
                  /** \name Set, get, and remove functions */
                  //@{
                
                  /** \brief Set (or reset) object by value and return its ordinal index.
                   *
                   * If the object with the given key index does not exist, it will be added.
                   * If an object with the given key does not exist, it will be created.
                   *
                   * \return Returns the ordinal index by which the object can be looked up
                   * with.
                   */
                  Ordinal setObj(const std::string &key, const ObjType &obj);
                
                  /** \brief Get the ordinal index given the string key.
                   *
                   * If the key does not exist, then getInvalidOrdinal() is returned.
                   */
                  inline Ordinal getObjOrdinalIndex(const std::string &key) const;
                
                  /** \brief Get a nonconst semi-persisting association with the stored object
                   * indexed by ordinal.
                   */
                  inline Ptr<ObjType> getNonconstObjPtr(const Ordinal &idx);
                
                  /** \brief Get a const semi-persisting association with the stored object
                   * indexed by ordinal.
                   */
                  inline Ptr<const ObjType> getObjPtr(const Ordinal &idx) const;
                
                  /** \brief Get a nonconst semi-persisting association with the stored object
                   * indexed by string key.
                   */
                  inline Ptr<ObjType> getNonconstObjPtr(const std::string &key);
                
                  /** \brief Get a const semi-persisting association with the stored object
                   * indexed by string key.
                   */
                  inline Ptr<const ObjType> getObjPtr(const std::string &key) const;
                
                  /** \brief Remove an object given its ordinal index.
                   *
                   * Each object is errased by assigning to a default-constructed ObjType().
                   * This, for example, will wipe out the reference count for a smart pointer
                   * class or will unsize an array, etc..
                   */
                  void removeObj(const Ordinal &idx);
                
                  /** \brief Remove an object given its string key. */
                  void removeObj(const std::string &key);
                
                  //@}
                
                  /** \name Iterator access */
                  //@{
                
                  /** \brief . */
                  inline Iterator nonconstBegin();
                
                  /** \brief . */
                  inline Iterator nonconstEnd();
                
                  /** \brief . */
                  inline ConstIterator begin() const;
                
                  /** \brief . */
                  inline ConstIterator end() const;
                
                  //@}
                
                private: // data members
                
                  /** \brief Stories objects contiguously along with key strings. */
                  key_and_obj_array_t key_and_obj_array_;
                  /** \brief Provides lookups of key -> ordinal index into above array. */
                  key_to_idx_map_t key_to_idx_map_;
                
                  // The above is a fairly simple data-structure.
                  //
                  // key_and_obj_array_: Array that stores the objects (and key names), by
                  // value, in the order they are inserted.  Any removed objects will have the
                  // index valuie of getInvalidOrdinal().  The key strings are also storied
                  // with the objects so that a clean iterator can over the objects has access
                  // to both the key and the object value.
                  //
                  // key_to_idx_map_: Maps the unique string key to the unigue ordinal index
                  // for an object.
                  //
                  // NOTES:
                  //
                  // A) This data-structure stores the key names twice in order to allow for
                  // optimal iterator performance.  The array key_and_obj_array_ allows fast
                  // ordered iterators through the data but in order to also provide the names
                  // in a fast manner, they have to be stored twice.
                  //
                  // B) Deleting objects is done by just removing an entry from
                  // key_to_idx_map_ but the corresponding entry in key_and_obj_array_ is just
                  // abandoned with the object value set to ObjType().
                
                private: // member functions
                
                  /** \brief . */
                  void assertOrdinalIndex(const Ordinal idx) const;
                
                  /** \brief . */
                  key_and_obj_t& getNonconstKeyAndObject(const Ordinal idx);
                
                  /** \brief . */
                  const key_and_obj_t& getKeyAndObject(const Ordinal idx) const;
                
                  /** \brief . */
                  void throwInvalidKeyError(const Ordinal idx, const std::string &key) const;
                
                  /** \brief . */
                  Ordinal assertKeyGetOrdinal(const std::string &key) const;
                
                };
                
                
                //
                // StringIndexedOrderedValueObjectContainer: Inline Implementations
                //
                
                
                // Set, get, and remove functions
                
                
                template<class ObjType>
                inline
                Ptr<ObjType>
                StringIndexedOrderedValueObjectContainer<ObjType>::getNonconstObjPtr(const Ordinal &idx)
                {
                  return ptrFromRef(getNonconstKeyAndObject(idx).second);
                }
                
                
                template<class ObjType>
                inline
                Ptr<const ObjType>
                StringIndexedOrderedValueObjectContainer<ObjType>::getObjPtr(const Ordinal &idx) const
                {
                  return ptrFromRef(getKeyAndObject(idx).second);
                }
                
                
                template<class ObjType>
                inline
                Ptr<ObjType>
                StringIndexedOrderedValueObjectContainer<ObjType>::getNonconstObjPtr(const std::string &key)
                {
                  return getNonconstObjPtr(assertKeyGetOrdinal(key));
                }
                
                
                template<class ObjType>
                inline
                Ptr<const ObjType>
                StringIndexedOrderedValueObjectContainer<ObjType>::getObjPtr(const std::string &key) const
                {
                  return getObjPtr(assertKeyGetOrdinal(key));
                }
                
                
                // Iterator access
                
                
                template<class ObjType>
                inline
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Iterator
                StringIndexedOrderedValueObjectContainer<ObjType>::nonconstBegin()
                {
                  return Iterator(key_and_obj_array_.begin(), key_and_obj_array_.begin(),
                    key_and_obj_array_.end());
                }
                
                
                template<class ObjType>
                inline
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Iterator
                StringIndexedOrderedValueObjectContainer<ObjType>::nonconstEnd()
                {
                  return Iterator(key_and_obj_array_.end(), key_and_obj_array_.begin(),
                    key_and_obj_array_.end());
                }
                
                
                template<class ObjType>
                inline
                typename StringIndexedOrderedValueObjectContainer<ObjType>::ConstIterator
                StringIndexedOrderedValueObjectContainer<ObjType>::begin() const
                {
                  return ConstIterator(key_and_obj_array_.begin(), key_and_obj_array_.begin(),
                    key_and_obj_array_.end());
                }
                
                
                template<class ObjType>
                inline
                typename StringIndexedOrderedValueObjectContainer<ObjType>::ConstIterator
                StringIndexedOrderedValueObjectContainer<ObjType>::end() const
                {
                  return ConstIterator(key_and_obj_array_.end(), key_and_obj_array_.begin(),
                    key_and_obj_array_.end());
                }
                
                
                //
                // StringIndexedOrderedValueObjectContainer: Template Implementations
                //
                
                
                // Constructors/Destructors/Info
                
                
                template<class ObjType>
                StringIndexedOrderedValueObjectContainer<ObjType>::StringIndexedOrderedValueObjectContainer()
                {}
                
                
                template<class ObjType>
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Ordinal
                StringIndexedOrderedValueObjectContainer<ObjType>::numObjects() const
                {
                  return key_to_idx_map_.size();
                }
                
                
                template<class ObjType>
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Ordinal
                StringIndexedOrderedValueObjectContainer<ObjType>::numStorage() const
                {
                  return key_and_obj_array_.size();
                }
                
                
                // Set, get, and remove functions
                
                
                template<class ObjType>
                inline
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Ordinal
                StringIndexedOrderedValueObjectContainer<ObjType>::getObjOrdinalIndex(const std::string &key) const
                {
                  key_to_idx_map_t::const_iterator itr = key_to_idx_map_.find(key);
                  if (itr != key_to_idx_map_.end()) {
                    return itr->second.idx;
                  }
                  return getInvalidOrdinal();
                }
                
                
                template<class ObjType>
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Ordinal
         479 -> StringIndexedOrderedValueObjectContainer<ObjType>::setObj(const std::string &key,
                  const ObjType &obj)
                {
                  typename key_to_idx_map_t::iterator obj_idx_itr = key_to_idx_map_.find(key);
                  if (obj_idx_itr != key_to_idx_map_.end()) {
                    // Object with the given key already exists
                    const Ordinal obj_idx = obj_idx_itr->second.idx;
                    key_and_obj_array_[obj_idx].second = obj;
                    return obj_idx;
                  }
                  // Object with the given key does not already exist so create a new one.
                  key_and_obj_array_.push_back(key_and_obj_t(key, obj));
                  const Ordinal new_idx = key_and_obj_array_.size()-1;
                  key_to_idx_map_[key] = new_idx;
                  return new_idx;
                }
                
                
                template<class ObjType>
                void StringIndexedOrderedValueObjectContainer<ObjType>::removeObj(const Ordinal &idx)
                {
                  key_and_obj_t &key_and_obj = getNonconstKeyAndObject(idx);
                  key_to_idx_map_.erase(key_and_obj.first);
                  key_and_obj = key_and_obj_t::makeInvalid();
                }
                
                
                template<class ObjType>
                void StringIndexedOrderedValueObjectContainer<ObjType>::removeObj(const std::string &key)
                {
                  typename key_to_idx_map_t::iterator itr = key_to_idx_map_.find(key);
                  if (itr == key_to_idx_map_.end()) {
                    throwInvalidKeyError(getInvalidOrdinal(), key);
                  }
                  const Ordinal idx = itr->second.idx;
                  key_to_idx_map_.erase(itr);
                  key_and_obj_array_[idx] = key_and_obj_t::makeInvalid();
                }
                
                
                // private
                
                
                template<class ObjType>
                void StringIndexedOrderedValueObjectContainer<ObjType>::assertOrdinalIndex(const Ordinal idx) const
                {
                  TEUCHOS_TEST_FOR_EXCEPTION( !(0 <= idx && idx < numStorage()),
                    InvalidOrdinalIndexError,
                    "Error, the ordinal index " << idx << " is invalid"
                    << " because it falls outside of the range of valid objects"
                    << " [0,"<<numStorage()-1<<"]!");
                }
                
                
                template<class ObjType>
                typename StringIndexedOrderedValueObjectContainer<ObjType>::key_and_obj_t&
         198 -> StringIndexedOrderedValueObjectContainer<ObjType>::getNonconstKeyAndObject(const Ordinal idx)
                {
                  assertOrdinalIndex(idx);
                  key_and_obj_t &key_and_obj = key_and_obj_array_[idx];
                  TEUCHOS_TEST_FOR_EXCEPTION( !key_and_obj.isActive(),
                    InvalidOrdinalIndexError,
                    "Error, the ordinal index " << idx << " is invalid"
                    << " because the object has been deleted!");
                  return key_and_obj;
                }
                
                
                template<class ObjType>
                const typename StringIndexedOrderedValueObjectContainer<ObjType>::key_and_obj_t&
         188 -> StringIndexedOrderedValueObjectContainer<ObjType>::getKeyAndObject(const Ordinal idx) const
                {
                  assertOrdinalIndex(idx);
                  const key_and_obj_t &key_and_obj = key_and_obj_array_[idx];
                  TEUCHOS_TEST_FOR_EXCEPTION( !key_and_obj.isActive(),
                    InvalidOrdinalIndexError,
                    "Error, the ordinal index " << idx << " is invalid"
                    << " because the object has been deleted!");
                  return key_and_obj;
                }
                
                
                template<class ObjType>
                void
                StringIndexedOrderedValueObjectContainer<ObjType>::throwInvalidKeyError(
                  const Ordinal idx, const std::string &key) const
                {
                  TEUCHOS_TEST_FOR_EXCEPTION( idx == getInvalidOrdinal(), InvalidKeyError,
                    "Error, the key '" << key << "' does not exist!");
                }
                
                
                template<class ObjType>
                typename StringIndexedOrderedValueObjectContainer<ObjType>::Ordinal
                StringIndexedOrderedValueObjectContainer<ObjType>::assertKeyGetOrdinal(const std::string &key) const
                {
                  const Ordinal idx = getObjOrdinalIndex(key);
                  throwInvalidKeyError(idx, key);
                  return idx;
                }
                
                
                } // end of Teuchos namespace
                
                /* Notes:
                 *
                 * This class may have a bit of a fragile implemenation.  It uses std::deque
                 * instead of std::vector to hold the stored objects.  This is so that once an
                 * object is added, it will keep the exact same address no matter how many
                 * other objects are added.  This is not the case with std::vector because
                 * when the memory is resized it will copy the value objects making the old
                 * objects invalid.  My guess with the std::deque class is that it would
                 * allocate and store the chunks such that once an objects was added to a
                 * chunk that it would not get reallocated and moved like in std::vector.  I
                 * don't feel very good about relying on this behavior but my guess is that
                 * this will be pretty portable.  If this turns out not to be portable, we can
                 * always just use RCP<ObjType> to store the object and that will guarantee
                 * that the object address will never be moved.  Going with an RCP<ObjType>
                 * implementation would also allow the Ptr<ObjType> views to catch dangling
                 * references in a debug-mode build.
                 */
                
                
                #endif // TEUCHOS_STRING_INDEXED_ORDERED_VALUE_OBJECT_CONTAINER_HPP
                
                


Top 10 Lines:

     Line      Count

      474        479
      530        198
      544        188
      104          3

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      868   Total number of line executions
   173.60   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_MultiVectorFactory.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef XPETRA_MULTIVECTORFACTORY_HPP
                #define XPETRA_MULTIVECTORFACTORY_HPP
                
                #include "Xpetra_ConfigDefs.hpp"
                
                #include "Xpetra_MultiVector.hpp"
                
                #ifdef HAVE_XPETRA_TPETRA
                #include "Xpetra_TpetraMultiVector.hpp"
                #endif
                
                #ifdef HAVE_XPETRA_EPETRA
                #include "Xpetra_EpetraMultiVector.hpp"
                #endif
                
                #include "Xpetra_Exceptions.hpp"
                
                namespace Xpetra {
                
                  template <class Scalar = MultiVector<>::scalar_type,
                            class LocalOrdinal =
                              typename MultiVector<Scalar>::local_ordinal_type,
                            class GlobalOrdinal =
                              typename MultiVector<Scalar, LocalOrdinal>::global_ordinal_type,
                            class Node =
                              typename MultiVector<Scalar, LocalOrdinal, GlobalOrdinal>::node_type>
                  class MultiVectorFactory {
                  private:
                    //! Private constructor. This is a static class.
                    MultiVectorFactory() {}
                
                  public:
                
                    //! Constructor specifying the number of non-zeros for all rows.
                    static Teuchos::RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                    Build (const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > &map,
                           size_t NumVectors,
                           bool zeroOut=true)
                    {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, NumVectors, zeroOut) );
                #endif
                
                      XPETRA_FACTORY_ERROR_IF_EPETRA(map->lib());
                      XPETRA_FACTORY_END;
                    }
                
                    //! Set multi-vector values from array of pointers using Teuchos memory management classes. (copy).
                    static Teuchos::RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > Build(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors) {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, ArrayOfPtrs, NumVectors) );
                #endif
                
                      XPETRA_FACTORY_ERROR_IF_EPETRA(map->lib());
                      XPETRA_FACTORY_END;
                    }
                
                  };
                
                
                // we need the Epetra specialization only if Epetra is enabled
                #if (defined(HAVE_XPETRA_EPETRA) && !defined(XPETRA_EPETRA_NO_32BIT_GLOBAL_INDICES))
                
                
                  // Specialization for Scalar=double, LO=GO=int and Serial node
                  // Used both for Epetra and Tpetra
                  // For any other node definition the general default implementation is used which allows Tpetra only
                  template <>
                  class MultiVectorFactory<double, int, int, EpetraNode> {
                
                    typedef double Scalar;
                    typedef int LocalOrdinal;
                    typedef int GlobalOrdinal;
                    typedef EpetraNode Node;
                
                  private:
                    //! Private constructor. This is a static class.
                    MultiVectorFactory() {}
                
                  public:
                
           1 ->     static RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > Build(const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > &map, size_t NumVectors, bool zeroOut=true) {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, NumVectors, zeroOut) );
                #endif
                
                      if (map->lib() == UseEpetra)
                        return rcp( new EpetraMultiVectorT<int,Node>(map, NumVectors, zeroOut) );
                
                      XPETRA_FACTORY_END;
                    }
                
                    //! Set multi-vector values from array of pointers using Teuchos memory management classes. (copy).
                    static Teuchos::RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > Build(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors) {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, ArrayOfPtrs, NumVectors) );
                #endif
                
                      if (map->lib() == UseEpetra)
                        return rcp( new EpetraMultiVectorT<int,Node>(map, ArrayOfPtrs, NumVectors) );
                
                      XPETRA_FACTORY_END;
                    }
                
                  };
                
                // we need the Epetra specialization only if Epetra is enabled
                #if (defined(HAVE_XPETRA_EPETRA) && !defined(XPETRA_EPETRA_NO_64BIT_GLOBAL_INDICES))
                
                  template <>
                  class MultiVectorFactory<double, int, long long, EpetraNode> {
                
                    typedef double Scalar;
                    typedef int LocalOrdinal;
                    typedef long long GlobalOrdinal;
                    typedef EpetraNode Node;
                
                  private:
                    //! Private constructor. This is a static class.
                    MultiVectorFactory() {}
                
                  public:
                
                    static RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > Build(const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > &map, size_t NumVectors, bool zeroOut=true) {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, NumVectors, zeroOut) );
                #endif
                
                      if (map->lib() == UseEpetra)
                        return rcp( new EpetraMultiVectorT<long long,Node>(map, NumVectors, zeroOut) );
                
                      XPETRA_FACTORY_END;
                    }
                
                    //! Set multi-vector values from array of pointers using Teuchos memory management classes. (copy).
                    static Teuchos::RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> > Build(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors) {
                      XPETRA_MONITOR("MultiVectorFactory::Build");
                
                #ifdef HAVE_XPETRA_TPETRA
                      if (map->lib() == UseTpetra)
                        return rcp( new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> (map, ArrayOfPtrs, NumVectors) );
                #endif
                
                      if (map->lib() == UseEpetra)
                        return rcp( new EpetraMultiVectorT<long long,Node>(map, ArrayOfPtrs, NumVectors) );
                
                      XPETRA_FACTORY_END;
                    }
                
                  };
                #endif // Epetra64
                #endif // HAVE_XPETRA_EPETRA
                
                }
                
                #define XPETRA_MULTIVECTORFACTORY_SHORT
                #endif


Top 10 Lines:

     Line      Count

      133          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_DefaultComm.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_DEFAULT_COMM_HPP
                #define TEUCHOS_DEFAULT_COMM_HPP
                
                #include "Teuchos_RCP.hpp"
                #include "Teuchos_DefaultSerialComm.hpp"
                #ifdef HAVE_MPI
                #  include "Teuchos_DefaultMpiComm.hpp"
                #endif
                
                namespace Teuchos {
                
                #ifdef HAVE_MPI
                namespace Details {
                
                template<class OrdinalType>
                int
                mpiFreeDefaultComm (MPI_Comm, int, void*, void*);
                
                template<class OrdinalType>
                int
                mpiFreeDefaultSerialComm (MPI_Comm, int, void*, void*);
                
                } // namespace Details
                #endif // HAVE_MPI
                
                /// \class DefaultComm
                /// \brief Return a default global communicator appropriate for the build.
                ///
                /// Use this class to get a Comm instance representing the default
                /// global communicator.  If Teuchos was built with MPI (i.e., if the
                /// HAVE_MPI macro is defined), then the default communicator wraps
                /// MPI_COMM_WORLD.  Otherwise, it is a "serial" communicator
                /// (containing one process, whose rank is zero).
                ///
                /// \tparam OrdinalType The ordinal type for the Comm communicator
                ///   wrapper template class.  Comm uses \c OrdinalType to represent
                ///   things like array lengths and indices.
                ///
                /// \note (mfh 19 Jul 2011, 22 Dec 2011) \c OrdinalType is called
                ///   <tt>OrdinalType</tt> and not \c Ordinal, because of a bug in
                ///   Intel's C++ compiler (version 11.1).  This compiler confuses the
                ///   \c Ordinal template parameter of DefaultComm with the
                ///   Teuchos::Ordinal typedef.  The \c Ordinal template parameter
                ///   should actually shadow the typedef in Teuchos, and it does with
                ///   GCC 4.5.1, but does not with Intel's compiler.  This may be the
                ///   case with other compilers as well, but I haven't tested them
                ///   yet.  If this class' template parameter were named \c Ordinal,
                ///   then the following line of code would result in a compile error:
                ///   \code
                ///   RCP<const Comm<int> pComm = DefaultComm<int>::getDefaultSerialComm (null);
                ///   \endcode
                template<typename OrdinalType>
                class DefaultComm {
                public:
                  /// \brief Return the default global communicator.
                  ///
                  /// \warning When running with MPI, do not call this function until
                  ///   after MPI_Init has been called.  You can use GlobalMPISesssion
                  ///   to initialize MPI without explicitly depending on the MPI
                  ///   interface or the mpi.h header file.  (If Trilinos was not
                  ///   built with MPI, GlobalMPISession will do the right thing, so
                  ///   you can use it unconditionally.)
                  ///
                  /// \warning Do not use or refer to the returned object after
                  ///   MPI_Finalize has been called.  In a non-MPI build, do not use
                  ///   or refer to the returned object after main() has returned.
                  static Teuchos::RCP<const Comm<OrdinalType> > getComm ();
                
                  /// \brief Return a serial Comm if the input Comm is null.
                  ///
                  /// If the input communicator \c comm is null, return the default
                  /// serial communicator.  Otherwise, just return the input.
                  ///
                  /// \warning The same warnings as for getComm() apply here.
                  static Teuchos::RCP<const Comm<OrdinalType> >
                  getDefaultSerialComm (const Teuchos::RCP<const Comm<OrdinalType> >& comm);
                
                private:
                  /// \brief The default global communicator.
                  ///
                  /// If Teuchos was built with MPI, this is a wrapper for
                  /// MPI_COMM_WORLD.  Otherwise, this is a "serial" communicator
                  /// (containing one process, whose rank is zero).
                  static const Comm<OrdinalType>* comm_;
                
                  //! A "serial" communicator (containing one process, whose rank is zero).
                  static const Comm<OrdinalType>* defaultSerialComm_;
                
                #ifdef HAVE_MPI
                  //! MPI_Finalize hook that calls freeDefaultComm().
                  template<class OT>
                  friend int
                  Details::mpiFreeDefaultComm (MPI_Comm, int, void*, void*);
                
                  //! MPI_Finalize hook that calls freeDefaultSerialComm().
                  template<class OT>
                  friend int
                  Details::mpiFreeDefaultSerialComm (MPI_Comm, int, void*, void*);
                #endif // HAVE_MPI
                
                  //! Free the default Comm object.
                  static void freeDefaultComm () {
                    if (comm_ != NULL) {
                      delete comm_;
                      comm_ = NULL;
                    }
                  }
                
                  //! Free the default serial Comm object.
                  static void freeDefaultSerialComm () {
                    if (defaultSerialComm_ != NULL) {
                      delete defaultSerialComm_;
                      defaultSerialComm_ = NULL;
                    }
                  }
                };
                
                #ifdef HAVE_MPI
                namespace Details {
                
                template<class OrdinalType>
                int
       ##### -> mpiFreeDefaultComm (MPI_Comm, int, void*, void*)
                {
                  try {
                    ::Teuchos::DefaultComm<OrdinalType>::freeDefaultComm ();
                  } catch (...) {
                    // Destructors must not throw exceptions, so we must accept the
                    // possible memory leak and move on.
                    std::cerr << "Teuchos::DefaultComm: Failed to free default Comm!  We can't "
                      "throw an exception here because this is a singleton destructor that "
                      "should only be called at MPI_Finalize or (if not building with MPI) at "
                      "exit from main()." << std::endl;
                    // FIXME (mfh 16 Nov 2014) There might be some way to create a
                    // custom return code with MPI error reporting.  For now, we just
                    // pick some error code not equal to MPI_SUCCESS.  It could
                    // perhaps overlap with some existing error code.
                    return (MPI_SUCCESS == 0) ? -1 : 0;
                  }
                  return MPI_SUCCESS;
                }
                
                template<class OrdinalType>
                int
                mpiFreeDefaultSerialComm (MPI_Comm, int, void*, void*)
                {
                  try {
                    ::Teuchos::DefaultComm<OrdinalType>::freeDefaultSerialComm ();
                  } catch (...) {
                    // Destructors must not throw exceptions, so we must accept the
                    // possible memory leak and move on.
                    std::cerr << "Teuchos::DefaultComm: Failed to free default serial Comm!  "
                      "We can't throw an exception here because this is a singleton destructor "
                      "that should only be called at MPI_Finalize or (if not building with MPI)"
                      " at exit from main()." << std::endl;
                    // FIXME (mfh 16 Nov 2014) There might be some way to create a
                    // custom return code with MPI error reporting.  For now, we just
                    // pick some error code not equal to MPI_SUCCESS.  It could
                    // perhaps overlap with some existing error code.
                    return (MPI_SUCCESS == 0) ? -1 : 0;
                  }
                  return MPI_SUCCESS;
                }
                
                } // namespace Details
                #endif // HAVE_MPI
                
                
                template<typename OrdinalType>
                Teuchos::RCP<const Teuchos::Comm<OrdinalType> >
           1 -> DefaultComm<OrdinalType>::getComm ()
                {
                  if (comm_ == NULL) {
                #ifdef HAVE_MPI
                    comm_ = new MpiComm<OrdinalType> (MPI_COMM_WORLD);
                
                    // We want comm_ to be deallocated when MPI_Finalize is called.
                    // The standard idiom for this (look in the MPI standard) is to
                    // register an attribute ((key,value) pair) with MPI_COMM_SELF,
                    // with a custom "destructor" to be called at MPI_Finalize.
                
                    // 'key' is an output argument of MPI_Comm_create_keyval.
                    int key = MPI_KEYVAL_INVALID;
                    int err =
                      MPI_Comm_create_keyval (MPI_COMM_NULL_COPY_FN,
                                              Details::mpiFreeDefaultComm<OrdinalType>,
                                              &key,
                                              NULL); // no extra state
                    if (err != MPI_SUCCESS) {
                      if (comm_ != NULL) { // clean up if MPI call fails
                        delete comm_;
                        comm_ = NULL;
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
                        "Teuchos::DefaultComm::getComm: MPI_Comm_create_keyval failed!");
                    }
                    int val = key; // doesn't matter
                
                    // Attach the attribute to MPI_COMM_SELF.
                    err = MPI_Comm_set_attr (MPI_COMM_SELF, key, &val);
                    if (err != MPI_SUCCESS) {
                      // MPI (versions up to and including 3.0) doesn't promise
                      // correct behavior after any function returns something other
                      // than MPI_SUCCESS.  Thus, it's not required to try to free the
                      // new key via MPI_Comm_free_keyval.  Furthermore, if something
                      // went wrong with MPI_Comm_set_attr, it's likely that the
                      // attribute mechanism is broken.  Thus, it would be unwise to
                      // call MPI_Comm_free_keyval.  However, we can still clean up
                      // other data.
                      if (comm_ != NULL) { // clean up if MPI call fails
                        delete comm_;
                        comm_ = NULL;
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
                        "Teuchos::DefaultComm::getComm: MPI_Comm_set_attr failed!");
                    }
                
                    // It looks weird to "free" the key right away.  However, this
                    // does not actually cause the "destructor" to be called.  It only
                    // gets called at MPI_FINALIZE.  See MPI 3.0 standard, Section
                    // 6.7.2, MPI_COMM_FREE_KEYVAL:
                    //
                    // "Note that it is not erroneous to free an attribute key that is
                    // in use, because the actual free does not transpire until after
                    // all references (in other communicators on the process) to the
                    // key have been freed.  These references need to be explicitly
                    // freed by the program, either via calls to MPI_COMM_DELETE_ATTR
                    // that free one attribute instance, or by calls to MPI_COMM_FREE
                    // that free all attribute instances associated with the freed
                    // communicator."
                    //
                    // We rely here on the latter mechanism.  MPI_FINALIZE calls
                    // MPI_COMM_FREE on MPI_COMM_SELF, so we do not need to call it
                    // explicitly.
                    //
                    // It's not clear what to do if the MPI_* calls above succeeded,
                    // but this call fails (i.e., returns != MPI_SUCCESS).  We could
                    // throw; this would make sense to do, because MPI (versions up to
                    // and including 3.0) doesn't promise correct behavior after any
                    // MPI function returns something other than MPI_SUCCESS.  We
                    // could also be optimistic and just ignore the return value,
                    // hoping that if the above calls succeeded, then the communicator
                    // will get freed at MPI_FINALIZE, even though the unfreed key may
                    // leak memory (see Bug 6338).  I've chosen the latter.
                    (void) MPI_Comm_free_keyval (&key);
                
                #else // NOT HAVE_MPI
                    comm_ = new SerialComm<OrdinalType> ();
                    // We want comm_ to be deallocated when main exits, so register
                    // its deallocation function as an atexit handler.
                    //
                    // The POSIX standard allows atexit to fail, in particular if it
                    // lacks space for registering more functions.  "[T]he application
                    // should call sysconf() to obtain the value of {ATEXIT_MAX}, the
                    // [maximum] number of functions that can be registered. There is
                    // no way for an application to tell how many functions have
                    // already been registered with atexit()."
                    //
                    // We don't do this here.  Instead, we just check atexit's return
                    // code.  If it fails, we throw.
                    int err = atexit (freeDefaultComm);
                    if (err != 0) {
                      if (comm_ != NULL) { // clean up if atexit fails
                        delete comm_;
                        comm_ = NULL;
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
                        "Teuchos::DefaultComm::getComm: atexit failed!");
                    }
                #endif // HAVE_MPI
                  }
                
                  TEUCHOS_TEST_FOR_EXCEPTION
                    (comm_ == NULL, std::logic_error, "Teuchos::DefaultComm::getComm: "
                     "comm_ == NULL before return.  This should never happen.  "
                     "Please report this bug to the Teuchos developers.");
                
                  // Return a nonowning RCP, because we need to ensure that
                  // destruction happens at MPI_Finalize (or at exit of main(), if not
                  // building with MPI).
                  return rcp (comm_, false);
                }
                
                template<typename OrdinalType>
                Teuchos::RCP<const Teuchos::Comm<OrdinalType> >
                DefaultComm<OrdinalType>::
                getDefaultSerialComm (const Teuchos::RCP<const Comm<OrdinalType> >& comm)
                {
                  if (! comm.is_null ()) {
                    return comm;
                  } else {
                    if (defaultSerialComm_ == NULL) {
                #ifdef HAVE_MPI
                      //defaultSerialComm_ = new MpiComm<OrdinalType> (MPI_COMM_SELF);
                      defaultSerialComm_ = new SerialComm<OrdinalType> ();
                
                      // Register an MPI_Finalize hook to free defaultSerialComm_.
                      // (See getComm implementation above in this file for details.)
                
                      int key = MPI_KEYVAL_INVALID;
                      int err =
                        MPI_Comm_create_keyval (MPI_COMM_NULL_COPY_FN,
                                                Details::mpiFreeDefaultSerialComm<OrdinalType>,
                                                &key,
                                                NULL); // no extra state
                      if (err != MPI_SUCCESS) {
                        if (defaultSerialComm_ != NULL) { // clean up if MPI call fails
                          delete defaultSerialComm_;
                          defaultSerialComm_ = NULL;
                        }
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::runtime_error, "Teuchos::DefaultComm::getDefaultSerialComm"
                          ": MPI_Comm_create_keyval failed!");
                      }
                      int val = key; // doesn't matter
                
                      // Attach the attribute to MPI_COMM_SELF.
                      err = MPI_Comm_set_attr (MPI_COMM_SELF, key, &val);
                      if (err != MPI_SUCCESS) {
                        // See comments in getComm implementation above to see why we
                        // don't call MPI_Comm_free_keyval here.
                        if (defaultSerialComm_ != NULL) { // clean up if MPI call fails
                          delete defaultSerialComm_;
                          defaultSerialComm_ = NULL;
                        }
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::runtime_error, "Teuchos::DefaultComm::getDefaultSerialComm"
                          ": MPI_Comm_set_attr failed!");
                      }
                
                      // See comments in getComm implementation above to see why we
                      // _do_ call MPI_Comm_free_keyval here, and why we don't check
                      // the return code.
                      (void) MPI_Comm_free_keyval (&key);
                
                #else // NOT HAVE_MPI
                      defaultSerialComm_ = new SerialComm<OrdinalType> ();
                      // We want defaultSerialComm_ to be deallocated when main exits,
                      // so register its deallocation function as an atexit handler.
                      //
                      // The POSIX standard allows atexit to fail, in particular if it
                      // lacks space for registering more functions.  "[T]he
                      // application should call sysconf() to obtain the value of
                      // {ATEXIT_MAX}, the [maximum] number of functions that can be
                      // registered. There is no way for an application to tell how
                      // many functions have already been registered with atexit()."
                      //
                      // We don't do this here.  Instead, we just check atexit's
                      // return code.  If it fails, we throw.
                      int err = atexit (freeDefaultComm);
                      if (err != 0) {
                        if (defaultSerialComm_ != NULL) { // clean up if atexit fails
                          delete defaultSerialComm_;
                          defaultSerialComm_ = NULL;
                        }
                        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
                          "Teuchos::DefaultComm::getDefaultSerialComm: atexit failed!");
                      }
                #endif // HAVE_MPI
                    }
                
                    TEUCHOS_TEST_FOR_EXCEPTION
                      (defaultSerialComm_ == NULL, std::logic_error, "Teuchos::DefaultComm::"
                       "getDefaultSerialComm: defaultSerialComm_ == NULL before return.  This sh"
                       "ould never happen.  Please report this bug to the Teuchos developers.");
                
                    // Return a nonowning RCP, because we need to ensure that
                    // destruction happens at MPI_Finalize (or at exit of main(), if not
                    // building with MPI).
                    return rcp (defaultSerialComm_, false);
                  }
                }
                
                template<typename OrdinalType>
                const Teuchos::Comm<OrdinalType>*
                DefaultComm<OrdinalType>::comm_ = NULL;
                
                template<typename OrdinalType>
                const Teuchos::Comm<OrdinalType>*
                DefaultComm<OrdinalType>::defaultSerialComm_ = NULL;
                
                } // namespace Teuchos
                
                #endif // TEUCHOS_DEFAULT_COMM_HPP


Top 10 Lines:

     Line      Count

      212          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosOutputManager.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_OUTPUT_MANAGER_HPP
                #define BELOS_OUTPUT_MANAGER_HPP
                
                /*!     \file BelosOutputManager.hpp
                        \brief Class which manages the output and verbosity of the Belos solvers.
                */
                
                #include "BelosConfigDefs.hpp"
                #include "BelosTypes.hpp"
                #include "Teuchos_oblackholestream.hpp"	
                #include "Teuchos_RCP.hpp"
                
                #ifdef HAVE_MPI
                #include <mpi.h>
                #endif
                
                /*!	\class Belos::OutputManager
                
                	\brief Belos's basic output manager for sending information of select verbosity levels
                	to the appropriate output stream.
                
                	This output manager will remove the need for the solver or linear problem to know any information
                	about the required output.  Calling <tt>isVerbosity( MsgType vb )</tt> will inform the solver if
                	it is supposed to output the information corresponding to the verbosity type (\c vb ).
                
                	\author Michael Heroux and Heidi Thornquist
                */
                
                namespace Belos {
                  
                  template <class ScalarType>
                  class OutputManager {
                    
                  public:
                    
                    //! @name Constructors/Destructor
                    //@{ 
                    
                    //! Basic constructor.
                    OutputManager( int vb = Belos::Errors, const Teuchos::RCP< std::ostream > &os = Teuchos::rcp(&std::cout,false) );
                    
                    //! Destructor.
       ##### ->     virtual ~OutputManager() {};
                    //@}
                    
                    //! @name Set methods
                    //@{ 
                    
                    //! Set the output stream for this manager.
                    void setOStream( const Teuchos::RCP<std::ostream> &os ) { myOS_ = os; };
                    
                    //! Set the verbosity level for this manager.
                    void setVerbosity( int vb ) { vb_ = vb; }; 
                    
                    //@}
                    
                    //! @name Get methods
                    //@{ 
                
                    //! Get an output stream for outputting the input message type.
                    std::ostream& stream( MsgType type ) 
                    {
                      if ( (type & vb_) && iPrint_ ) {
                	return *myOS_;
                      }
                      return myBHS_;
                    }
                 
                    //! Get the output stream for this manager.
                    Teuchos::RCP<std::ostream> getOStream() { return myOS_; };
                    
                    //@}
                    
                    //! @name Query methods
                    //@{ 
                    
                    //! Find out whether we need to print out information for this message type.
                    /*! This method is used by the solver to determine whether computations are
                      necessary for this message type.
                    */
                    bool isVerbosity( MsgType type ) const { return (( type == Belos::Errors ) || ( vb_ & type )); }; 
                    
                    //@}
                
                    //! @ name Print methods
                    //@{
                    
                    //! Send some output of a specified message type to the output stream.
                    void print( MsgType type, const std::string output );
                
                    //@}
                
                  private:
                    
                    //! @name Undefined methods
                    //@{ 
                    
                    //! Copy constructor.
                    OutputManager( const OutputManager<ScalarType>& OM );
                    
                    //! Assignment operator.
                    OutputManager<ScalarType>& operator=( const OutputManager<ScalarType>& OM );
                    
                    //@}
                    
                    int vb_;
                    Teuchos::RCP<std::ostream> myOS_;	
                    Teuchos::oblackholestream myBHS_;  
                    bool iPrint_;
                  };
                  
                  template<class ScalarType>
           1 ->   OutputManager<ScalarType>::OutputManager( int vb, const Teuchos::RCP<std::ostream> &os ) :
                    vb_(vb),
                    myOS_(os)
                  {
                    int MyPID;
                #ifdef HAVE_MPI
                    // Initialize MPI
                    int mpiStarted = 0;
                    MPI_Initialized(&mpiStarted);
                    if (mpiStarted) MPI_Comm_rank(MPI_COMM_WORLD, &MyPID);
                    else MyPID=0;
                #else 
                    MyPID = 0;
                #endif
                    iPrint_ = (MyPID == 0);
                  }
                 
                  template<class ScalarType>
                  void OutputManager<ScalarType>::print( MsgType type, const std::string output ) {
                  if ( (type & vb_) && iPrint_ ) {
                    *myOS_ << output;
                  }
                }
                 
                } // end Belos namespace
                
                #endif
                
                // end of file BelosOutputManager.hpp


Top 10 Lines:

     Line      Count

      154          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosStatusTestOutputFactory.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                //
                
                #ifndef BELOS_STATUS_TEST_OUTPUT_FACTORY_HPP
                #define BELOS_STATUS_TEST_OUTPUT_FACTORY_HPP
                
                /*!
                  \file BelosStatusTestOutputFactory.hpp
                  \brief A factory class for generating StatusTestOutput objects.
                */
                
                #include "BelosConfigDefs.hpp"
                #include "BelosTypes.hpp"
                #include "BelosStatusTestResNormOutput.hpp"
                #include "BelosStatusTestUserOutput.hpp"
                #include "BelosStatusTestGeneralOutput.hpp"
                
                
                namespace Belos {
                
                  /*!
                    \class StatusTestOutputFactory
                    \brief A factory class for generating StatusTestOutput objects.
                
                    StatusTestOutputFactory provides a generic interface for generating StatusTestOutput objects
                    that any solver manager can use.  This factory removes the logic for selecting which StatusTestOutput
                    class needs to be used from the solver managers. It also hides the generation of new StatusTestOutput
                    classes from the solver managers.
                  */
                template <class ScalarType, class MV, class OP>
                class StatusTestOutputFactory {
                
                 public:
                  //! @name Constructors/destructors
                  //@{
                
                  /*! \brief Constructor
                   *
                   * The StatusTestOutputFactory generates a StatusTestOutput object that provides a particular style of
                   * output, decided by the Belos::OutputType enumeration.
                   *
                   * @param[in] outputStyle A ::OutputType value which defines the style of output requested by the user.
                   * @param[in] taggedTests: map tag names of status tests to status tests (optional, default = Teuchos::null)
                   */
                  StatusTestOutputFactory( int outputStyle, Teuchos::RCP<std::map<std::string,Teuchos::RCP<StatusTest<ScalarType,MV,OP> > > > taggedTests = Teuchos::null )
                    : outputStyle_(outputStyle),
                      taggedTests_(taggedTests)
                  {}
                
                  //! Destructor
       ##### ->   virtual ~StatusTestOutputFactory() {}
                  //@}
                
                
                  //! @name Creation Methods
                  //@{
                
                  /*! \brief Create the StatusTestOutput object specified by the outputStyle
                   *
                   * The StatusTestOutput object requires an OutputManager for printing the underlying StatusTest on
                   * calls to checkStatus(), as well as an underlying StatusTest.
                   *
                   * The last two parameters, described below, in addition to the verbosity level of the OutputManager, control when printing is
                   * called. When both the \c mod criterion and the \c printStates criterion are satisfied, the status test will be printed to the
                   * OutputManager with ::MsgType of ::StatusTestDetails.
                   *
                   * @param[in] mod A positive number describes how often the output should be printed. On every call to checkStatus(), an internal counter
                   *                is incremented. Printing may only occur when this counter is congruent to zero modulo \c mod. Default: 1 (attempt to print on every call to checkStatus())
                   * @param[in] printStates A combination of ::StatusType values for which the output may be printed. Default: ::Passed (attempt to print whenever checkStatus() will return ::Passed)
                   *
                   */
           1 ->    Teuchos::RCP<StatusTestOutput<ScalarType,MV,OP> > create(const Teuchos::RCP<OutputManager<ScalarType> > &printer,
                                                                            Teuchos::RCP<StatusTest<ScalarType,MV,OP> > test,
                                                                            int mod,
                                                                            int printStates)
                    {
                      Teuchos::RCP<StatusTestOutput<ScalarType,MV,OP> > outputTest;
                
                      switch( outputStyle_ ) {
                
                      case General:
                        if (mod > 0) {
                          outputTest = Teuchos::rcp( new StatusTestGeneralOutput<ScalarType,MV,OP>( printer, test, mod, printStates ) );
                        }
                        else {
                          outputTest = Teuchos::rcp( new StatusTestGeneralOutput<ScalarType,MV,OP>( printer, test, 1 ) );
                        }
                        break;
                      case Brief:
                        if (mod > 0) {
                          outputTest = Teuchos::rcp( new StatusTestResNormOutput<ScalarType,MV,OP>( printer, test, mod, printStates ) );
                        }
                        else {
                          outputTest = Teuchos::rcp( new StatusTestResNormOutput<ScalarType,MV,OP>( printer, test, 1 ) );
                        }
                        break;
                      case User:
                        if (mod > 0) {
                          outputTest = Teuchos::rcp( new StatusTestUserOutput<ScalarType,MV,OP>( printer, test, taggedTests_, mod, printStates ) );
                        }
                        else {
                          outputTest = Teuchos::rcp( new StatusTestUserOutput<ScalarType,MV,OP>( printer, test, taggedTests_, 1 ) );
                        }
                        break;
                      }
                
                      return outputTest;
                    }
                
                  //@}
                
                 private:
                
                  // Which type of StatusTestOutput class
                  int outputStyle_;
                
                  Teuchos::RCP<std::map<std::string,Teuchos::RCP<StatusTest<ScalarType,MV,OP> > > > taggedTests_;
                
                  // Hide the default constructor and copy constructor
                  StatusTestOutputFactory( void ) {}
                  StatusTestOutputFactory( const StatusTestOutputFactory<ScalarType,MV,OP>& ) {}
                
                };
                
                } // end of Belos namespace
                
                #endif /* BELOS_STATUS_TEST_OUTPUT_FACTORY_HPP */


Top 10 Lines:

     Line      Count

      111          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Tpetra_DistObject_decl.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //          Tpetra: Templated Linear Algebra Services Package
                //                 Copyright (2008) Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                // @HEADER
                
                #ifndef TPETRA_DISTOBJECT_DECL_HPP
                #define TPETRA_DISTOBJECT_DECL_HPP
                
                /// \file Tpetra_DistObject_decl.hpp
                /// \brief Declaration of the Tpetra::DistObject class
                ///
                /// If you want to use Tpetra::DistObject, include
                /// "Tpetra_DistObject.hpp" (a file which CMake generates and installs
                /// for you).  If you only want the declaration of Tpetra::DistObject,
                /// include this file (Tpetra_DistObject_decl.hpp).
                
                #include "Tpetra_Map.hpp"
                #include "Tpetra_Import.hpp"
                #include "Tpetra_Export.hpp"
                #include "Tpetra_SrcDistObject.hpp"
                #include "Kokkos_NodeAPIConfigDefs.hpp" // enum KokkosClassic::ReadWriteOption
                #include "Kokkos_ArithTraits.hpp"
                
                // #ifndef HAVE_TPETRA_TRANSFER_TIMERS
                // #  define HAVE_TPETRA_TRANSFER_TIMERS 1
                // #endif // HAVE_TPETRA_TRANSFER_TIMERS
                
                #ifdef HAVE_TPETRA_TRANSFER_TIMERS
                #  undef HAVE_TPETRA_TRANSFER_TIMERS
                #endif // HAVE_TPETRA_TRANSFER_TIMERS
                
                
                namespace Tpetra {
                
                  /// \class DistObject
                  /// \brief Base class for distributed Tpetra objects that support
                  ///   data redistribution.
                  ///
                  /// DistObject is a base class for all Tpetra distributed global
                  /// objects, including CrsMatrix and MultiVector.  It provides the
                  /// basic mechanisms and interface specifications for importing and
                  /// exporting operations using Import and Export objects.
                  ///
                  /// \tparam LocalOrdinal The type of local IDs.  Same as Map's
                  ///   \c LocalOrdinal template parameter.  This should be an integer
                  ///   type, preferably signed.
                  ///
                  /// \tparam GlobalOrdinal The type of global IDs.  Same as Map's
                  ///   \c GlobalOrdinal template parameter.  Defaults to the same type
                  ///   as \c LocalOrdinal.  This should also be an integer type,
                  ///   preferably signed.
                  ///
                  /// \tparam Node Same as Map's \c Node template parameter.  Defaults
                  ///   to the default Kokkos Node type.
                  ///
                  /// \tparam classic DO NOT SET THIS EXPLICITLY.  This template
                  ///   parameter only exists for backwards compatibility.  It must
                  ///   always be false.
                  ///
                  /// \section Tpetra_DistObject_Summary Summary
                  ///
                  /// Most Tpetra users will only use this class' methods to perform
                  /// data redistribution for subclasses such as CrsMatrix,
                  /// MultiVector, and Vector.  DistObject provides four methods for
                  /// redistributing data: two versions of <tt>doImport()</tt>, and
                  /// two versions of <tt>doExport()</tt>.  Import operations
                  /// redistribute data from a nonoverlapping (one-to-one)
                  /// distribution to a possibly overlapping distribution.  Export
                  /// operations redistribute data from a possibly overlapping
                  /// distribution to a nonoverlapping (one-to-one) distribution.
                  /// Once you have precomputed a data redistribution plan (an Import
                  /// or Export object), you may use the plan to redistribute an input
                  /// object's data into this object, by calling one of these methods.
                  /// The input object of <tt>doImport()</tt> or <tt>doExport()</tt>
                  /// is always the "source" of the redistribution operation, which
                  /// sends the data.  The <tt>*this</tt> object is the target, which
                  /// receives and combines the data.  It has the distribution given
                  /// by <tt>this->getMap()</tt>.
                  ///
                  /// \section Tpetra_DistObject_FwdRev Forward or reverse redistribution modes
                  ///
                  /// Both Import and Export operations occur in two modes: forward
                  /// and reverse.  Forward mode is the usual case, where you are
                  /// calling a method with its matching plan type
                  /// (<tt>doImport()</tt> for an Import plan, or <tt>doExport()</tt>
                  /// for an Export plan).  In that case, the input DistObject must
                  /// have the same Map as the source Map of the plan, and the target
                  /// DistObject must have the same Map as the target Map of the plan.
                  /// Reverse mode is also possible, where you call a method with the
                  /// opposite plan type (<tt>doImport()</tt> for an Export plan, or
                  /// <tt>doExport()</tt> for an Import plan).  In that case, the
                  /// source DistObject's Map must be the same as the target Map of
                  /// the plan, and the target DistObject's Map must be the same as
                  /// the source Map of the plan.  If you call <tt>doImport()</tt>, we
                  /// still call this an Import operation, even if you are using an
                  /// Export plan in reverse.  Similarly, if you call
                  /// <tt>doExport()</tt>, we call this an Export operation.
                  ///
                  /// Most users will want to use forward mode.  However, reverse mode
                  /// is useful for some applications.  For example, suppose you are
                  /// solving a nonlinear partial differential equation using the
                  /// finite element method, with Newton's method for the nonlinear
                  /// equation.  When assembling into a vector, it is convenient and
                  /// efficient to do local assembly first into a vector with an
                  /// overlapping distribution, then do global assembly via forward
                  /// mode Export into a vector with a nonoverlapping distribution.
                  /// After the linear solve, you may want to bring the resulting
                  /// nonoverlapping distribution vector back to the overlapping
                  /// distribution for another update phase.  This would be a reverse
                  /// mode Import, using the precomputed Export object.
                  ///
                  /// Another use case for reverse mode is in CrsMatrix, for the
                  /// transpose version of distributed sparse matrix-vector multiply
                  /// ("mat-vec").  Non-transpose mat-vec (a function from the domain
                  /// Map to the range Map) does an Import to bring in the source
                  /// vector's data from the domain Map to the column Map of the
                  /// sparse matrix, and an Export (if necessary) to bring the results
                  /// from the row Map of the sparse matrix to the range Map.
                  /// Transpose mat-vec (a function from the range Map to the domain
                  /// Map) uses these precomputed Import and Export objects in reverse
                  /// mode: first the Export in reverse mode to Import the source
                  /// vector's data to the row Map, and then the Import in reverse
                  /// mode to Export the results to the domain Map.  Reverse mode lets
                  /// us reuse the precomputed data redistribution plans for the
                  /// transpose case.
                  ///
                  /// \section Tpetra_DistObject_ImplSubclass How to implement a subclass
                  ///
                  /// If you want to implement your own DistObject subclass, you
                  /// should start by implementing the four pure virtual methods:
                  /// checkSizes(), copyAndPermute(), packAndPrepare(), and
                  /// unpackAndCombine().  The implementation of doTransfer() includes
                  /// documentation that explains how DistObject uses those methods to
                  /// do data redistribution.
                  ///
                  /// If you are writing a DistObject class that uses Kokkos compute
                  /// buffers and aims to work for any Kokkos Node type, you should
                  /// also implement the three hooks that create and release views:
                  /// createViews(), createViewsNonConst(), and releaseViews().  The
                  /// default implementation of these hooks does nothing.  The
                  /// documentation of these methods explains different ways you might
                  /// choose to implement them.
                  ///
                  /// DistObject implements SrcDistObject, because we presume that if
                  /// an object can be the target of an Import or Export, it can also
                  /// be the source of an Import or Export.
                  template <class Packet,
                            class LocalOrdinal = ::Tpetra::Details::DefaultTypes::local_ordinal_type,
                            class GlobalOrdinal = ::Tpetra::Details::DefaultTypes::global_ordinal_type,
                            class Node = ::Tpetra::Details::DefaultTypes::node_type,
                            const bool classic = Node::classic>
                  class DistObject :
                    virtual public SrcDistObject,
                    virtual public Teuchos::Describable
                  {
                  public:
                    //! @name Typedefs
                    //@{
                
                    /// \brief The type of each datum being sent or received in an Import or Export.
                    ///
                    /// Note that this type does not always correspond to the
                    /// <tt>Scalar</tt> template parameter of subclasses.
                    typedef typename Kokkos::Details::ArithTraits<Packet>::val_type packet_type;
                    //! The type of local indices.
                    typedef LocalOrdinal local_ordinal_type;
                    //! The type of global indices.
                    typedef GlobalOrdinal global_ordinal_type;
                    //! The Kokkos Node type.
                    typedef Node node_type;
                
                    //! The Kokkos Device type.
                    typedef typename Node::device_type device_type;
                    //! The Kokkos execution space.
                    typedef typename device_type::execution_space execution_space;
                
                  private:
                    typedef typename Kokkos::View<packet_type*, device_type>::size_type view_size_type;
                    typedef DistObject<Packet, LocalOrdinal, GlobalOrdinal, Node, classic> this_type;
                
                  public:
                    //! The type of the Map specialization to use with this class.
                    typedef Map<local_ordinal_type, global_ordinal_type, node_type> map_type;
                
                    //@}
                    //! @name Constructors and destructor
                    //@{
                
                    //! Constructor.
                    explicit DistObject (const Teuchos::RCP<const map_type>& map);
                
                    //! Copy constructor.
                    DistObject (const DistObject<Packet, LocalOrdinal, GlobalOrdinal, Node, classic>& rhs);
                
                    //! Destructor (virtual for memory safety of derived classes).
                    virtual ~DistObject ();
                
                    //@}
                    //! @name Public methods for redistributing data
                    //@{
                
                    /// \brief Import data into this object using an Import object ("forward mode").
                    ///
                    /// The input DistObject is always the source of the data
                    /// redistribution operation, and the <tt>*this</tt> object is
                    /// always the target.
                    ///
                    /// If you don't know the difference between forward and reverse
                    /// mode, then you probably want forward mode.  Use this method
                    /// with your precomputed Import object if you want to do an
                    /// Import, else use doExport() with a precomputed Export object.
                    ///
                    /// \param source [in] The "source" object for redistribution.
                    /// \param importer [in] Precomputed data redistribution plan.
                    ///   Its source Map must be the same as the input DistObject's Map,
                    ///   and its target Map must be the same as <tt>this->getMap()</tt>.
                    /// \param CM [in] How to combine incoming data with the same
                    ///   global index.
                    void
                    doImport (const SrcDistObject& source,
                              const Import<LocalOrdinal, GlobalOrdinal, Node>& importer,
                              CombineMode CM);
                
                    /// \brief Export data into this object using an Export object ("forward mode").
                    ///
                    /// The input DistObject is always the source of the data
                    /// redistribution operation, and the <tt>*this</tt> object is
                    /// always the target.
                    ///
                    /// If you don't know the difference between forward and reverse
                    /// mode, then you probably want forward mode.  Use this method
                    /// with your precomputed Export object if you want to do an
                    /// Export, else use doImport() with a precomputed Import object.
                    ///
                    /// \param source [in] The "source" object for redistribution.
                    /// \param exporter [in] Precomputed data redistribution plan.
                    ///   Its source Map must be the same as the input DistObject's Map,
                    ///   and its target Map must be the same as <tt>this->getMap()</tt>.
                    /// \param CM [in] How to combine incoming data with the same
                    ///   global index.
                    void
                    doExport (const SrcDistObject& source,
                              const Export<LocalOrdinal, GlobalOrdinal, Node>& exporter,
                              CombineMode CM);
                
                    /// \brief Import data into this object using an Export object ("reverse mode").
                    ///
                    /// The input DistObject is always the source of the data
                    /// redistribution operation, and the <tt>*this</tt> object is
                    /// always the target.
                    ///
                    /// If you don't know the difference between forward and reverse
                    /// mode, then you probably want forward mode.  Use the version of
                    /// doImport() that takes a precomputed Import object in that
                    /// case.
                    ///
                    /// \param source [in] The "source" object for redistribution.
                    /// \param exporter [in] Precomputed data redistribution plan.
                    ///   Its <i>target</i> Map must be the same as the input DistObject's Map,
                    ///   and its <i>source</i> Map must be the same as <tt>this->getMap()</tt>.
                    ///   (Note the difference from forward mode.)
                    /// \param CM [in] How to combine incoming data with the same
                    ///   global index.
                    void
                    doImport (const SrcDistObject& source,
                              const Export<LocalOrdinal, GlobalOrdinal, Node>& exporter,
                              CombineMode CM);
                
                    /// \brief Export data into this object using an Import object ("reverse mode").
                    ///
                    /// The input DistObject is always the source of the data
                    /// redistribution operation, and the <tt>*this</tt> object is
                    /// always the target.
                    ///
                    /// If you don't know the difference between forward and reverse
                    /// mode, then you probably want forward mode.  Use the version of
                    /// doExport() that takes a precomputed Export object in that
                    /// case.
                    ///
                    /// \param source [in] The "source" object for redistribution.
                    /// \param importer [in] Precomputed data redistribution plan.
                    ///   Its <i>target</i> Map must be the same as the input DistObject's Map,
                    ///   and its <i>source</i> Map must be the same as <tt>this->getMap()</tt>.
                    ///   (Note the difference from forward mode.)
                    /// \param CM [in] How to combine incoming data with the same
                    ///   global index.
                    void
                    doExport (const SrcDistObject& source,
                              const Import<LocalOrdinal, GlobalOrdinal, Node>& importer,
                              CombineMode CM);
                
                    //@}
                    //! @name Attribute accessor methods
                    //@{
                
                    /// \brief Whether this is a globally distributed object.
                    ///
                    /// For a definition of "globally distributed" (and its opposite,
                    /// "locally replicated"), see the documentation of Map's
                    /// isDistributed() method.
                    bool isDistributed () const;
                
                    /// \brief The Map describing the parallel distribution of this object.
                    ///
                    /// Note that some Tpetra objects might be distributed using
                    /// multiple Map objects.  For example, CrsMatrix has both a row
                    /// Map and a column Map.  It is up to the subclass to decide
                    /// which Map to use when invoking the DistObject constructor.
          57 ->     virtual Teuchos::RCP<const map_type> getMap () const { return map_; }
                
                    //@}
                    //! @name I/O methods
                    //@{
                
                    /// \brief Print this object to the given output stream.
                    ///
                    /// We generally assume that all MPI processes can print to the
                    /// given stream.
                    void print (std::ostream &os) const;
                
                    //@}
                    //! @name Implementation of Teuchos::Describable
                    //@{
                
                    /// \brief One-line descriptiion of this object.
                    ///
                    /// We declare this method virtual so that subclasses of
                    /// DistObject may override it.
                    virtual std::string description () const;
                
                    /// \brief Print a descriptiion of this object to the given output stream.
                    ///
                    /// We declare this method virtual so that subclasses of
                    /// Distobject may override it.
                    virtual void
                    describe (Teuchos::FancyOStream &out,
                              const Teuchos::EVerbosityLevel verbLevel =
                              Teuchos::Describable::verbLevel_default) const;
                
                    //@}
                    //! @name Methods for use only by experts
                    //@{
                
                    /// \brief Remove processes which contain no elements in this object's Map.
                    ///
                    /// \warning This method is ONLY for use by experts.  We highly
                    ///   recommend using the nonmember function of the same name
                    ///   defined in this file.
                    ///
                    /// \warning We make NO promises of backwards compatibility.
                    ///   This method may change or disappear at any time.
                    ///
                    /// On input, this object is distributed over the Map returned by
                    /// getMap() (the "original Map," with its communicator, the
                    /// "original communicator").  The input \c newMap of this method
                    /// <i>must</i> be the same as the result of calling
                    /// <tt>getMap()->removeEmptyProcesses()</tt>.  On processes in
                    /// the original communicator which contain zero elements
                    /// ("excluded processes," as opposed to "included processes"),
                    /// the input \c newMap must be \c Teuchos::null (which is what
                    /// <tt>getMap()->removeEmptyProcesses()</tt> returns anyway).
                    ///
                    /// On included processes, reassign this object's Map (that would
                    /// be returned by getMap()) to the input \c newMap, and do any
                    /// work that needs to be done to restore correct semantics.  On
                    /// excluded processes, free any data that needs freeing, and do
                    /// any other work that needs to be done to restore correct
                    /// semantics.
                    ///
                    /// This method has collective semantics over the original
                    /// communicator.  On exit, the only method of this object which
                    /// is safe to call on excluded processes is the destructor.  This
                    /// implies that subclasses' destructors must not contain
                    /// communication operations.
                    ///
                    /// \return The object's new Map.  Its communicator is a new
                    ///   communicator, distinct from the old Map's communicator,
                    ///   which contains a subset of the processes in the old
                    ///   communicator.
                    ///
                    /// \note The name differs from Map's method
                    ///   removeEmptyProcesses(), in order to emphasize that the
                    ///   operation on DistObject happens in place, modifying the
                    ///   input, whereas the operation removeEmptyProcess() on Map
                    ///   does not modify the input.
                    ///
                    /// \note To implementers of DistObject subclasses: The default
                    ///   implementation of this class throws std::logic_error.
                    virtual void
                    removeEmptyProcessesInPlace (const Teuchos::RCP<const map_type>& newMap);
                
                    // Forward declaration of nonmember function.
                    template<class PT, class LO, class GO, class NT>
                    friend void
                    removeEmptyProcessesInPlace (Teuchos::RCP<Tpetra::DistObject<PT, LO, GO, NT> >& input,
                                                 const Teuchos::RCP<const Map<LO, GO, NT> >& newMap);
                    // Forward declaration of nonmember function.
                    template<class PT, class LO, class GO, class NT>
                    friend void
                    removeEmptyProcessesInPlace (Teuchos::RCP<Tpetra::DistObject<PT, LO, GO, NT> >& input);
                    //@}
                
                  protected:
                    /// \enum ReverseOption
                    /// \brief Whether the data transfer should be performed in forward or reverse mode.
                    ///
                    /// "Reverse mode" means calling doExport() with an Import object,
                    /// or calling doImport() with an Export object.  "Forward mode"
                    /// means calling doExport() with an Export object, or calling
                    /// doImport() with an Import object.
                    enum ReverseOption {
                      DoForward, //*!< Perform the transfer in forward mode.
                      DoReverse  //*!< Perform the transfer in reverse mode.
                    };
                
                    /// \brief Whether the implementation's instance promises always
                    ///   to have a constant number of packets per LID, and if so, how
                    ///   many packets per LID there are.
                    ///
                    /// If this method returns zero, the instance says that it might
                    /// possibly have a different number of packets for each LID to
                    /// send or receive.  If it returns nonzero, the instance promises
                    /// that the number of packets is the same for all LIDs, and that
                    /// the return value is this number of packets per LID.
                    ///
                    /// The default implementation of this method returns zero.  This
                    /// does not affect the behavior of doTransfer() in any way.  If a
                    /// nondefault implementation returns nonzero, doTransfer() will
                    /// use this information to avoid unnecessary allocation and / or
                    /// resizing of arrays.
                    virtual size_t constantNumberOfPackets () const;
                
                    /// \brief Redistribute data across memory images.
                    ///
                    /// \param src [in] The source object, to redistribute into
                    ///   the target object, which is <tt>*this</tt> object.
                    ///
                    /// \param CM [in] The combine mode that describes how to combine
                    ///   values that map to the same global ID on the same process.
                    ///
                    /// \param permuteToLIDs [in] See copyAndPermute().
                    ///
                    /// \param permuteFromLIDs [in] See copyAndPermute().
                    ///
                    /// \param remoteLIDs [in] List of entries (as local IDs) in the
                    ///   destination object to receive from other processes.
                    ///
                    /// \param exportLIDs [in] See packAndPrepare().
                    ///
                    /// \param distor [in/out] The Distributor object that knows how
                    ///   to redistribute data.
                    ///
                    /// \param revOp [in] Whether to do a forward or reverse mode
                    ///   redistribution.
                    virtual void
                    doTransfer (const SrcDistObject& src,
                                CombineMode CM,
                                size_t numSameIDs,
                                const Teuchos::ArrayView<const local_ordinal_type> &permuteToLIDs,
                                const Teuchos::ArrayView<const local_ordinal_type> &permuteFromLIDs,
                                const Teuchos::ArrayView<const local_ordinal_type> &remoteLIDs,
                                const Teuchos::ArrayView<const local_ordinal_type> &exportLIDs,
                                Distributor &distor,
                                ReverseOption revOp);
                
                    virtual void
                    doTransferOld (const SrcDistObject& src,
                                   CombineMode CM,
                                   size_t numSameIDs,
                                   const Teuchos::ArrayView<const local_ordinal_type> &permuteToLIDs,
                                   const Teuchos::ArrayView<const local_ordinal_type> &permuteFromLIDs,
                                   const Teuchos::ArrayView<const local_ordinal_type> &remoteLIDs,
                                   const Teuchos::ArrayView<const local_ordinal_type> &exportLIDs,
                                   Distributor &distor,
                                   ReverseOption revOp);
                
                    virtual void
                    doTransferNew (const SrcDistObject& src,
                                   const CombineMode CM,
                                   const size_t numSameIDs,
                                   const Kokkos::DualView<const local_ordinal_type*,
                                     device_type>& permuteToLIDs,
                                   const Kokkos::DualView<const local_ordinal_type*,
                                     device_type>& permuteFromLIDs,
                                   const Kokkos::DualView<const local_ordinal_type*,
                                     device_type>& remoteLIDs,
                                   const Kokkos::DualView<const local_ordinal_type*,
                                     device_type>& exportLIDs,
                                   Distributor& distor,
                                   const ReverseOption revOp,
                                   const bool commOnHost);
                
                    /// \name Methods implemented by subclasses and used by doTransfer().
                    ///
                    /// The doTransfer() method uses the subclass' implementations of
                    /// these methods to implement data transfer.  Subclasses of
                    /// DistObject must implement these methods.  This is an instance
                    /// of the <a
                    /// href="http://en.wikipedia.org/wiki/Template_method_pattern">Template
                    /// Method Pattern</a>.  ("Template" here doesn't mean "C++
                    /// template"; it means "pattern with holes that are filled in by
                    /// the subclass' method implementations.")
                    //@{
                
                    /// \brief Compare the source and target (\e this) objects for compatibility.
                    ///
                    /// \return True if they are compatible, else false.
                    virtual bool
                    checkSizes (const SrcDistObject& source) = 0;
                
                    /// \brief Whether the subclass implements the "old" or "new"
                    ///   (Kokkos-friendly) interface.
                    ///
                    /// The "old" interface consists of copyAndPermute,
                    /// packAndPrepare, and unpackAndCombine.  The "new" interface
                    /// consists of copyAndPermuteNew, packAndPrepareNew, and
                    /// unpackAndCombineNew.  The new interface is preferred because
                    /// it facilitates thread parallelization using Kokkos data
                    /// structures.
                    ///
                    /// At some point, we will remove the old interface, and rename
                    /// the "new" interface (by removing "New" from the methods'
                    /// names), so that it becomes the only interface.
                    virtual bool useNewInterface () { return false; }
                
                    /// \brief Perform copies and permutations that are local to this process.
                    ///
                    /// \param source [in] On entry, the source object, from which we
                    ///   are distributing.  We distribute to the destination object,
                    ///   which is <tt>*this</tt> object.
                    /// \param numSameIDs [in] The umber of elements that
                    ///   are the same on the source and destination (this) objects.
                    ///   These elements are owned by the same process in both the
                    ///   source and destination objects.  No permutation occurs.
                    /// \param numPermuteIDs [in] The number of elements that are
                    ///   locally permuted between the source and destination objects.
                    /// \param permuteToLIDs [in] List of the elements that are
                    ///   permuted.  They are listed by their LID in the destination
                    ///   object.
                    /// \param permuteFromLIDs [in] List of the elements that are
                    ///   permuted.  They are listed by their LID in the source
                    ///   object.
                    virtual void
                    copyAndPermute (const SrcDistObject& source,
                                    size_t numSameIDs,
                                    const Teuchos::ArrayView<const local_ordinal_type>& permuteToLIDs,
                                    const Teuchos::ArrayView<const local_ordinal_type>& permuteFromLIDs)
                    {}
                    virtual void
                    copyAndPermuteNew (const SrcDistObject& source,
                                       const size_t numSameIDs,
                                       const Kokkos::DualView<const local_ordinal_type*, device_type>& permuteToLIDs,
                                       const Kokkos::DualView<const local_ordinal_type*, device_type>& permuteFromLIDs)
                    {}
                
                    /// \brief Perform any packing or preparation required for communication.
                    ///
                    /// \param source [in] Source object for the redistribution.
                    ///
                    /// \param exportLIDs [in] List of the entries (as local IDs in
                    ///   the source object) we will be sending to other images.
                    ///
                    /// \param exports [out] On exit, the buffer for data to send.
                    ///
                    /// \param numPacketsPerLID [out] On exit, the implementation of
                    ///   this method must do one of two things: set
                    ///   numPacketsPerLID[i] to contain the number of packets to be
                    ///   exported for exportLIDs[i] and set constantNumPackets to
                    ///   zero, or set constantNumPackets to a nonzero value.  If the
                    ///   latter, the implementation need not fill numPacketsPerLID.
                    ///
                    /// \param constantNumPackets [out] On exit, 0 if numPacketsPerLID
                    ///   has variable contents (different size for each LID).  If
                    ///   nonzero, then it is expected that the number of packets per
                    ///   LID is constant, and that constantNumPackets is that value.
                    ///
                    /// \param distor [in] The Distributor object we are using.
                    virtual void
                    packAndPrepare (const SrcDistObject& source,
                                    const Teuchos::ArrayView<const local_ordinal_type>& exportLIDs,
                                    Teuchos::Array<packet_type>& exports,
                                    const Teuchos::ArrayView<size_t>& numPacketsPerLID,
                                    size_t& constantNumPackets,
                                    Distributor &distor)
                    {}
                
                    virtual void
                    packAndPrepareNew (const SrcDistObject& source,
                                       const Kokkos::DualView<const local_ordinal_type*, device_type>& exportLIDs,
                                       Kokkos::DualView<packet_type*, device_type>& exports,
                                       const Kokkos::DualView<size_t*, device_type>& numPacketsPerLID,
                                       size_t& constantNumPackets,
                                       Distributor& distor)
                    {}
                
                    /// \brief Perform any unpacking and combining after communication
                    ///   (old version that uses Teuchos memory management classes to
                    ///   hold data).
                    ///
                    /// \param importLIDs [in] List of the entries (as LIDs in the
                    ///   destination object) we received from other images.
                    ///
                    /// \param imports [in] Buffer containing data we received.
                    ///
                    /// \param numPacketsPerLID [in] If constantNumPackets is zero,
                    ///   then numPacketsPerLID[i] contains the number of packets
                    ///   imported for importLIDs[i].
                    ///
                    /// \param constantNumPackets [in] If nonzero, then
                    ///   numPacketsPerLID is constant (same value in all entries) and
                    ///   constantNumPackets is that value.  If zero, then
                    ///   numPacketsPerLID[i] is the number of packets imported for
                    ///   importLIDs[i].
                    ///
                    /// \param distor [in] The Distributor object we are using.
                    ///
                    /// \param CM [in] The combine mode to use when combining the
                    ///   imported entries with existing entries.
                    virtual void
                    unpackAndCombine (const Teuchos::ArrayView<const local_ordinal_type>& importLIDs,
                                      const Teuchos::ArrayView<const packet_type>& imports,
                                      const Teuchos::ArrayView<size_t>& numPacketsPerLID,
                                      size_t constantNumPackets,
                                      Distributor &distor,
                                      CombineMode CM)
                    {}
                
                    /// \brief Perform any unpacking and combining after communication
                    ///   (new version that uses Kokkos data structures to hold data).
                    ///
                    /// The \c imports input argument controls whether this method
                    /// should unpack on host or unpack on device.
                    ///
                    /// \param importLIDs [in] List of the entries (as LIDs in the
                    ///   destination object) we received from other images.
                    ///
                    /// \param imports [in] Buffer containing data we received.
                    ///
                    /// \param numPacketsPerLID [in] If constantNumPackets is zero,
                    ///   then numPacketsPerLID[i] contains the number of packets
                    ///   imported for importLIDs[i].
                    ///
                    /// \param constantNumPackets [in] If nonzero, then
                    ///   numPacketsPerLID is constant (same value in all entries) and
                    ///   constantNumPackets is that value.  If zero, then
                    ///   numPacketsPerLID[i] is the number of packets imported for
                    ///   importLIDs[i].
                    ///
                    /// \param distor [in] The Distributor object we are using.
                    ///
                    /// \param CM [in] The combine mode to use when combining the
                    ///   imported entries with existing entries.
                    virtual void
                    unpackAndCombineNew (const Kokkos::DualView<const local_ordinal_type*, device_type>& importLIDs,
                                         const Kokkos::DualView<const packet_type*, device_type>& imports,
                                         const Kokkos::DualView<const size_t*, device_type>& numPacketsPerLID,
                                         const size_t constantNumPackets,
                                         Distributor& distor,
                                         const CombineMode CM)
                    {}
                    //@}
                
                    /// \brief Hook for creating a const view.
                    ///
                    /// doTransfer() calls this on the source object.  By default,
                    /// it does nothing, but the source object can use this as a hint
                    /// to fetch data from a compute buffer on an off-CPU device (such
                    /// as a GPU) into host memory.
                    virtual void createViews () const;
                
                    /// \brief Hook for creating a nonconst view.
                    ///
                    /// doTransfer() calls this on the destination (<tt>*this</tt>)
                    /// object.  By default, it does nothing, but the destination
                    /// object can use this as a hint to fetch data from a compute
                    /// buffer on an off-CPU device (such as a GPU) into host memory.
                    ///
                    /// \param rwo [in] Whether to create a write-only or a
                    ///   read-and-write view.  For Kokkos Node types where compute
                    ///   buffers live in a separate memory space (e.g., in the device
                    ///   memory of a discrete accelerator like a GPU), a write-only
                    ///   view only requires copying from host memory to the compute
                    ///   buffer, whereas a read-and-write view requires copying both
                    ///   ways (once to read, from the compute buffer to host memory,
                    ///   and once to write, back to the compute buffer).
                    virtual void createViewsNonConst (KokkosClassic::ReadWriteOption rwo);
                
                    /// \brief Hook for releasing views.
                    ///
                    /// \note This is no longer called (and is therefore no longer
                    ///   needed) for subclasses for which useNewInterface() returns
                    ///   \c true.
                    ///
                    /// doTransfer() calls this on both the source and destination
                    /// objects, once it no longer needs to access that object's data.
                    /// By default, this method does nothing.  Implementations may use
                    /// this as a hint to free host memory which is a view of a
                    /// compute buffer, once the host memory view is no longer needed.
                    /// Some implementations may prefer to mirror compute buffers in
                    /// host memory; for these implementations, releaseViews() may do
                    /// nothing.
                    virtual void releaseViews () const;
                
                    //! The Map over which this object is distributed.
                    Teuchos::RCP<const map_type> map_;
                
                  protected:
                    /// \brief Buffer into which packed data are imported (received
                    ///   from other processes).
                    ///
                    /// Unfortunately, I had to declare these protected, because
                    /// CrsMatrix uses them at one point.  Please, nobody else use
                    /// them.
                    Kokkos::DualView<packet_type*, execution_space> imports_;
                
                    /// \brief Reallocate imports_ if needed.
                    ///
                    /// This unfortunately must be declared protected, for the same
                    /// reason that imports_ is declared protected.
                    ///
                    /// \param newSize [in] New size of imports_.
                    /// \param debug [in] Whether to print (copious) debug output to stderr.
                    void
                    reallocImportsIfNeeded (const size_t newSize, const bool debug = false);
                
                    /// \brief Number of packets to receive for each receive operation.
                    ///
                    /// This array is used in Distributor::doPosts() (and
                    /// doReversePosts()) when starting the ireceive operation.
                    ///
                    /// This may be ignored in doTransfer() if constantNumPackets
                    /// is nonzero, indicating a constant number of packets per LID.
                    /// (For example, MultiVector sets the constantNumPackets output
                    /// argument of packAndPrepare() to the number of columns in
                    /// the multivector.)
                    ///
                    /// Unfortunately, I had to declare this protected, because
                    /// CrsMatrix uses it at one point.  Please, nobody else use it.
                    Kokkos::DualView<size_t*, execution_space> numImportPacketsPerLID_;
                
                    /// \brief Buffer from which packed data are exported (sent to
                    ///   other processes).
                    ///
                    /// Unfortunately, I had to declare this protected, because
                    /// CrsMatrix uses it at one point.  Please, nobody else use it.
                    Kokkos::DualView<packet_type*, device_type> exports_;
                
                    /// \brief Number of packets to send for each send operation.
                    ///
                    /// This array is used in Distributor::doPosts() (and
                    /// doReversePosts()) for preparing for the send operation.
                    ///
                    /// This may be ignored in doTransfer() if constantNumPackets is
                    /// nonzero, indicating a constant number of packets per LID.
                    /// (For example, MultiVector sets the constantNumPackets output
                    /// argument of packAndPrepare() to the number of columns in the
                    /// multivector.)
                    ///
                    /// Unfortunately, I had to declare this protected, because
                    /// CrsMatrix uses them at one point.  Please, nobody else use it.
                    Kokkos::DualView<size_t*, execution_space> numExportPacketsPerLID_;
                
                #ifdef HAVE_TPETRA_TRANSFER_TIMERS
                  private:
                    Teuchos::RCP<Teuchos::Time> doXferTimer_;
                    Teuchos::RCP<Teuchos::Time> copyAndPermuteTimer_;
                    Teuchos::RCP<Teuchos::Time> packAndPrepareTimer_;
                    Teuchos::RCP<Teuchos::Time> doPostsAndWaitsTimer_;
                    Teuchos::RCP<Teuchos::Time> unpackAndCombineTimer_;
                #endif // HAVE_TPETRA_TRANSFER_TIMERS
                
                  }; // class DistObject
                
                  /// \brief Remove processes which contain no elements in this object's Map.
                  ///
                  /// \tparam DistObjectType A specialization of DistObject.
                  ///
                  /// \warning This method is ONLY for use by experts.  The fact that
                  ///   the documentation of this method starts with a "Vocabulary"
                  ///   section should give you proper respect for the complicated
                  ///   semantics of this method in a parallel MPI run.
                  /// \warning We make NO promises of backwards compatibility.
                  ///   This method may change or disappear at any time.
                  ///
                  /// Vocabulary:
                  /// - The Map returned by <tt>input->getMap() on input to this
                  ///   method is the "original Map."
                  /// - The communicator returned by <tt>input->getComm() on
                  ///   input to this method is the "original communicator."
                  /// - All processes in the original communicator which contain zero
                  ///   elements in the original Map are "excluded processes."
                  /// - All other processes in the original communicator are "included
                  ///   processes."
                  ///
                  /// Preconditions:
                  /// - The nonnull object \c input is distributed over the
                  ///   original Map.
                  /// - The input Map <tt>newMap</tt> <i>must</i> be the same as the
                  ///   result of calling removeEmptyProcesses() on the original Map.
                  /// - On excluded processes, <tt>newMap</tt> must be
                  ///   <tt>Teuchos::null</tt>.  (This is what
                  ///   <tt>getMap()->removeEmptyProcesses()</tt> returns anyway on
                  ///   excluded processes.)
                  ///
                  /// This method has collective semantics over the original
                  /// communicator.  On included processes, reassign this object's Map
                  /// (that would be returned by getMap()) to the input \c newMap, and
                  /// do any work that needs to be done to restore correct semantics.
                  /// The input DistObject \c input will be nonnull on return.  On
                  /// excluded processes, free any data in \c input that need freeing,
                  /// do any other work that needs to be done to restore correct
                  /// semantics, and set \c input to null before returning.
                  ///
                  /// The two-argument version of this function is useful if you have
                  /// already precomputed the new Map that excludes processes with
                  /// zero elements.  For example, you might want to apply this Map to
                  /// several different MultiVector instances.  The one-argument
                  /// version of this function is useful if you want the DistObject to
                  /// compute the new Map itself, because you only plan to use it for
                  /// that one DistObject instance.
                  ///
                  /// Here is a sample use case.  Suppose that \c input is some
                  /// subclass of DistObject, like MultiVector, CrsGraph, or
                  /// CrsMatrix.  Suppose also that \c map_type is the corresponding
                  /// specialization of Map.
                  /// \code
                  /// RCP<const map_type> origRowMap = input->getMap ();
                  /// RCP<const map_type> newRowMap = origRowMap->removeEmptyProcesses ();
                  /// removeEmptyProcessesInPlace (input, newRowMap);
                  /// // Either (both the new Map and input are null), or
                  /// // (both the new Map and input are not null).
                  /// assert ((newRowMap.is_null () && input.is_null ()) ||
                  ///         (! newRowMap.is_null () && ! input.is_null ()));
                  /// \endcode
                  ///
                  /// \warning On excluded processes, calling this function
                  ///   invalidates any other references to the input DistObject
                  ///   <tt>input</tt>.  Calling any methods (other than the
                  ///   destructor) on the input on excluded processes has undefined
                  ///   behavior in that case, and may result in deadlock.
                  ///
                  /// \note The name differs from Map's method
                  ///   removeEmptyProcesses(), in order to emphasize that the
                  ///   operation on DistObject happens in place, modifying the
                  ///   input, whereas the operation removeEmptyProcess() on Map
                  ///   does not modify the input.
                  ///
                  /// \note To implementers of DistObject subclasses: The default
                  ///   implementation of this class throws std::logic_error.
                  ///
                  /// \note To implementers of DistObject subclasses: On exit, the
                  ///   only method of this object which is safe to call on excluded
                  ///   processes is the destructor, or this method with the original
                  ///   Map.  This implies that subclasses' destructors must not
                  ///   contain communication operations.
                  template<class DistObjectType>
                  void
                  removeEmptyProcessesInPlace (Teuchos::RCP<DistObjectType>& input,
                                               const Teuchos::RCP<const Map<typename DistObjectType::local_ordinal_type,
                                                                            typename DistObjectType::global_ordinal_type,
                                                                            typename DistObjectType::node_type> >& newMap);
                
                  /// \brief Remove processes which contain no elements in this object's Map.
                  ///
                  /// \tparam DistObjectType A specialization of DistObject.
                  ///
                  /// \warning This method is ONLY for use by experts.
                  /// \warning We make NO promises of backwards compatibility.
                  ///   This method may change or disappear at any time.
                  ///
                  /// This method behaves just like the two-argument version of
                  /// removeEmptyProcessesInPlace(), except that it first calls
                  /// removeEmptyProcesses() on the input DistObject's Map to compute
                  /// the new Map.
                  ///
                  /// The two-argument version of this function is useful if you have
                  /// already precomputed the new Map that excludes processes with
                  /// zero elements.  For example, you might want to apply this Map to
                  /// several different MultiVector instances.  The one-argument
                  /// version of this function is useful if you want the DistObject to
                  /// compute the new Map itself, because you only plan to use it for
                  /// that one DistObject instance.
                  ///
                  /// Here is a sample use case.  Suppose that \c input is some
                  /// subclass of DistObject, like MultiVector, CrsGraph, or
                  /// CrsMatrix.  Suppose also that \c map_type is the corresponding
                  /// specialization of Map.
                  /// \code
                  /// removeEmptyProcessesInPlace (input);
                  /// RCP<const map_type> newRowMap;
                  /// if (! input.is_null ()) {
                  ///   newRowMap = input->getMap ();
                  /// }
                  /// // Either (both the new Map and input are null), or
                  /// // (both the new Map and input are not null).
                  /// assert ((newRowMap.is_null () && input.is_null ()) ||
                  ///         (! newRowMap.is_null () && ! input.is_null ()));
                  /// \endcode
                  template<class DistObjectType>
                  void
                  removeEmptyProcessesInPlace (Teuchos::RCP<DistObjectType>& input);
                
                } // namespace Tpetra
                
                #endif // TPETRA_DISTOBJECT_DECL_HPP


Top 10 Lines:

     Line      Count

      345         57

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       57   Total number of line executions
    57.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_CreateTpetraPreconditioner.hpp:
                #ifndef MUELU_CREATE_TPETRA_PRECONDITIONER_HPP
                #define MUELU_CREATE_TPETRA_PRECONDITIONER_HPP
                
                //! @file
                //! @brief Various adapters that will create a MueLu preconditioner that is a Tpetra::Operator.
                
                #include <Teuchos_XMLParameterListHelpers.hpp>
                #include <Tpetra_Operator.hpp>
                #include <Tpetra_RowMatrix.hpp>
                #include <Xpetra_TpetraBlockCrsMatrix.hpp>
                #include <Tpetra_Experimental_BlockCrsMatrix.hpp>
                #include <Xpetra_CrsMatrix.hpp>
                #include <Xpetra_MultiVector.hpp>
                #include <Xpetra_MultiVectorFactory.hpp>
                
                #include <MueLu.hpp>
                
                #include <MueLu_Exceptions.hpp>
                #include <MueLu_Hierarchy.hpp>
                #include <MueLu_MasterList.hpp>
                #include <MueLu_MLParameterListInterpreter.hpp>
                #include <MueLu_ParameterListInterpreter.hpp>
                #include <MueLu_TpetraOperator.hpp>
                #include <MueLu_CreateXpetraPreconditioner.hpp>
                #include <MueLu_Utilities.hpp>
                #include <MueLu_HierarchyUtils.hpp>
                
                
                #if defined(HAVE_MUELU_EXPERIMENTAL) and defined(HAVE_MUELU_AMGX)
                #include <MueLu_AMGXOperator.hpp>
                #include <amgx_c.h>
                #include "cuda_runtime.h"
                #endif
                
                namespace MueLu {
                
                
                  /*!
                    @brief Helper function to create a MueLu or AMGX preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                    Given a Tpetra::Operator, this function returns a constructed MueLu preconditioner.
                    @param[in] inA Matrix
                    @param[in] inParamList Parameter list
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
           1 ->   CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::Operator<Scalar, LocalOrdinal, GlobalOrdinal, Node> > &inA,
                                         Teuchos::ParameterList& inParamList,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    typedef Scalar          SC;
                    typedef LocalOrdinal    LO;
                    typedef GlobalOrdinal   GO;
                    typedef Node            NO;
                
                    using   Teuchos::ParameterList;
                
                    typedef Xpetra::MultiVector<SC,LO,GO,NO>            MultiVector;
                    typedef Xpetra::Matrix<SC,LO,GO,NO>                 Matrix;
                    typedef Hierarchy<SC,LO,GO,NO>                      Hierarchy;
                    //typedef HierarchyManager<SC,LO,GO,NO>               HierarchyManager;  // not used
                    typedef Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> crs_matrix_type;
                    typedef Tpetra::Experimental::BlockCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> block_crs_matrix_type;
                
                #if defined(HAVE_MUELU_EXPERIMENTAL) and defined(HAVE_MUELU_AMGX)
                    std::string externalMG = "use external multigrid package";
                    if (hasParamList && paramList.isParameter(externalMG) && paramList.get<std::string>(externalMG) == "amgx"){
                      constCrsA = rcp_dynamic_cast<const crs_matrix_type>(inA);
                      TEUCHOS_TEST_FOR_EXCEPTION(constCrsA == Teuchos::null, Exceptions::RuntimeError, "CreateTpetraPreconditioner: failed to dynamic cast to Tpetra::CrsMatrix, which is required to be able to use AmgX.");
                      return rcp(new AMGXOperator<SC,LO,GO,NO>(inA,inParamList));
                    }
                #endif
                
                    // Wrap A
                    RCP<Matrix> A;
                    RCP<block_crs_matrix_type> bcrsA = rcp_dynamic_cast<block_crs_matrix_type>(inA);
                    RCP<crs_matrix_type> crsA = rcp_dynamic_cast<crs_matrix_type>(inA);
                    if (crsA != Teuchos::null)
                      A = TpetraCrs_To_XpetraMatrix<SC,LO,GO,NO>(crsA);
                    else if (bcrsA != Teuchos::null) {
                      RCP<Xpetra::CrsMatrix<SC,LO,GO,NO> > temp = rcp(new Xpetra::TpetraBlockCrsMatrix<SC,LO,GO,NO>(bcrsA));
                      TEUCHOS_TEST_FOR_EXCEPTION(temp==Teuchos::null, Exceptions::RuntimeError, "CreateTpetraPreconditioner: cast from Tpetra::Experimental::BlockCrsMatrix to Xpetra::TpetraBlockCrsMatrix failed.");
                      A = rcp(new Xpetra::CrsMatrixWrap<SC,LO,GO,NO>(temp));
                    }
                    else {
                      TEUCHOS_TEST_FOR_EXCEPTION(true, Exceptions::RuntimeError, "CreateTpetraPreconditioner: only Tpetra CrsMatrix and BlockCrsMatrix types are supported.");
                    }
                
                    RCP<Xpetra::MultiVector<double,LO,GO,NO> > coordinates = Teuchos::null;
                    if (inCoords != Teuchos::null) {
                      coordinates = TpetraMultiVector_To_XpetraMultiVector<double,LO,GO,NO>(inCoords);
                    }
                    RCP<MultiVector> nullspace = Teuchos::null;
                    if (inNullspace != Teuchos::null) {
                      nullspace = TpetraMultiVector_To_XpetraMultiVector<SC,LO,GO,NO>(inNullspace);
                    }
                
                    RCP<Hierarchy> H = MueLu::CreateXpetraPreconditioner<SC,LO,GO,NO>(A,inParamList,coordinates,nullspace);
                    return rcp(new TpetraOperator<SC,LO,GO,NO>(H));
                  }
                
                
                  /*!
                    @brief Helper function to create a MueLu preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                
                    Given a Tpetra::CrsMatrix, this function returns a constructed MueLu preconditioner.
                    This method is deprecated.
                
                    @param[in] inA Matrix
                    @param[in] inParamList Parameter list
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  MUELU_DEPRECATED
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
                  CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > &inA,
                                         Teuchos::ParameterList& inParamList,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    RCP<Tpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>> opMat(inA);
                    return CreateTpetraPreconditioner<Scalar, LocalOrdinal, GlobalOrdinal, Node>(opMat, inParamList, inCoords, inNullspace);
                  }
                
                
                  /*!
                    @brief Helper function to create a MueLu preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                
                    Given a Tpetra::CrsMatrix, this function returns a constructed MueLu preconditioner.
                    This method is deprecated.
                
                    @param[in] inA Matrix
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  MUELU_DEPRECATED
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
                  CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::CrsMatrix  <Scalar, LocalOrdinal, GlobalOrdinal, Node> >& inA,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    Teuchos::ParameterList paramList;
                    RCP<Tpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>> opMat(inA);
                    return CreateTpetraPreconditioner<Scalar, LocalOrdinal, GlobalOrdinal, Node>(opMat, paramList, inCoords, inNullspace);
                  }
                
                
                  /*!
                    @brief Helper function to create a MueLu preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                
                    Given a Tpetra::CrsMatrix, this function returns a constructed MueLu preconditioner.
                    This method is deprecated.
                
                    @param[in] inA Matrix
                    @param[in] xmlFileName XML file containing MueLu options
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  MUELU_DEPRECATED
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
                  CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::CrsMatrix  <Scalar, LocalOrdinal, GlobalOrdinal, Node> >& inA,
                                         const std::string& xmlFileName,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    Teuchos::ParameterList paramList;
                    Teuchos::updateParametersFromXmlFileAndBroadcast(xmlFileName, Teuchos::Ptr<Teuchos::ParameterList>(&paramList), *inA->getComm());
                
                    RCP<Tpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>> opMat(inA);
                    return CreateTpetraPreconditioner<Scalar, LocalOrdinal, GlobalOrdinal, Node>(opMat, paramList, inCoords, inNullspace);
                  }
                
                
                  /*!
                    @brief Helper function to create a MueLu preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                
                    Given a Tpetra::Operator , this function returns a constructed MueLu preconditioner.
                
                    @param[in] inA Matrix
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
                  CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::Operator<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& inA,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    Teuchos::ParameterList paramList;
                    return CreateTpetraPreconditioner<Scalar, LocalOrdinal, GlobalOrdinal, Node>(inA, paramList, inCoords, inNullspace);
                  }
                
                
                  /*!
                    @brief Helper function to create a MueLu preconditioner that can be used by Tpetra.
                    @ingroup MueLuAdapters
                
                    Given a Tpetra::Operator, this function returns a constructed MueLu preconditioner.
                
                    @param[in] inA Matrix
                    @param[in] xmlFileName XML file containing MueLu options
                    @param[in] inCoords (optional) Coordinates.  The first vector is x, the second (if necessary) y, the third (if necessary) z.
                    @param[in] inNullspace (optional) Near nullspace of the matrix.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  Teuchos::RCP<MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node> >
       ##### ->   CreateTpetraPreconditioner(const Teuchos::RCP<Tpetra::Operator<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& inA,
                                         const std::string& xmlFileName,
                                         const Teuchos::RCP<Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node>>& inCoords = Teuchos::null,
                                         const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>>& inNullspace = Teuchos::null)
                  {
                    Teuchos::ParameterList paramList;
                    Teuchos::updateParametersFromXmlFileAndBroadcast(xmlFileName, Teuchos::Ptr<Teuchos::ParameterList>(&paramList), *inA->getDomainMap()->getComm());
                    return CreateTpetraPreconditioner<Scalar, LocalOrdinal, GlobalOrdinal, Node>(inA, paramList, inCoords, inNullspace);
                  }
                
                
                  /*!
                    @brief Helper function to reuse an existing MueLu preconditioner.
                    @ingroup MueLuAdapters
                
                    @param[in] inA Matrix
                    @param[in] Op  Existing MueLu preconditioner.
                  */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  void ReuseTpetraPreconditioner(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& inA,
                                                 MueLu::TpetraOperator<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op) {
                    typedef Scalar          SC;
                    typedef LocalOrdinal    LO;
                    typedef GlobalOrdinal   GO;
                    typedef Node            NO;
                
                    typedef Xpetra::Matrix<SC,LO,GO,NO>     Matrix;
                    typedef MueLu ::Hierarchy<SC,LO,GO,NO>  Hierarchy;
                
                    RCP<Hierarchy> H = Op.GetHierarchy();
                    RCP<Matrix>    A = TpetraCrs_To_XpetraMatrix<SC,LO,GO,NO>(inA);
                
                    MueLu::ReuseXpetraPreconditioner<SC,LO,GO,NO>(A, H);
                  }
                
                } //namespace
                
                #endif //ifndef MUELU_CREATE_TPETRA_PRECONDITIONER_HPP
                


Top 10 Lines:

     Line      Count

       49          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_Hashtable.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_HASHTABLE_H
                #define TEUCHOS_HASHTABLE_H
                
                /*! \file Teuchos_Hashtable.hpp
                    \brief Templated hashtable class
                */
                
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_Array.hpp"
                #include "Teuchos_HashUtils.hpp"
                
                namespace Teuchos
                {
                  using std::string;
                
                  /** \ingroup Containers
                   * \brief Helper class for Teuchos::Hashtable, representing a single <key, value> pair.
                   */
       ##### ->   template<class Key, class Value> class HashPair
                    {
                    public:
                      //! Empty constructor
                      inline HashPair() : key_(), value_() {;}
                      //! Basic <key, value> constructor
                      inline HashPair(const Key& key, const Value& value)
                        : key_(key), value_(value) {;}
                
                      //! Templated key variable
                      Key key_;
                      //! Templated value variable
                      Value value_;
                    };
                
                  /**
                     \ingroup Containers
                     \brief Templated hashtable class.
                     @author Kevin Long
                  */
                  template<class Key, class Value> class Hashtable
                    {
                    public:
                
                      //! Create an empty Hashtable
                      inline Hashtable(int capacity=101, double rehashDensity = 0.8);
                
                      //! Check for the presence of a key
                      inline bool containsKey(const Key& key) const ;
                
                      //! Get the value indexed by key
                      inline const Value& get(const Key& key) const ;
                
                      //! Put a new (key, value) pair in the table.
                      inline void put(const Key& key, const Value& value);
                
                      //! Remove from the table the element given by key.
                      inline void remove(const Key& key);
                
                      //! Get the number of elements in the table
                      inline int size() const {return count_;}
                
                      //! Get lists of keys and values in Array form
                      inline void arrayify(Array<Key>& keys, Array<Value>& values) const ;
                
                      //! Return the average degeneracy (average number of entries per hash code).
                      inline double avgDegeneracy() const {return avgDegeneracy_;}
                
                      //! Return the density of the hashtable (num entries / capacity)
                      inline double density() const {return ((double)count_)/((double) capacity_);}
                
                      //! Set the density at which to do a rehash
                      inline void setRehashDensity(double rehashDensity);
                
                      //! Write to a std::string
                      inline std::string toString() const ;
                
                    private:
                
                      inline void rehash();
                      inline int nextPrime(int newCap) const ;
                      inline void accumulateAvgFill(int n) const ;
                
                
                      Array<Array<HashPair<Key, Value> > > data_;
                      int count_;
                      int capacity_;
                      mutable Value mostRecentValue_;
                      mutable Key mostRecentKey_;
                
                      mutable size_t nHits_;
                      mutable double avgDegeneracy_;
                      double rehashDensity_;
                    };
                
                  template<class Key, class Value>
                  std::string toString(const Hashtable<Key, Value>& h);
                
                  /** \relates Hashtable
                      \brief Write Hashtable to a stream
                  */
                  template<class Key, class Value>
                  std::ostream& operator<<(std::ostream& os, const Hashtable<Key, Value>& h);
                
                  template<class Key, class Value> inline
                    Hashtable<Key, Value>::Hashtable(int capacity, double rehashDensity):
                    data_(),
                    count_(0),
                    capacity_(HashUtils::nextPrime(capacity)),
                    nHits_(0),
                    avgDegeneracy_(0),
                    rehashDensity_(rehashDensity)
                    {
                      data_.resize(capacity_);
                    }
                
                  template<class Key, class Value> inline
                    bool Hashtable<Key, Value>::containsKey(const Key& key) const
                    {
                      const Array<HashPair<Key, Value> >& candidates
                        = data_[hashCode(key) % capacity_];
                
                      for (int i=0; i<candidates.length(); i++)
                        {
                          const HashPair<Key, Value>& c = candidates[i];
                          if (c.key_ == key)
                            {
                              //          (Key&) mostRecentKey_ = key;
                              //(Value&) mostRecentValue_ = c.value_;
                              return true;
                            }
                        }
                      return false;
                    }
                
                  template<class Key, class Value> inline
                    void Hashtable<Key, Value>::put(const Key& key, const Value& value)
                    {
                      int index = hashCode(key) % capacity_;
                
                      Array<HashPair<Key, Value> >& local = data_[index];
                
                      // check for duplicate key
                      for (int i=0; i<local.length(); i++)
                        {
                          if (local[i].key_ == key)
                            {
                              local[i].value_ = value;
                              return;
                            }
                        }
                
                      // no duplicate key, so increment element count by one.
                      count_++;
                
                      // check for need to resize.
                      if ((double) count_ > rehashDensity_ * (double) capacity_)
                        {
                          capacity_ = HashUtils::nextPrime(capacity_+1);
                          rehash();
                          // recaluate index
                          index = hashCode(key) % capacity_;
                        }
                
                      data_[index].append(HashPair<Key, Value>(key, value));
                    }
                
                
                
                  template<class Key, class Value> inline
                    void Hashtable<Key, Value>::rehash()
                    {
                      Array<Array<HashPair<Key, Value> > > tmp(capacity_);
                
                      for (int i=0; i<data_.length(); i++)
                        {
                          for (int j=0; j<data_[i].length(); j++)
                            {
                              int newIndex = hashCode(data_[i][j].key_) % capacity_;
                              tmp[newIndex].append(data_[i][j]);
                            }
                        }
                
                      data_ = tmp;
                    }
                
                
                  template<class Key, class Value> inline
                    void Hashtable<Key, Value>::arrayify(Array<Key>& keys, Array<Value>& values) const
                    {
                      keys.reserve(size());
                      values.reserve(size());
                
                      for (int i=0; i<data_.length(); i++)
                        {
                          for (int j=0; j<data_[i].length(); j++)
                            {
                              keys.append(data_[i][j].key_);
                              values.append(data_[i][j].value_);
                            }
                        }
                    }
                
                  template<class Key, class Value>  inline
       ##### ->   std::string Hashtable<Key, Value>::toString() const
                  {
                    Array<Key> keys;
                    Array<Value> values;
                    arrayify(keys, values);
                
                    std::string rtn = "[";
                    for (int i=0; i<keys.length(); i++)
                      {
                        rtn += "{" + Teuchos::toString(keys[i]) + ", " + Teuchos::toString(values[i])
                          + "}";
                        if (i < keys.length()-1) rtn += ", ";
                      }
                    rtn += "]";
                
                    return rtn;
                  }
                
                  template<class Key, class Value>  inline
                    std::string toString(const Hashtable<Key, Value>& h)
                    {
                      Array<Key> keys;
                      Array<Value> values;
                      h.arrayify(keys, values);
                
                      std::string rtn = "[";
                      for (int i=0; i<keys.length(); i++)
                        {
                          rtn += "{" + Teuchos::toString(keys[i]) + ", " + Teuchos::toString(values[i])
                            + "}";
                          if (i < keys.length()-1) rtn += ", ";
                        }
                      rtn += "]";
                
                      return rtn;
                    }
                
                  template<class Key, class Value> inline
           1 ->     const Value& Hashtable<Key, Value>::get(const Key& key) const
                    {
                      TEUCHOS_TEST_FOR_EXCEPTION(!containsKey(key),
                                         std::runtime_error,
                                         "Hashtable<Key, Value>::get: key "
                                         << Teuchos::toString(key)
                                         << " not found in Hashtable"
                                         << toString());
                
                      const Array<HashPair<Key, Value> >& candidates
                        = data_[hashCode(key) % capacity_];
                
                      accumulateAvgFill(candidates.length());
                
                      for (int i=0; i<candidates.length(); i++)
                        {
                          const HashPair<Key, Value>& c = candidates[i];
                          if (c.key_ == key)
                            {
                              return c.value_;
                            }
                        }
                      return mostRecentValue_;
                    }
                
                
                  template<class Key, class Value> inline
                    void Hashtable<Key, Value>::remove(const Key& key)
                    {
                      TEUCHOS_TEST_FOR_EXCEPTION(!containsKey(key),
                                         std::runtime_error,
                                         "Hashtable<Key, Value>::remove: key "
                                         << Teuchos::toString(key)
                                         << " not found in Hashtable"
                                         << toString());
                
                      count_--;
                      int h = hashCode(key) % capacity_;
                      const Array<HashPair<Key, Value> >& candidates = data_[h];
                
                      for (int i=0; i<candidates.length(); i++)
                        {
                          const HashPair<Key, Value>& c = candidates[i];
                          if (c.key_ == key)
                            {
                              data_[h].remove(i);
                              break;
                            }
                        }
                    }
                
                  template<class Key, class Value> inline
                  void Hashtable<Key, Value>::accumulateAvgFill(int n) const
                  {
                    avgDegeneracy_ = ((double) nHits_)/(nHits_ + 1.0) * avgDegeneracy_ + ((double) n)/(nHits_ + 1.0);
                    nHits_++;
                    }
                
                  template<class Key, class Value>  inline
                    std::ostream& operator<<(std::ostream& os, const Hashtable<Key, Value>& h)
                    {
                      return os << toString(h);
                    }
                
                
                }
                
                #endif // TEUCHOS_HASHTABLE_H


Top 10 Lines:

     Line      Count

      282          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.33   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_TimeMonitor.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_TIMEMONITOR_HPP
                #define TEUCHOS_TIMEMONITOR_HPP
                
                
                /*! \file Teuchos_TimeMonitor.hpp
                 *
                 * \brief Scope protection wrapper for Teuchos::Time, with timer reporting functionality.
                 *
                 * An instance of the Teuchos::TimeMonitor class wraps a nonconst
                 * reference to a Teuchos::Time timer object.  TimeMonitor's
                 * constructor starts the timer, and its destructor stops the timer.
                 * This ensures scope safety of timers, so that no matter how a scope
                 * is exited (whether the normal way or when an exception is thrown),
                 * a timer started in the scope is stopped when the scope is left.
                 *
                 * TimeMonitor also has class methods that create or destroy timers
                 * (in such a way that it can track the complete set of created timers
                 * on each process) and compute global timer statistics.
                 */
                
                /** \example TimeMonitor/cxx_main.cpp
                 *
                 * This is an example of how to use the Teuchos::TimeMonitor class.
                 */
                
                #include "Teuchos_PerformanceMonitorBase.hpp"
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_Comm.hpp"
                #include "Teuchos_Time.hpp"
                
                #include "Teuchos_CommandLineProcessor.hpp"
                
                /// \brief Defines a static non-member function that returns a Teuchos timer.
                ///
                /// \warning Please don't use this macro.  It is a bad idea to keep
                ///   around static RCP objects past return from main().
                #define TEUCHOS_TIMER(funcName, strName) \
                  static Teuchos::Time& funcName() \
                  {static Teuchos::RCP<Time> rtn = \
                      Teuchos::TimeMonitor::getNewCounter(strName); return *rtn;}
                
                
                /** \brief Defines a timer for a specific function (with differentiator).
                 *
                 * Same as TEUCHOS_FUNC_TIME_MONITOR(...) except required when used more than
                 * once in the same function (like a block of code).
                 *
                 * \warning Please don't use this macro.  It is a bad idea to keep
                 *   around static RCP objects past return from main().
                 */
                #define TEUCHOS_FUNC_TIME_MONITOR_DIFF( FUNCNAME, DIFF ) \
                  static Teuchos::RCP<Teuchos::Time> DIFF ## blabla_localTimer; \
                  if(!DIFF ## blabla_localTimer.get()) { \
                    std::ostringstream oss; \
                    oss << FUNCNAME; \
                    DIFF ## blabla_localTimer = Teuchos::TimeMonitor::getNewCounter(oss.str()); \
                  } \
                  Teuchos::TimeMonitor DIFF ## blabla_localTimeMonitor(*DIFF ## blabla_localTimer)
                
                
                /** \brief Defines a timer for a specific function.
                 *
                 Note that the name of the timer can be formated with stream inserts.
                 For example, we can define a time monitor for a function as follows:
                
                 \code
                 template<typename Scalar>
                 void foo()
                 {
                   TEUCHOS_FUNC_TIME_MONITOR(
                     "foo<" << Teuchos::ScalarTraits<Scalar>::name () << ">()"
                     );
                   ...
                 }
                 \endcode
                
                 The timer can then be printed at the end of the program using any of
                 various class methods, including summarize():
                 \code
                 Teuchos::TimeMonitor::summarize ();
                 \endcode
                */
                #define TEUCHOS_FUNC_TIME_MONITOR( FUNCNAME ) \
                  TEUCHOS_FUNC_TIME_MONITOR_DIFF( FUNCNAME, main )
                
                
                namespace Teuchos {
                
                /// \typedef stat_map_type
                /// \brief Global statistics collected from timer data.
                ///
                /// Key: name of the timer.
                ///
                /// Value: each entry in the vector is a timing and call count for
                ///   that timer, corresponding to a particular statistic (e.g.,
                ///   minimum, arithmetic mean, or maximum).  What statistic that is
                ///   depends on an auxillary array "statNames" which has the same
                ///   ordering as the entries in this vector.  See the documentation
                ///   of \c TimeMonitor::computeGlobalTimerStatistics().
                typedef std::map<std::string, std::vector<std::pair<double, double> > > stat_map_type;
                
                /// \class TimeMonitor
                /// \brief A scope-safe timer wrapper class, that can compute global timer statistics.
                ///
                /// An instance of the TimeMonitor class wraps a nonconst reference to
                /// a Time timer object.  TimeMonitor's constructor starts the timer,
                /// and its destructor stops the timer.  This ensures scope safety of
                /// timers, so that no matter how a scope is exited (whether the
                /// normal way or when an exception is thrown), a timer started in the
                /// scope is stopped when the scope is left.
                ///
                /// TimeMonitor also has class methods that create or destroy timers
                /// and compute global timer statistics.  If you create a timer using
                /// getNewCounter() (or the deprecated getNewTimer()), it will add
                /// that timer to the set of timers for which to compute global
                /// statistics.  The summarize() and report() methods will print
                /// global statistics for these timers, like the minimum, mean, and
                /// maximum time over all processes in the communicator, for each
                /// timer.  These methods work correctly even if some processes have
                /// different timers than other processes.  You may also use
                /// computeGlobalTimerStatistics() to compute the same global
                /// statistics, if you wish to use them in your program or output them
                /// in a different format than that of these methods.
                ///
                /// \warning This class must only be used to time functions that are
                ///   called only within the main program.  It may <i>not</i> be used
                ///   in pre-program setup or post-program teardown!
                class TEUCHOSCOMM_LIB_DLL_EXPORT TimeMonitor :
                    public PerformanceMonitorBase<Time> {
                public:
                
                  /** \name Constructor/Destructor */
                  //@{
                
                  /// \brief Constructor: starts the timer.
                  ///
                  /// \param timer [in/out] Reference to the timer to be wrapped.
                  ///   This constructor starts the timer, and the destructor stops
                  ///   the timer.
                  ///
                  /// \param reset [in] If true, reset the timer before starting it.
                  ///   Default behavior is not to reset the timer.
                  TimeMonitor (Time& timer, bool reset=false);
                
                  //! Destructor: stops the timer.
                  ~TimeMonitor();
                  //@}
                
                  /// \brief Return a new timer with the given name (class method).
                  ///
                  /// Call getNewCounter() or this method if you want to create a new
                  /// named timer, and you would like TimeMonitor to track the timer
                  /// for later computation of global statistics over processes.
                  ///
                  /// This method wraps getNewCounter() (inherited from the base
                  /// class) for backwards compatibiity.
                  static RCP<Time> getNewTimer (const std::string& name) {
                    return getNewCounter (name);
                  }
                
                  /// \brief Disable the timer with the given name.
                  ///
                  /// "Disable" means that the timer (Time instance) will ignore all
                  /// calls to start(), stop(), and incrementNumCalls().  The effect
                  /// will be as if the TimeMonitor had never touched the timer.
                  ///
                  /// If the timer with the given name does not exist (was never
                  /// created using getNewCounter() or getNewTimer()), then this
                  /// method throws std::invalid_argument.  Otherwise, it disables the
                  /// timer.  This effect lasts until the timer is cleared or until
                  /// the timer is enabled, either by calling enableTimer() (see
                  /// below) or by calling the Time instance's enable() method.
                  ///
                  /// Disabling a timer does <i>not</i> exclude it from the list of
                  /// timers printed by summarize() or report().
                  static void disableTimer (const std::string& name);
                
                  /// \brief Enable the timer with the given name.
                  ///
                  /// If the timer with the given name does not exist (was never
                  /// created using getNewCounter() or getNewTimer()), then this
                  /// method throws std::invalid_argument.  Otherwise, it undoes the
                  /// effect of disableTimer() on the timer with the given name.  If
                  /// the timer with the given name was not disabled, then this method
                  /// does nothing.
                  static void enableTimer (const std::string& name);
                
                  /// \brief Reset all global timers to zero.
                  ///
                  /// This method only affects Time objects created by getNewCounter()
                  /// or getNewTimer().
                  ///
                  /// \pre None of the timers must currently be running.
                  static void zeroOutTimers();
                
                  /// \brief Compute global timer statistics for all timers on the given communicator.
                  ///
                  /// The typical use case for Time and TimeMonitor is that all
                  /// processes in a communicator create the same set of timers, and
                  /// then want to report summary statistics.  This method supports
                  /// that typical use case.  For each timer in the set, this method
                  /// computes a list of global statistics.  "Global" means "for all
                  /// processes in the communicator."  "Statistic" means the result of
                  /// a reduction over the timing and call count values.  Thus, each
                  /// statistic includes both a timing and a call count.  The current
                  /// list of computed statistics includes the minimum and maximum
                  /// timing (and the corresponding call count for each) and the
                  /// arithmetic mean (timing and call count).  This list may expand
                  /// in the future.
                  ///
                  /// Different processes may have different sets of timers.  This
                  /// method gives you two options for reconciling the sets.  If setOp
                  /// is Intersection, it computes the intersection (the common
                  /// subset) of timers on all processes in the communicator.
                  /// Otherwise, if setOp is Union, this method computes the union of
                  /// timers on all processes in the communicator.  Intersection is
                  /// the default, since it means that all reported timers exist on
                  /// all participating processes.  For setOp=Union, timers that do
                  /// not exist on some processes will be given a zero timing and call
                  /// count, so that statistics make sense.
                  ///
                  /// \note This method must called as a collective by all processes
                  ///   in the communicator.
                  ///
                  /// All output arguments are returned redundantly on all processes
                  /// in the communicator.  That makes this method an all-reduce.
                  ///
                  /// \section Teuchos_TimeMonitor_computeGlobalTimerStatistics_stats Statistics collected
                  ///
                  /// The "MinOverProcs" and "MaxOverProcs" timings are cumulative:
                  /// the reported timing is for all calls.  Along with the min resp.
                  /// max timing comes the call count of the process who had the min
                  /// resp. max.  (If more than one process had the min resp. max
                  /// timing, then the call count on the process with the smallest
                  /// rank is reported.)
                  ///
                  /// The "MeanOverProcs" equals the sum of the processes' cumulative
                  /// timings, divided by the number of processes.  Thus, it is
                  /// cumulative over all calls, and is comparable with the
                  /// "MinOverProcs" and "MaxOverProcs" timings.  This differs from
                  /// the "MeanOverCallCounts" (see below).  This does <i>not</i>
                  /// weight the mean by call counts.
                  ///
                  /// The "MeanOverCallCounts" is an arithmetic mean of all timings.
                  /// It is <i>not</i> cumulative.  It reports the mean timing for a
                  /// single invocation over all calls on all processes, not weighting
                  /// any one process more than the others.  For each timer, this is
                  /// the sum of the cumulative timing over all processes, divided by
                  /// the sum of the call counts over all processes for that timing.
                  /// (We compute it a bit differently to help prevent overflow.)  The
                  /// "MeanOverCallCounts" is <i>not</i> comparable with the min, max,
                  /// or "MeanOverProcs".
                  ///
                  /// We report with both versions of the mean timing the mean call
                  /// count over processes.  This may be fractional, which is one
                  /// reason why we report call counts as \c double rather than \c
                  /// int.  It has no particular connection to the mean timing.
                  ///
                  /// \section Teuchos_TimeMonitor_computeGlobalTimerStatistics_perf Performance
                  ///
                  /// This operation requires interprocess communication.  Suppose
                  /// there are \f$P\f$ processes in the given communicator, and
                  /// \f$N\f$ unique timers in the global union of all processes'
                  /// timers.  Then, this method requires \f$O(\log P)\f$ messages
                  /// (\f$O(1)\f$ "reductions" and exactly 1 "broadcast") and
                  /// \f$O(N)\f$ per-processor storage (in the worst case) when
                  /// computing either the intersection or the union of timers (the
                  /// algorithm is similar in either case).  The whole algorithm takes
                  /// at worst \f$O(N (\log N) (\log P))\f$ time along the critical
                  /// path (i.e., on the "slowest process" in the communicator).  The
                  /// \f$N \log N\f$ term comes from sorting the timers by label at
                  /// each stage of the reduction in order to compute their union or
                  /// intersection.
                  ///
                  /// \param statData [out] On output: Global timer statistics, stored
                  ///   as a map with key timer name, and with value the ordered list
                  ///   of statistics for that timer.  The \c statNames output has the
                  ///   same order as the ordered list of statistics for each timer.
                  ///   Each entry of the statistics list is a (timing, call count)
                  ///   pair, the meaning of which depends on the particular statistic
                  ///   (see above).
                  ///
                  /// \param statNames [out] On output: Each value in the statData map
                  ///   is a vector.  That vector v has the same number of entries as
                  ///   statNames.  statNames[k] is the name of the statistic (see
                  ///   above) stored as v[k].  Always refer to statNames for the
                  ///   number and names of statistics.
                  ///
                  /// \param comm [in] Communicator whose process(es) will participate
                  ///   in the gathering of timer statistics.  This is a Ptr and not
                  ///   an RCP, because RCP would suggest that TimeMonitor were
                  ///   keeping the communicator around after return of this method.
                  ///   Ptr suggests instead that TimeMonitor will only reference the
                  ///   communicator during this method.  If you have an RCP, you can
                  ///   turn it into a Ptr by calling its ptr() method:
                  ///   \code
                  ///   RCP<const Comm<int> > myComm = ...;
                  ///   TimeMonitor::computeGlobalTimerStatistics (statData, statNames, myComm.ptr());
                  ///   \endcode
                  ///
                  /// \param setOp [in] If \c Intersection, compute statistics for the
                  ///   intersection of all created timers over all processes in the
                  ///   communicator.  If \c Union, compute statistics for the union
                  ///   of all created timers over all processes in the communicator.
                  ///
                  /// \param filter [in] Filter for timer labels.  If filter is not
                  ///   empty, this method will only compute statistics for timers
                  ///   whose labels begin with this string.
                  static void
                  computeGlobalTimerStatistics (stat_map_type& statData,
                                                std::vector<std::string>& statNames,
                                                Ptr<const Comm<int> > comm,
                                                const ECounterSetOp setOp=Intersection,
                                                const std::string& filter="");
                
                  /// \brief Compute global timer statistics for all timers on all (MPI) processes.
                  ///
                  /// This is an overload of the above computeGlobalTimerStatistics()
                  /// method for when the caller does not want to provide a
                  /// communicator explicitly.  This method "does the right thing" in
                  /// that case.  Specifically:
                  /// - If Trilinos was not built with MPI support, this method
                  ///   assumes a serial "communicator" containing one process.
                  /// - If Trilinos was built with MPI support and MPI has been
                  ///   initialized (via MPI_Init() or one of the wrappers in
                  ///   Epetra or Teuchos), this method uses MPI_COMM_WORLD as the
                  ///   communicator.  This is the most common case.
                  /// - If Trilinos was built with MPI support and MPI has <i>not</i>
                  ///   been initialized, this method will use a "serial" communicator
                  ///   (that does not actually use MPI).  This may produce output on
                  ///   all the MPI processes if you are running with Trilinos as an
                  ///   MPI job with more than one process.  Thus, if you intend to
                  ///   use this method in parallel, you should first initialize MPI.
                  ///   (We cannot initialize MPI for you, because we have no way to
                  ///   know whether you intend to run an MPI-enabled build serially.)
                  ///
                  /// \warning If you call this method when MPI is running, you
                  ///   <i>must</i> call it on all processes in \c MPI_COMM_WORLD.
                  ///   Otherwise, the method will never finish, since it will be
                  ///   waiting forever for the non-participating processes.  If you
                  ///   want to use computeGlobalTimerStatistics() on a
                  ///   subcommunicator, please use the overloaded version above that
                  ///   takes a communicator as an input argument.
                  static void
                  computeGlobalTimerStatistics (stat_map_type& statData,
                                                std::vector<std::string>& statNames,
                                                const ECounterSetOp setOp=Intersection,
                                                const std::string& filter="");
                
                  /// \brief Print summary statistics for all timers on the given communicator.
                  ///
                  /// If writeGlobalStatus=true, this method computes the same
                  /// statistics as computeGlobalTimerStatistics(), using the same
                  /// collective algorithm.  (<tt>writeGlobalStatus=false</tt> means
                  /// that only the process with rank 0 in the communicator reports
                  /// its timers' data.)  It then reports the results to the given
                  /// output stream on the process with rank 0 in the given
                  /// communicator.  Output follows a human-readable tabular form.
                  ///
                  /// \param comm [in] Communicator whose process(es) will participate
                  ///   in the gathering of timer statistics.  This is a Ptr and not
                  ///   an RCP, because RCP would suggest that TimeMonitor were
                  ///   keeping the communicator around after return of this method.
                  ///   Ptr suggests instead that TimeMonitor will only reference the
                  ///   communicator during this method.  If you have an RCP, you can
                  ///   turn it into a Ptr by calling its ptr() method:
                  ///   \code
                  ///   RCP<const Comm<int> > myComm = ...;
                  ///   TimeMonitor::summarize (myComm.ptr());
                  ///   \endcode
                  ///
                  /// \param out [out] Output stream to which to write.  This will
                  ///   only be used on the process with rank 0 in the communicator.
                  ///
                  /// \param alwaysWriteLocal [in] If true, the process with Rank 0 in
                  ///   the communicator will write its local timings to the given
                  ///   output stream.  Defaults to false, since the global statistics
                  ///   are more meaningful.  If the local set of timers differs from
                  ///   the global set of timers (either the union or the
                  ///   intersection, depending on \c setOp), Proc 0 will create
                  ///   corresponding local timer data (<i>not</i> corresponding
                  ///   timers) with zero elapsed times and call counts, just to pad
                  ///   the table of output.
                  ///
                  /// \param writeGlobalStats [in] If true (the default), compute and
                  ///   display the statistics that \c computeGlobalTimerStatistics()
                  ///   computes.  If there is only one MPI process or if this is a
                  ///   non-MPI build of Trilinos, only compute and show the "global"
                  ///   timings, without the "statistics" that would be all the same
                  ///   anyway.
                  ///
                  /// \param writeZeroTimers [in] If false, do not display results for
                  ///   timers that have never been called (numCalls() == 0).  If
                  ///   true, display results for all timers, regardless of their call
                  ///   count.  Note that \c setOp and \c writeGlobalStats might
                  ///   reintroduce timers with zero call counts.
                  ///
                  /// \param setOp [in] If \c Intersection, compute and display the
                  ///   intersection of all created timers over all processes in the
                  ///   communicator.  If \c Union, compute and display the union of
                  ///   all created timers over all processes in the communicator.
                  ///
                  /// \param filter [in] Filter for timer labels.  If filter is not
                  ///   empty, this method will only print timers whose labels begin
                  ///   with this string.
                  ///
                  /// \param ignoreZeroTimers [in] Processes that either do not have
                  ///   a particular timer or have zero time for a timer are not used
                  ///   in calculating global statistics. This mode requires one
                  ///   additional all-reduce per invocation.
                  ///
                  /// \note If \c writeGlobalStats is true, this method <i>must</i> be
                  ///   called as a collective by all processes in the communicator.
                  ///   This method will <i>only</i> perform communication if
                  ///   <tt>writeGlobalStats</tt> is true.
                  static void
                  summarize (Ptr<const Comm<int> > comm,
                             std::ostream &out=std::cout,
                             const bool alwaysWriteLocal=false,
                             const bool writeGlobalStats=true,
                             const bool writeZeroTimers=true,
                             const ECounterSetOp setOp=Intersection,
                             const std::string& filter="",
                             const bool ignoreZeroTimers=false);
                
                  /// \brief Print summary statistics for all timers on all (MPI) processes.
                  ///
                  /// This is an overload of the above summarize() method for when the
                  /// caller does not want to provide a communicator explicitly.  This
                  /// method "does the right thing" in that case.  For an explanation
                  /// of what that means, see the documentation of the overload of
                  /// computeGlobalTimerStatistics() that does not require a
                  /// communicator argument.
                  ///
                  /// \warning If you call this method when MPI is running, you
                  ///   <i>must</i> call it on all processes in \c MPI_COMM_WORLD.
                  ///   Otherwise, the method will never finish, since it will be
                  ///   waiting forever for the non-participating processes.  If you
                  ///   want to use \c summarize() on a subcommunicator, please use
                  ///   the overloaded version above that takes a communicator as an
                  ///   input argument.
                  static void
                  summarize (std::ostream& out=std::cout,
                             const bool alwaysWriteLocal=false,
                             const bool writeGlobalStats=true,
                             const bool writeZeroTimers=true,
                             const ECounterSetOp setOp=Intersection,
                             const std::string& filter="",
                             const bool ignoreZeroTimers=false);
                
                  /// \brief Report timer statistics to the given output stream.
                  ///
                  /// This is like summarize(), but gives you more control over the
                  /// output format.  To get the default parameters, either call
                  /// getValidReportParameters(), or call this method with params
                  /// nonnull but empty (it will fill in default parameters).
                  ///
                  /// \param comm [in] Communicator whose process(es) will participate
                  ///   in the gathering of timer statistics.  This is a Ptr and not
                  ///   an RCP, because RCP would suggest that TimeMonitor were
                  ///   keeping the communicator around after return of this method.
                  ///   Ptr suggests instead that TimeMonitor will only reference the
                  ///   communicator during this method.  If you have an RCP, you can
                  ///   turn it into a Ptr by calling its ptr() method:
                  ///   \code
                  ///   RCP<const Comm<int> > myComm = ...;
                  ///   TimeMonitor::report (myComm.ptr (), ...);
                  ///   \endcode
                  ///
                  /// \param out [out] Output stream to which to write.  This will
                  ///   only be used on the process with rank 0 in the communicator.
                  ///
                  /// \param filter [in] Filter for timer labels.  If filter is not
                  ///   empty, this method will only print timers whose labels begin
                  ///   with this string.
                  ///
                  /// \param params [in/out] Parameters to control output format and
                  ///   which statistics to generate.  If null, we use default
                  ///   parameters if this method was not yet called with params
                  ///   nonnull, otherwise we use the previous set of parameters.  If
                  ///   nonnull, we read the given parameters, filling in defaults,
                  ///   and use the resulting parameters for all subsequent calls to
                  ///   report() (until new parameters are set).
                  ///
                  /// \section Teuchos_TimeMonitor_report_SupportedParams Supported parameters
                  ///
                  /// Here is the current set of supported parameters:
                  /// - "Report format": "Table" (default), "YAML"
                  /// - "YAML style": "spacious" (default), "compact"
                  /// - "How to merge timer sets": "Intersection" (default), "Union"
                  /// - "alwaysWriteLocal": true, false (default)
                  /// - "writeGlobalStats": true (default), false
                  /// - "writeZeroTimers": true (default), false
                  ///
                  /// This method currently supports two different output formats.
                  /// "Table" format is the same tabular format which summarize()
                  /// uses.  It displays times and call counts in a table that is easy
                  /// for humans to read, but hard to parse.  "YAML" format uses a
                  /// standard, structured, human-readable output format called YAML.
                  /// <a href="http://yaml.org">YAML</a> stands for YAML Ain't Markup
                  /// Language.
                  ///
                  /// "YAML style" refers to two variants of YAML output that report()
                  /// can generate.  The "compact" mode attempts to put as much data
                  /// on each line as possible.  It may be more readable when there
                  /// are a small number of timers.  The "spacious" mode prefers one
                  /// line per datum whenever possible.  Both modes have the same
                  /// schema, that is, their output has the same hierarchical
                  /// structure and thus the same parse tree.
                  ///
                  /// (In technical terms: compact mode uses YAML's so-called "flow
                  /// style" for sequences and mappings whenever possible, except at
                  /// the outermost level where it would hinder readability.  Spacious
                  /// mode does not use "flow style" for lists or mappings.  For an
                  /// explanation of YAML's flow style, see <a
                  /// href="http://www.yaml.org/spec/1.2/spec.html#style/flow/">Chapter
                  /// 7 of the YAML 1.2 spec</a>.)
                  ///
                  /// "How to merge timer sets" refers to the set operation by which
                  /// processors should combine their sets of timers in order to
                  /// compute global timer statistics.  This corresponds to the
                  /// <tt>setOp</tt> argument of summarize().
                  ///
                  /// The remaining Boolean parameters are the same as the eponymous
                  /// arguments of summarize(), to whose documentation one should
                  /// refer.  There are some wrinkles: in particular, YAML output
                  /// ignores the "alwaysWriteLocal" parameter and assumes
                  /// "writeGlobalStats" is true.
                  static void
                  report (Ptr<const Comm<int> > comm,
                          std::ostream& out,
                          const std::string& filter,
                          const RCP<ParameterList>& params=null);
                
                  /// \brief Report timer statistics to the given output stream.
                  ///
                  /// This is like the 4-argument version of report(), but with a
                  /// default filter.
                  static void
                  report (Ptr<const Comm<int> > comm,
                          std::ostream& out,
                          const RCP<ParameterList>& params=null);
                
                  /// \brief Report timer statistics to the given output stream.
                  ///
                  /// This is like the 4-argument version of report(), but with a
                  /// default communicator.
                  static void
                  report (std::ostream& out,
                          const std::string& filter,
                          const RCP<ParameterList>& params=null);
                
                  /// \brief Report timer statistics to the given output stream.
                  ///
                  /// This is like the 4-argument version of report(), but with a
                  /// default communicator and a default filter.
                  static void
                  report (std::ostream& out,
                          const RCP<ParameterList>& params=null);
                
                  //! Default parameters (with validators) for report().
                  static RCP<const ParameterList> getValidReportParameters ();
                
                 private:
                  /// \brief Valid output formats for report().
                  ///
                  /// \warning This is an implementation detail of TimeMonitor.  It is
                  ///   subject to change at any time without notice.
                  enum ETimeMonitorReportFormat {
                    REPORT_FORMAT_YAML,
                    REPORT_FORMAT_TABLE
                  };
                
                  /// \brief Valid YAML output formats for report().
                  ///
                  /// \warning This is an implementation detail of TimeMonitor.  It is
                  ///   subject to change at any time without notice.
                  enum ETimeMonitorYamlFormat {
                    YAML_FORMAT_COMPACT,
                    YAML_FORMAT_SPACIOUS
                  };
                
                  /// \brief Like summarize(), but with YAML-format output.
                  ///
                  /// \param comm [in] Communicator over which to compute timer
                  ///   statistics.
                  /// \param out [out] Output stream to which to write (on Proc 0 of
                  ///   the given communicator only).
                  /// \param yamlStyle [in] Whether to print YAML output in "compact"
                  ///   or "spacious" style.
                  /// \param filter [in] Filter for timer labels.  If filter is not
                  ///   empty, this method will only print timers whose labels begin
                  ///   with this string.
                  ///
                  /// \warning This is an experimental interface.  It may change or
                  ///   disappear without warning.
                  static void
                  summarizeToYaml (Ptr<const Comm<int> > comm,
                                   std::ostream& out,
                                   const ETimeMonitorYamlFormat yamlStyle,
                                   const std::string& filter="");
                
                  /// \brief Like summarize(), but with YAML-format output and default communicator.
                  ///
                  /// \warning This is an experimental interface.  It may change or
                  ///   disappear without warning.
                  static void
                  summarizeToYaml (std::ostream& out,
                                   const ETimeMonitorYamlFormat yamlStyle,
                                   const std::string& filter="");
                
                  /// \brief Add the "Report format" parameter to plist.
                  ///
                  /// \note Call this in getValidReportParameters() to set a default
                  ///   value and validator for this parameter.
                  static void setReportFormatParameter (ParameterList& plist);
                
                  /// \brief Add the "YAML style" parameter to plist.
                  ///
                  /// \note Call this in getValidReportParameters() to set a default
                  ///   value and validator for this parameter.
                  static void setYamlFormatParameter (ParameterList& plist);
                
                  /// \brief Add the "How to merge timer sets" parameter to plist.
                  ///
                  /// \note Call this in getValidReportParameters() to set a default
                  ///   value and validator for this parameter.
                  static void setSetOpParameter (ParameterList& plist);
                
                  /// \brief Set parameters for report().  Call only from report().
                  ///
                  /// If this method completes successfully, it sets setParams_ to
                  /// true as a flag.
                  ///
                  /// \param params [in/out] Parameters for report().  This may be
                  ///   null, in which case we use defaults or the last set of
                  ///   parameters.
                  ///
                  /// \warning This method is not thread safe, in the sense that it
                  ///   does not set the class data atomically.  Behavior when calling
                  ///   this method from multiple threads is undefined.  Calling this
                  ///   routine with different parameter lists from different threads
                  ///   will certainly not accomplish what you want to accomplish.
                  static void setReportParameters (const RCP<ParameterList>& params);
                
                  //! Parameters for the report() class method.
                  //@{
                
                  //! Current output format for report().  Set via setReportParameters().
                  static ETimeMonitorReportFormat reportFormat_;
                
                  /// Current output style for report(), when using YAML output.
                  /// Set via setReportParameters().
                  static ETimeMonitorYamlFormat yamlStyle_;
                
                  //! Whether report() should use the intersection or union of timers over processes.
                  static ECounterSetOp setOp_;
                
                  //! Whether report() should always report Proc 0's local timer results.
                  static bool alwaysWriteLocal_;
                
                  /// Whether report() should always compute global timer statistics.
                  /// This requires communication equivalent to O(1) all-reduces.
                  static bool writeGlobalStats_;
                
                  //! Whether report() should report timers with zero call counts.
                  static bool writeZeroTimers_;
                  //@}
                
                  /// \brief Whether setReportParameters() completed successfully.
                  ///
                  /// \note Keeping this helps us avoid keeping the whole
                  ///   ParameterList around.
                  static bool setParams_;
                };
                
                
                } // namespace Teuchos
                
                
                namespace Teuchos {
                
                /// \class TimeMonitorSurrogateImpl
                /// \brief Implementation of TimeMonitorSurrogate that invokes TimeMonitor.
                /// \warning Users should not use this class or rely on it in any way.
                ///   It is an implementation detail.
                ///
                /// Please refer to the documentation of
                /// TimeMonitorSurrogateImplInserter and TimeMonitorSurrogate for an
                /// explanation of the purpose of this class.
           1 -> class TimeMonitorSurrogateImpl : public CommandLineProcessor::TimeMonitorSurrogate
                {
       ##### ->   virtual void summarize (std::ostream& out) {
                    TimeMonitor::summarize (out);
                  }
                };
                
                /// \class TimeMonitorSurrogateImplInserter
                /// \brief Injects run-time dependency of a class on TimeMonitor.
                /// \warning Users should not use this class or rely on it in any way.
                ///   It is an implementation detail.
                ///
                /// \section Teuchos_TimeMonitorSurrogateImplInserter_Summary Summary
                ///
                /// Classes and functions with the name "TimeMonitorSurrogate" in them
                /// let CommandLineProcessor optionally call TimeMonitor::summarize(),
                /// without needing to know that the TimeMonitor class exists.  This
                /// allows Teuchos to put CommandLineProcessor in a separate package
                /// from TimeMonitor.  We want to do this because TimeMonitor depends
                /// on Comm, and is therefore in the TeuchosComm subpackage (which
                /// depends on TeuchosCore), but CommandLineProcessor is in a
                /// different subpackage which does not depend on Comm.
                ///
                /// The TimeMonitorSurrogateImplInserter class' constructor ensures
                /// that CommandLineProcessor gets informed about TimeMonitor even
                /// before the program starts executing main().  This happens
                /// automatically, without changes to main(), because we declare an
                /// instance of this class in the header file.  If the TeuchosComm
                /// subpackage was built and its libraries were linked in,
                /// CommandLineProcessor will know about TimeMonitor.
                ///
                /// \section Teuchos_TimeMonitorSurrogateImplInserter_Note Note to Teuchos developers
                ///
                /// This is an instance of the
                /// <a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a>
                /// design pattern.  CommandLineProcessor is not supposed to know
                /// about TimeMonitor, because CommandLineProcessor's subpackage does
                /// not depend on TimeMonitor's subpackage.  Thus,
                /// CommandLineProcessor interacts with TimeMonitor through the
                /// TimeMonitorSurrogate interface.  TimeMonitorSurrogateImplInserter
                /// "injects" the dependency at run time, if the TeuchosComm
                /// subpackage was enabled and the application linked with its
                /// libraries.
                ///
                /// Teuchos developers could imitate the pattern of this class in
                /// order to use TimeMonitor's class methods (such as summarize())
                /// from any other class that does not depend on the TeuchosComm
                /// subpackage.
                class TimeMonitorSurrogateImplInserter {
                public:
                  //! Constructor: inject dependency on TimeMonitor into CommandLineProcessor.
         202 ->   TimeMonitorSurrogateImplInserter () {
                    if (is_null (CommandLineProcessor::getTimeMonitorSurrogate ())) {
                      CommandLineProcessor::setTimeMonitorSurrogate (Teuchos::rcp (new TimeMonitorSurrogateImpl));
                    }
                  }
                };
                
                } // end namespace Teuchos
                
                
                namespace {
                
                // Inject the implementation in every translation unit.
                Teuchos::TimeMonitorSurrogateImplInserter timeMonitorSurrogateImplInserter;
                
                } // namespace (anonymous)
                
                #endif // TEUCHOS_TIMEMONITOR_H


Top 10 Lines:

     Line      Count

      783        202
      732          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      203   Total number of line executions
    67.67   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_HierarchyManager.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //        MueLu: A package for multigrid based preconditioning
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef MUELU_HIERARCHYMANAGER_DECL_HPP
                #define MUELU_HIERARCHYMANAGER_DECL_HPP
                
                #include <string>
                #include <map>
                
                #include <Teuchos_Array.hpp>
                
                #include <Xpetra_Operator.hpp>
                #include <Xpetra_IO.hpp>
                
                #include "MueLu_ConfigDefs.hpp"
                
                #include "MueLu_Exceptions.hpp"
                #include "MueLu_Hierarchy.hpp"
                #include "MueLu_HierarchyFactory.hpp"
                #include "MueLu_Level.hpp"
                #include "MueLu_MasterList.hpp"
                
                namespace MueLu {
                
                  // This class stores the configuration of a Hierarchy.
                  // The class also provides an algorithm to build a Hierarchy from the configuration.
                  //
                  // See also: FactoryManager
                  //
                  template <class Scalar = double, class LocalOrdinal = int, class GlobalOrdinal = LocalOrdinal, class Node = KokkosClassic::DefaultNode::DefaultNodeType>
                  class HierarchyManager : public HierarchyFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node> {
                #undef MUELU_HIERARCHYMANAGER_SHORT
                #include "MueLu_UseShortNames.hpp"
                    typedef std::pair<std::string, const FactoryBase*> keep_pair;
                
                  public:
                
                    //!
                    HierarchyManager(int numDesiredLevel = MasterList::getDefault<int>("max levels")) :
                        numDesiredLevel_        (numDesiredLevel),
                        maxCoarseSize_          (MasterList::getDefault<int>("coarse: max size")),
                        verbosity_              (Medium),
                        doPRrebalance_          (MasterList::getDefault<bool>("repartition: rebalance P and R")),
                        implicitTranspose_      (MasterList::getDefault<bool>("transpose: use implicit")),
                        graphOutputLevel_(-1) { }
                
                    //!
                    virtual ~HierarchyManager() { }
                
                    //!
                    void AddFactoryManager(int startLevel, int numDesiredLevel, RCP<FactoryManagerBase> manager) {
                      const int lastLevel = startLevel + numDesiredLevel - 1;
                      if (levelManagers_.size() < lastLevel + 1)
                        levelManagers_.resize(lastLevel + 1);
                
                      for (int iLevel = startLevel; iLevel <= lastLevel; iLevel++)
                        levelManagers_[iLevel] = manager;
                    }
                
                    //!
                    RCP<FactoryManagerBase> GetFactoryManager(int levelID) const {
                      // NOTE: last levelManager is used for all the remaining levels
                      return (levelID >= levelManagers_.size() ? levelManagers_[levelManagers_.size()-1] : levelManagers_[levelID]);
                    }
                
                    //! returns number of factory managers stored in levelManagers_ vector.
                    size_t getNumFactoryManagers() const {
                      return levelManagers_.size();
                    }
                
                    //!
                    void CheckConfig() {
                      for (int i = 0; i < levelManagers_.size(); i++)
                        TEUCHOS_TEST_FOR_EXCEPTION(levelManagers_[i] == Teuchos::null, Exceptions::RuntimeError, "MueLu:HierarchyConfig::CheckConfig(): Undefined configuration for level:");
                    }
                
                    //@{
                
       ##### ->     virtual RCP<Hierarchy> CreateHierarchy() const {
                      return rcp(new Hierarchy());
                    }
                
                    //! Setup Hierarchy object
           1 ->     virtual void SetupHierarchy(Hierarchy& H) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(!H.GetLevel(0)->IsAvailable("A"), Exceptions::RuntimeError, "No fine level operator");
                
                #ifdef HAVE_MUELU_DEBUG
                      // Reset factories' data used for debugging
                      for (int i = 0; i < levelManagers_.size(); i++)
                        levelManagers_[i]->ResetDebugData();
                
                #endif
                
                      // Setup Matrix
                      // TODO: I should certainly undo this somewhere...
                      RCP<Level>    l0 = H.GetLevel(0);
                      RCP<Operator> Op = l0->Get<RCP<Operator> >("A");
                
                      Xpetra::UnderlyingLib lib = Op->getDomainMap()->lib();
                      H.setlib(lib);
                
                      SetupOperator(*Op);
                      SetupExtra(H);
                
                      // Setup Hierarchy
                      H.SetMaxCoarseSize(maxCoarseSize_);
                      VerboseObject::SetDefaultVerbLevel(verbosity_);
                      if (graphOutputLevel_ >= 0)
                        H.EnableGraphDumping("dep_graph.dot", graphOutputLevel_);
                
                      H.SetPRrebalance(doPRrebalance_);
                      H.SetImplicitTranspose(implicitTranspose_);
                
                      H.Clear();
                
                      // There are few issues with using Keep in the interpreter:
                      //   1. Hierarchy::Keep interface takes a name and a factory. If
                      //      factories are different on different levels, the AddNewLevel() call
                      //      in Hierarchy does not work properly, as it assume that factories are
                      //      the same.
                      //   2. FactoryManager does not have a Keep option, only Hierarchy and
                      //      Level have it
                      //   3. Interpreter constructs factory managers, but not levels. So we
                      //      cannot set up Keep flags there.
                      //
                      // The solution implemented here does the following:
                      //   1. Construct hierarchy with dummy levels. This avoids
                      //      Hierarchy::AddNewLevel() calls which will propagate wrong
                      //      inheritance.
                      //   2. Interpreter constructs keep_ array with names and factories for
                      //      that level
                      //   3. For each level, we call Keep(name, factory) for each keep_
                      for (int i = 0; i < numDesiredLevel_; i++) {
                        std::map<int, std::vector<keep_pair> >::const_iterator it = keep_.find(i);
                        if (it != keep_.end()) {
                          RCP<Level> l = H.GetLevel(i);
                          const std::vector<keep_pair>& keeps = it->second;
                          for (size_t j = 0; j < keeps.size(); j++)
                            l->Keep(keeps[j].first, keeps[j].second);
                        }
                        if (i < numDesiredLevel_-1) {
                          RCP<Level> newLevel = rcp(new Level());
                          H.AddLevel(newLevel);
                        }
                      }
                
                      int  levelID     = 0;
                      int  lastLevelID = numDesiredLevel_ - 1;
                      bool isLastLevel = false;
                
                      while (!isLastLevel) {
                        bool r = H.Setup(levelID,
                                         LvlMngr(levelID-1, lastLevelID),
                                         LvlMngr(levelID,   lastLevelID),
                                         LvlMngr(levelID+1, lastLevelID));
                
                        isLastLevel = r || (levelID == lastLevelID);
                        levelID++;
                      }
                
                      RCP<Teuchos::FancyOStream> fos = this->getOStream();
                      fos->setOutputToRootOnly(0);
                      H.describe(*fos, verbosity_);
                
                      // When we reuse hierarchy, it is necessary that we don't
                      // change the number of levels. We also cannot make requests
                      // for coarser levels, because we don't construct all the
                      // data on previous levels. For instance, let's say our first
                      // run constructed three levels. If we try to do requests during
                      // next setup for the fourth level, it would need Aggregates
                      // which we didn't construct for level 3 because we reused P.
                      // To fix this situation, we change the number of desired levels
                      // here.
                      numDesiredLevel_ = levelID;
                
                      WriteData<Matrix>(H, matricesToPrint_,     "A");
                      WriteData<Matrix>(H, prolongatorsToPrint_, "P");
                      WriteData<Matrix>(H, restrictorsToPrint_,  "R");
                      WriteData<MultiVector>(H, nullspaceToPrint_,  "Nullspace");
                      WriteData<MultiVector>(H, coordinatesToPrint_,  "Coordinates");
                
                    } //SetupHierarchy
                
                    //@}
                
                    typedef std::map<std::string, RCP<const FactoryBase> > FactoryMap;
                
                  protected: //TODO: access function
                
                    //! Setup Matrix object
       ##### ->     virtual void SetupOperator(Operator& Op) const { }
                
                    //! Setup extra data
                    // TODO: merge with SetupMatrix ?
       ##### ->     virtual void SetupExtra(Hierarchy& H) const { }
                
                    // TODO this was private
                    // Used in SetupHierarchy() to access levelManagers_
                    // Inputs i=-1 and i=size() are allowed to simplify calls to hierarchy->Setup()
                    Teuchos::RCP<FactoryManagerBase> LvlMngr(int levelID, int lastLevelID) const {
                      // NOTE: the order of 'if' statements is important
                      if (levelID == -1)                    // levelID = -1 corresponds to the finest level
                        return Teuchos::null;
                
                      if (levelID == lastLevelID+1)         // levelID = 'lastLevelID+1' corresponds to the last level (i.e., no nextLevel)
                        return Teuchos::null;
                
                      if (levelManagers_.size() == 0) {     // default factory manager.
                        // The default manager is shared across levels, initialized only if needed and deleted with the HierarchyManager
                        static RCP<FactoryManagerBase> defaultMngr = rcp(new FactoryManager());
                        return defaultMngr;
                      }
                
                      return GetFactoryManager(levelID);
                    }
                
                    // Hierarchy parameters
                    mutable int           numDesiredLevel_;
                    Xpetra::global_size_t maxCoarseSize_;
                    MsgType               verbosity_;
                    bool                  doPRrebalance_;
                    bool                  implicitTranspose_;
                    int                   graphOutputLevel_;
                    Teuchos::Array<int>   matricesToPrint_;
                    Teuchos::Array<int>   prolongatorsToPrint_;
                    Teuchos::Array<int>   restrictorsToPrint_;
                    Teuchos::Array<int>   nullspaceToPrint_;
                    Teuchos::Array<int>   coordinatesToPrint_;
                
                    std::map<int, std::vector<keep_pair> > keep_;
                
                  private:
                
                    template<class T>
           5 ->     void WriteData(Hierarchy& H, const Teuchos::Array<int>& data, const std::string& name) const {
                      for (int i = 0; i < data.size(); ++i) {
                        std::string fileName = name + "_" + Teuchos::toString(data[i]) + ".m";
                
                        if (data[i] < H.GetNumLevels()) {
                          RCP<Level> L = H.GetLevel(data[i]);
                
                          if (L->IsAvailable(name)) {
                            RCP<T> M = L->template Get< RCP<T> >(name);
                            if (!M.is_null())
                              Xpetra::IO<Scalar, LocalOrdinal, GlobalOrdinal, Node>::Write(fileName,* M);
                          }
                        }
                      }
                    }
                
                    // Levels
                    Array<RCP<FactoryManagerBase> > levelManagers_;        // one FactoryManager per level (the last levelManager is used for all the remaining levels)
                
                  }; // class HierarchyManager
                
                } // namespace MueLu
                
                #define MUELU_HIERARCHYMANAGER_SHORT
                #endif // MUELU_HIERARCHYMANAGER_HPP
                
                //TODO: split into _decl/_def
                // TODO: default value for first param (FactoryManager()) should not be duplicated (code maintainability)


Top 10 Lines:

     Line      Count

      277          5
      126          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     1.20   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosStatusTestCombo.hpp:
                
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                //
                
                #ifndef BELOS_STATUS_TEST_COMBO_H
                #define BELOS_STATUS_TEST_COMBO_H
                
                /*!
                  \file BelosStatusTestCombo.hpp
                  \brief Belos::StatusTest for logically combining several status tests.
                */
                  
                #include "BelosStatusTest.hpp"
                #include <vector>
                
                /*! 
                  \class Belos::StatusTestCombo
                  \brief A class for extending the status testing capabilities of Belos via logical combinations.
                
                  StatusTestCombo is an interface that can be implemented to extend the convergence testing
                  capabilities of Belos.  This class supports composite tests.  In this situation,
                  two or more existing StatusTestCombo objects test1 and test2 can be used to create a new test.
                  For all combinations, if any tests returns Failed or returns not-a-number (NaN) status, then the combination test 
                  returns Failed.
                  There are three possible combinations:
                  <ol>
                  <li> OR combination:
                  If an OR combination is selected, the status returns Converged if any one of the subtest returns.
                  All of the tests are executed, whether or not any of them return Converged.
                  as Converged.  
                  <li> AND combination:
                  If an AND combination is selected, the status returns Converged only when all subtests return as Converged.
                  All of the tests are executed, whether or not any of them return Failed.
                  <li> SEQ combination:
                  SEQ is a form of AND that will perform subtests in sequence.  If the first test returns Passed, Failed or Undefined,
                  no other subtests are done, and the status is returned as Failed if the first test was Failed, or as
                  Failed if the first test was Failed or NaN.  If the first test returns Converged, the second test is checked in 
                  the same fashion as the first.  If the second test is Converged, the third one is tested, and so on.
                  
                  The purpose of the SEQ combination is to allow the addition of expensive but more rigorous convergence tests.  For
                  example, we could define a test that used the implicit residual std::vector (the one produced by the iterative method)
                  as the first subtest and define a second test using the explicitly computed residual std::vector.  Explicitly computing
                  the residual requires a matrix multiplication with the original matrix operator, an expensive operation.  By using
                  the SEQ combination, we can avoid the matrix multiplication associated with the explicit residual calculation
                  until the implicit residual is small.
                  </ol>
                */
                
                namespace Belos {
                
                template <class ScalarType, class MV, class OP>
                class StatusTestCombo: public StatusTest<ScalarType,MV,OP> {
                	
                 public:
                
                #ifndef DOXYGEN_SHOULD_SKIP_THIS
                
                  typedef std::vector< Teuchos::RCP<StatusTest<ScalarType,MV,OP> > > st_vector;
                  typedef typename st_vector::iterator iterator;
                  typedef typename st_vector::const_iterator const_iterator;
                
                #endif // DOXYGEN_SHOULD_SKIP_THIS
                  
                  //! @name Enums
                  //@{ 
                  /*! 
                    \brief The test can be either the AND of all the component tests,
                    or the OR of all the component tests, or a sequential AND (SEQ).
                  */
                  enum ComboType {AND,  /*!< Require all subtests to be satisfied. */
                		  OR,   /*!< Require one or the other subtests to be satisfied. */
                		  SEQ   /*!< Requires all subtests to be satisfied, but stops check after the first failed 
                			  or unconverged status. */
                  };
                  //@}
                
                  //! @name Constructors / Destructor
                  //@{ 
                
                  //! Constructor
                  StatusTestCombo(ComboType t);
                
                  //! Single test constructor.
                  StatusTestCombo(ComboType t, 
                		  const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test1);
                
                  //! Dual test constructor.
                  StatusTestCombo(ComboType t, 
                		  const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test1, 
                		  const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test2);
                
                  /// \brief Add another test to this combination.
                  ///
                  /// Only add the test if doing so would not in infinite recursion.
                  StatusTestCombo<ScalarType,MV,OP>& addStatusTest(const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& add_test);
                
                  //! Destructor
       ##### ->   virtual ~StatusTestCombo() {};
                  //@}
                
                  //! @name Status methods
                  //@{ 
                  
                  /// \brief Check convergence status of the iterative solver.
                  ///
                  /// Return one of the following values: Passed (the convergence
                  /// criteria are met), Failed (they are not met) or Undefined (we
                  /// can't tell).
                  StatusType checkStatus( Iteration<ScalarType,MV,OP>* iSolver );
                
                  /// \brief Return the result of the most recent checkStatus call.
                  ///
                  /// If checkStatus has not yet been called, return the default status.
       ##### ->   StatusType getStatus() const { return(status_); };
                
                  //@}
                
                  //! @name Reset methods
                  //@{ 
                
                  //! Resets all the status tests in this combination to their initial internal state.
                  /*! This should be done when the status test is being reused with another solver or linear problem.
                  */
                  void reset(); 
                
                  //@}
                
                  //! @name Accessor methods
                  //@{ 
                
                  //! Return the type of combination (OR, AND, or SEQ).
                  ComboType getComboType() const { return type_; }
                
                  //! Return the vector of status tests
                  st_vector getStatusTests() { return tests_; }
                
                  //@}
                
                  //! @name Print methods
                  //@{ 
                  
                  //! Output formatted description of stopping test to output stream
                  void print(std::ostream& os, int indent = 0) const;
                  
                  //@}
                
                protected:
                
                  //! @name Internal methods.
                  //@{ 
                  //! Use this for checkStatus when this is an OR type combo. Updates status.
                  void orOp( Iteration<ScalarType,MV,OP>* iSolver );
                
                  //! Use this for checkStatus when this is an AND type combo. Updates status.
                  void andOp( Iteration<ScalarType,MV,OP>* iSolver );
                
                  //! Use this for checkStatus when this is a sequential AND type combo. Updates status.
                  void seqOp( Iteration<ScalarType,MV,OP>* iSolver );
                
                  //! Check whether or not it is safe to add a to the list of
                  //! tests. This is necessary to avoid any infinite recursions.
                  bool isSafe( const Teuchos:: RCP<StatusTest<ScalarType,MV,OP> >& test1);
                  //@}
                
                 private:
                
                  //! @name Private data members.
                  //@{ 
                  //! The type of combination (OR, AND, or SEQ)
                  ComboType type_;
                
                  //! Vector of generic status tests
                  st_vector tests_;
                
                  /// \brief The current status
                  StatusType status_;
                  //@}
                
                };
                
                template <class ScalarType, class MV, class OP>
                StatusTestCombo<ScalarType,MV,OP>::StatusTestCombo(ComboType t)
                {
                  type_ = t;
                  status_ = Undefined;
                }
                
                template <class ScalarType, class MV, class OP>
                StatusTestCombo<ScalarType,MV,OP>::StatusTestCombo(ComboType t, 
                						   const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test1)
                {
                  type_ = t;
                  tests_.push_back(test1);
                  status_ = Undefined;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> StatusTestCombo<ScalarType,MV,OP>::StatusTestCombo(ComboType t, 
                						   const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test1, 
                						   const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test2)
                {
                  type_ = t;
                  tests_.push_back(test1);
                  addStatusTest(test2);
                  status_ = Undefined;
                }
                
                template <class ScalarType, class MV, class OP>
                StatusTestCombo<ScalarType,MV,OP>& StatusTestCombo<ScalarType,MV,OP>::addStatusTest(const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& add_test)
                {
                  if (isSafe(add_test))
                    tests_.push_back(add_test);
                  else
                    {
                      const int indent = 2;
                      std::cout << "\n*** WARNING! ***\n";
                      std::cout << "This combo test currently consists of the following:\n";
                      this->print(std::cout, indent);
                      std::cout << "Unable to add the following test:\n";
                      add_test->print(std::cout, indent);
                      std::cout << "\n";
                    }
                  return *this;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> bool StatusTestCombo<ScalarType,MV,OP>::isSafe( const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >& test1)
                {
                  // Are we trying to add "this" to "this"? This would result in an infinite recursion.
                  if (test1.get() == this)
                    return false;
                  
                  // Recursively test that we're not adding something that's already
                  // in the list because that can also lead to infinite recursions.
                  for (iterator i = tests_.begin(); i != tests_.end(); ++i) {
                    
                    StatusTestCombo<ScalarType,MV,OP>* ptr = dynamic_cast<StatusTestCombo<ScalarType,MV,OP> *>(i->get());
                    if (ptr != NULL)
                      if (!ptr->isSafe(test1))
                        return false;
                  }
                  return true;
                }
                
                template <class ScalarType, class MV, class OP>
           4 -> StatusType StatusTestCombo<ScalarType,MV,OP>::checkStatus( Iteration<ScalarType,MV,OP>* iSolver )
                {
                  status_ = Failed;
                
                  if (type_ == OR)
                    orOp( iSolver );
                  else if (type_ == AND)
                    andOp( iSolver );
                  else
                    seqOp( iSolver );
                
                  return status_;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> void StatusTestCombo<ScalarType,MV,OP>::reset( )
                {
                  // Resets all status tests in my list.
                  for (const_iterator i = tests_.begin(); i != tests_.end(); ++i) 
                    {
                      (*i)->reset();
                    }
                  // Reset my status.
                  status_ = Undefined;
                  //
                  return;
                }
                
                template <class ScalarType, class MV, class OP>
                void StatusTestCombo<ScalarType,MV,OP>::orOp( Iteration<ScalarType,MV,OP>* iSolver )
                {
                  status_ = Failed;
                
                  // Checks the status of each test. The first test it encounters, if
                  // any, that is unconverged is the status that it sets itself too.
                  for (const_iterator i = tests_.begin(); i != tests_.end(); ++i) 
                    {
                      StatusType s = (*i)->checkStatus( iSolver );
                
                      // Check for failure.
                      if (s==Passed) status_ = Passed;
                    }
                }
                
                template <class ScalarType, class MV, class OP>
                void StatusTestCombo<ScalarType,MV,OP>::andOp( Iteration<ScalarType,MV,OP>* iSolver )
                {
                  bool isFailed = false;
                  
                  for (const_iterator i = tests_.begin(); i != tests_.end(); ++i) {
                    
                    StatusType s = (*i)->checkStatus( iSolver );
                
                    // Check for failure.
                    if (s==Failed) isFailed = true;
                
                    // If any of the tests are failed, then the AND test is failed.
                    if (s == Failed) {
                      status_ = Failed;
                    }
                
                    // If this is the first test and it's failed, copy its
                    // status to the combo status.
                    if ((!isFailed) && (status_ == Failed)) {
                      status_ = s;
                    }
                  }
                  
                  // Any failure is a complete failure
                  if (isFailed) status_ = Failed;
                  
                  return;
                }
                
                template <class ScalarType, class MV, class OP>
                void StatusTestCombo<ScalarType,MV,OP>::seqOp( Iteration<ScalarType,MV,OP>* iSolver ) 
                {
                  for (const_iterator i = tests_.begin(); i != tests_.end(); ++i) {
                
                    StatusType s = (*i)->checkStatus( iSolver );
                
                    // Check for failure.
                    if (s==Failed) {
                      status_ = Failed;
                      return;
                    }
                    else if (s==Undefined) {
                      status_ = s;
                      return;
                    }
                  }
                  // If we make it here, we have converged
                  status_ = Passed;
                
                  return;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> void StatusTestCombo<ScalarType,MV,OP>::print(std::ostream& os, int indent) const {
                  for (int j = 0; j < indent; j ++)
                    os << ' ';
                  this->printStatus(os, status_);
                  os << ((type_ == OR) ? "OR" : (type_ == AND) ? "AND" :"SEQ");
                  os << " Combination";
                  os << " -> " << std::endl;
                
                  for (const_iterator i = tests_.begin(); i != tests_.end(); ++i)
                    (*i)->print(os, indent+2);
                }
                
                } // end namespace Belos
                
                #endif /* BELOS_STATUS_TEST_COMBO_H */


Top 10 Lines:

     Line      Count

      285          4
      237          1
      266          1
      300          1
      383          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     1.14   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_PerformanceMonitorBase.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_PERFORMANCEMONITORBASE_H
                #define TEUCHOS_PERFORMANCEMONITORBASE_H
                
                /*! \file Teuchos_PerformanceMonitorBase.hpp
                  \brief Provides common capabilities for collecting and reporting
                  performance data across processors
                */
                
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_Array.hpp"
                #include "Teuchos_Comm.hpp"
                #include "Teuchos_RCP.hpp"
                #include "Teuchos_TableFormat.hpp"
                #include <cstdlib> // atexit
                
                namespace Teuchos
                {
                  /// \brief Set operation type for \c mergeCounterNames() to perform.
                  ///
                  /// The \c mergeCounterNames() function merges sets of counter names
                  /// over all MPI processes in a communicator.  Different MPI
                  /// processes may have created different sets of counters.  This
                  /// enum allows the caller to specify how mergeCounterNames() picks
                  /// the global set of timers.
                  enum ECounterSetOp { Intersection, Union };
                
                  /// \brief Merge counter names over all processors.
                  ///
                  /// Different MPI processes may have created different sets of
                  /// counters.  Use this function to reconcile the sets among
                  /// processes, either by computing their intersection or their
                  /// union.  This is done using a reduction to MPI Rank 0 (relative
                  /// to the given communicator) and a broadcast to all processes
                  /// participating in the communicator.  We use a
                  /// reduce-and-broadcast rather than just a reduction, so that all
                  /// participating processes can use the resulting list of global
                  /// names as lookup keys for computing global statistics.
                  ///
                  /// \param comm [in] Communicator over which to merge.
                  ///
                  /// \param localNames [in] The calling MPI process' list of (local)
                  ///   counter names.
                  ///
                  /// \param globalNames [out] On output, on each MPI process: the
                  ///   results of merging the counter names.
                  ///
                  /// \param setOp [in] If Intersection, globalNames on output
                  ///   contains the intersection of all sets of counter names.  If
                  ///   Union, globalNames on output contains the union of all sets of
                  ///   counter names.
                  void
                  mergeCounterNames (const Comm<int>& comm,
                                     const Array<std::string>& localNames,
                                     Array<std::string>& globalNames,
                                     const ECounterSetOp setOp);
                
                  /// \class PerformanceMonitorBase
                  ///
                  /// \brief Common capabilities for collecting and reporting
                  ///   performance data across processors.
                  ///
                  /// PerformanceMonitorBase is templated on a counter type T (which
                  /// might be a timer or a flop counter). The common capability of the
                  /// counter type is a counter for the number of calls.  Derived counter
                  /// types may supply additional features.
                  ///
                  /// PerformanceMonitorBase's constructor increments its counter's
                  /// call count.  Subclasses of PerformanceMonitorBase may do more
                  /// upon construction or destruction; for example, TimeMonitor
                  /// starts its timer on construction and stops it on destruction.
                  ///
                  /// This class keeps a static list of all counters created using the
                  /// getNewCounter() method during the course of a run. Counts from
                  /// this list can then be printed out at the end of the run.
                  /// Subclasses of PerformanceMonitorBase, such as TimeMonitor, may
                  /// use this list to do things like compute global timer statistics
                  /// over all the MPI processes.
                  ///
                  /// PerformanceMonitorBase requires that the counter type T provide at
                  /// least the following interface:
                  ///
                  /// \code
                  /// // Constructor taking an std::string argument (the counter name).
                  /// T (const std::string&);
                  ///
                  /// // Return the name of the counter.
                  /// const std::string& name () const;
                  ///
                  /// // Add one to the number of calls (the number of times the counter
                  /// // was started).
                  /// void incrementNumCalls ();
                  ///
                  /// // Return the number of calls (see incrementNumCalls () above).
                  /// int numCalls () const;
                  ///
                  /// // Indicate whether the counter is already running.
                  /// bool isRunning () const;
                  /// \endcode
                  ///
                  template <class T>
                  class PerformanceMonitorBase
                  {
                  public:
                    /** \brief Construct with a counter. */
                    PerformanceMonitorBase(T& counter_in, bool reset=false)
                      : counter_(counter_in), isRecursiveCall_(counter_.isRunning())
                    {
                      (void) reset;  // get rid of "unused parameter" warning
                      counter_.incrementNumCalls ();
                    }
                
                    /// \brief Destructor.
                    ///
                    /// The destructor for the base class does nothing.  We provide a
                    /// virtual destructor for memory safety of derived classes.
                    virtual ~PerformanceMonitorBase() {}
                
                    /** \brief Create a new counter with the specified name and add it
                     *   to a global set of counters of this type.
                     *
                     * If the counter already exists, just return the existing
                     * counter.  If the counter doesn't already exist, create a new
                     * counter with that name and return it.
                     *
                     * New counters should usually be created in this way rather than
                     * through a direct constructor call.  This lets
                     * PerformanceMonitorBase keep track of them, so that methods like
                     * summarize() and report() know about them.  Timers created in
                     * other ways are not included in the reports printed by these
                     * methods.
                     */
                    static RCP<T> getNewCounter (const std::string& name);
                
                  private:
                    /// \brief Free the singleton returned by format().
                    ///
                    /// \warning Only for use as atexit() handler.
                    ///
                    /// \warning This method is not reentrant.  In particular, if
                    ///   multiple threads call this method at the same time, they
                    ///   might manage to double-delete format_.  This could only
                    ///   happen if the format() method below is called twice by
                    ///   different threads.
                    static void freeTableFormat () {
                      if (format_ != NULL) {
                        delete format_;
                        format_ = NULL;
                      }
                    }
                
                    /// \brief Free the singleton returned by counters().
                    ///
                    /// \warning Only for use as atexit() handler.
                    ///
                    /// \warning This method is not reentrant.  In particular, if
                    ///   multiple threads call this method at the same time, they
                    ///   might manage to double-delete counters_.  This could only
                    ///   happen if the counters() method below is called twice by
                    ///   different threads.
       ##### ->     static void freeCounters () {
                      if (counters_ != NULL) {
                        delete counters_;
                        counters_ = NULL;
                      }
                    }
                
                  public:
                    /// \brief Table format that will be used to print a summary of
                    ///   timer results.
                    ///
                    /// \warning This method is not reentrant.  In particular, if
                    ///   multiple threads call this method at the same time, they
                    ///   might manage to double-register the atexit() handler for
                    ///   format_.  This could only happen if this method is called
                    ///   twice by different threads.
                    static TableFormat& format ()
                    {
                      if (format_ == NULL) {
                        format_ = new TableFormat ();
                        // It _is_ possible for atexit() to fail (e.g., because it ran
                        // out of memory for storing callbacks).  We could throw an
                        // exception here in that case, but I think it's better just
                        // to let the minor memory leak happen.
                        (void) atexit (freeTableFormat);
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        format_ == NULL, std::logic_error, "Teuchos::PerformanceMonitorBase::"
                        "format: Should never get here!  format_ is NULL.");
                
                      return *format_;
                    }
                
                    /// \brief Return the first counter with the given name, or null if none.
                    ///
                    /// It is currently possible to create multiple counters with the
                    /// same name using \c getNewCounter().  If multiple counters with
                    /// the given name exist, this method simply returns the first in
                    /// the list.  Do not rely on the ability to create multiple
                    /// counters with the same name; this may go away in the future.
                    static RCP<T>
                    lookupCounter (const std::string& name);
                
                    /// \brief "Forget" about all counters created with getNewCounter().
                    ///
                    /// This removes all counters from the current set of counters (as
                    /// would be returned by counters()).
                    static void clearCounters ();
                
                    /// \brief "Forget" about all counters created with getNewCounter().
                    ///
                    /// This removes all counters from the current list of counters
                    /// (as would be returned by counters()).
                    ///
                    /// \warning This method is DEPRECATED, because the name is
                    ///   inaccurate (the template parameter of PerformanceMonitorBase
                    ///   may be any kind of performance counter, not just a timer).
                    ///   Use clearCounters() instead.
                    static TEUCHOS_DEPRECATED void clearTimers ();
                
                    /// \brief "Forget" about any counters with the given name.
                    ///
                    /// If one or more counters with the given name was created using
                    /// getNewCounter(), calling this method with that name will
                    /// remove them from the global list of counters.
                    static void clearCounter (const std::string& name);
                
                    /// \brief "Forget" about any counters with the given name.
                    ///
                    /// If one or more counters with the given name was created using
                    /// getNewCounter(), calling this method with that name will
                    /// remove them from the global list of counters.
                    ///
                    /// \warning This method is DEPRECATED, because the name is
                    ///   inaccurate (the template parameter of PerformanceMonitorBase
                    ///   may be any kind of performance counter, not just a timer).
                    ///   Use clearCounter() instead.
                    static TEUCHOS_DEPRECATED void clearTimer (const std::string& name);
                
                  protected:
                
                    //! Constant access to the instance's counter reference.
                    const T& counter() const { return counter_; }
                
                    //! Nonconstant access to the instance's counter reference.
                    T& counter() { return counter_; }
                
                    /// \brief Whether we are currently in a recursive call of the counter.
                    ///
                    /// Subclasses of PerformanceMonitorBase may use this information
                    /// to control whether to start or stop the given counter.  This
                    /// matters in cases such as timing, where we don't want to start
                    /// and stop timers multiple times within a single call stack.
                    bool isRecursiveCall() const { return isRecursiveCall_; }
                
                    /// \brief Array of all counters that were created with
                    ///   getNewCounter() on the calling (MPI) process.
                    ///
                    /// \warning This method is not reentrant.
           2 ->     static std::map<std::string, RCP<T> >& counters ()
                    {
                      if (counters_ == NULL) {
                        counters_ = new std::map<std::string, RCP<T> > ();
                        // It _is_ possible for atexit() to fail (e.g., because it ran
                        // out of memory for storing callbacks).  We could throw an
                        // exception here in that case, but I think it's better just
                        // to let the minor memory leak happen.
                        (void) atexit (freeCounters);
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        counters_ == NULL, std::logic_error, "Teuchos::PerformanceMonitorBase::"
                        "counters: Should never get here!  counters_ is NULL.");
                
                      return *counters_;
                    }
                
                  private:
                    //! Singleton object returned by format().
                    static TableFormat* format_;
                
                    //! Singleton object returned by counters().
                    static std::map<std::string, RCP<T> >* counters_;
                
                    //! Reference to the counter being wrapped.
                    T& counter_;
                
                    //! Whether we are currently in a recursive call of the counter.
                    bool isRecursiveCall_;
                  };
                
                  template<class T>
                  TableFormat*
                  PerformanceMonitorBase<T>::format_ = NULL;
                
                  template<class T>
                  std::map<std::string, RCP<T> >*
                  PerformanceMonitorBase<T>::counters_ = NULL;
                
                  template<class T>
                  RCP<T>
          10 ->   PerformanceMonitorBase<T>::getNewCounter (const std::string& name)
                  {
                    typedef std::map<std::string, RCP<T> > map_type;
                    typedef typename map_type::iterator iter_type;
                
                    map_type& ctrs = counters ();
                    iter_type it = ctrs.find (name);
                    RCP<T> newCounter = null;
                    if (it == ctrs.end ()) {
                      newCounter = rcp (new T (name));
                #ifdef HAVE_TEUCHOS_DEBUG
                      const bool wasNotThere = ctrs.insert (std::make_pair (name, newCounter)).second;
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        ! wasNotThere, std::logic_error,
                        "getNewCounter: insert() claims that timer \"" << name << "\" was "
                        "already there in the map, even though find() claims that it was not.  "
                        "Please report this bug to the Teuchos developers.");
                #else
                      // Use the returned iterator to optimize insertion.
                      ctrs.insert (it, std::make_pair (name, newCounter));
                #endif // HAVE_TEUCHOS_DEBUG
                    } else {
                      newCounter = it->second;
                #ifdef HAVE_TEUCHOS_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        it->second.is_null (), std::logic_error,
                        "getNewCounter: Timer \"" << name << "\" was already there in the map, "
                        "but looking it up by name resulted in a null timer.  "
                        "Please report this bug to the Teuchos developers.");
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        name != it->second->name (), std::logic_error,
                        "getNewCounter: Timer \"" << name << "\" was already there in the map, "
                        "but looking it up by name resulted in a timer with a different name \""
                        << it->second->name () << "\".  Please report this bug to the Teuchos "
                        "developers.");
                #endif // HAVE_TEUCHOS_DEBUG
                    }
                
                #ifdef HAVE_TEUCHOS_DEBUG
                    TEUCHOS_TEST_FOR_EXCEPTION(
                      newCounter.is_null (), std::logic_error,
                      "getNewCounter: At end of method, when creating timer \"" << name
                      << "\", newCounter is null.  Please report this bug to the Teuchos "
                      "developers.");
                #endif // HAVE_TEUCHOS_DEBUG
                    return newCounter;
                  }
                
                  template<class T>
                  RCP<T>
                  PerformanceMonitorBase<T>::lookupCounter (const std::string& name)
                  {
                    typedef std::map<std::string, RCP<T> > map_type;
                    typedef typename map_type::iterator iter_type;
                
                    map_type& ctrs = counters ();
                    iter_type it = ctrs.find (name);
                    if (it == ctrs.end ()) {
                      return null;
                    } else {
                      return it->second;
                    }
                  }
                
                  template<class T>
                  void
                  PerformanceMonitorBase<T>::clearCounter (const std::string& name)
                  {
                    counters ().erase (name);
                  }
                
                  template<class T>
                  void
                  PerformanceMonitorBase<T>::clearTimer (const std::string& name)
                  {
                    clearCounter (name);
                  }
                
                  template<class T>
                  void
                  PerformanceMonitorBase<T>::clearTimers ()
                  {
                    clearCounters ();
                  }
                
                  template<class T>
                  void
                  PerformanceMonitorBase<T>::clearCounters ()
                  {
                    counters ().clear ();
                  }
                
                } // namespace Teuchos
                
                #endif // TEUCHOS_PERFORMANCEMONITORBASE_H


Top 10 Lines:

     Line      Count

      341         10
      300          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_Matrix.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                
                // WARNING: This code is experimental. Backwards compatibility should not be expected.
                
                #ifndef XPETRA_MATRIX_HPP
                #define XPETRA_MATRIX_HPP
                
                #include <Kokkos_DefaultNode.hpp>
                
                #include "Xpetra_ConfigDefs.hpp"
                #include "Xpetra_Exceptions.hpp"
                
                #include "Xpetra_MultiVector.hpp"
                #include "Xpetra_CrsGraph.hpp"
                #include "Xpetra_CrsMatrix.hpp"
                #include "Xpetra_CrsMatrixFactory.hpp"
                #include "Xpetra_MatrixView.hpp"
                #include "Xpetra_Operator.hpp"
                #include "Xpetra_StridedMap.hpp"
                #include "Xpetra_StridedMapFactory.hpp"
                
                #include <Teuchos_SerialDenseMatrix.hpp>
                #include <Teuchos_Hashtable.hpp>
                
                /** \file Xpetra_Matrix.hpp
                
                Declarations for the class Xpetra::Matrix.
                */
                namespace Xpetra {
                
                    /*!
                     @class Xpetra::Matrix class.
                     @brief Xpetra-specific matrix class.
                
                     This class is specific to Xpetra and has no analogue in Epetra or Tpetra.  The main motivation for this class is to be able to access matrix data in a manner different than how it is stored.
                     For example, it might be more convenient to treat ("view") a matrix stored in compressed row storage as if it were a block matrix.  The Xpetra::Matrix class is intended to manage these "views".
                
                     <B>How to create a Matrix from an existing CrsMatrix</B>
                
                     @code
                     RCP<Xpetra::CrsMatrix> crsA;
                     RCP<Xpetra::Matrix>    A  = rcp(new CrsMatrixWrap(crsA));
                     @endcode
                
                    */
                
                  typedef std::string viewLabel_t;
                
                  template <class Scalar        = Operator<>::scalar_type,
                            class LocalOrdinal  = Operator<>::local_ordinal_type,
                            class GlobalOrdinal = typename Operator<LocalOrdinal>::global_ordinal_type,
                            class Node          = typename Operator<LocalOrdinal, GlobalOrdinal>::node_type>
                  class Matrix : public Xpetra::Operator< Scalar, LocalOrdinal, GlobalOrdinal, Node > {
                    typedef Xpetra::Map<LocalOrdinal, GlobalOrdinal, Node> Map;
                    typedef Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> CrsMatrix;
                    typedef Xpetra::CrsGraph<LocalOrdinal, GlobalOrdinal, Node> CrsGraph;
                    typedef Xpetra::CrsMatrixFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node> CrsMatrixFactory;
                    typedef Xpetra::MatrixView<Scalar, LocalOrdinal, GlobalOrdinal, Node> MatrixView;
                
                  public:
                    typedef Scalar          scalar_type;
                    typedef LocalOrdinal    local_ordinal_type;
                    typedef GlobalOrdinal   global_ordinal_type;
                    typedef Node            node_type;
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename CrsMatrix::local_matrix_type local_matrix_type;
                #endif
                
                    //! @name Constructor/Destructor Methods
                    //@{
                
                    Matrix() { }
                
                    //! Destructor
       ##### ->     virtual ~Matrix() { }
                
                    //@}
                
                    //! @name View management methods
                    //@{
           2 ->     void CreateView(viewLabel_t viewLabel, const RCP<const Map> & rowMap, const RCP<const Map> & colMap) {
                      TEUCHOS_TEST_FOR_EXCEPTION(operatorViewTable_.containsKey(viewLabel) == true, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.CreateView(): a view labeled '" + viewLabel + "' already exist.");
                      RCP<MatrixView> view = rcp(new MatrixView(rowMap, colMap));
                      operatorViewTable_.put(viewLabel, view);
                    }
                
                    // JG TODO: why this is a member function??
                    void CreateView(const viewLabel_t viewLabel, const RCP<const Matrix>& A, bool transposeA = false, const RCP<const Matrix>& B = Teuchos::null, bool transposeB = false) {
                      RCP<const Map> domainMap = Teuchos::null;
                      RCP<const Map> rangeMap  = Teuchos::null;
                
                      const size_t        blkSize = 1;
                      std::vector<size_t> stridingInfo(1, blkSize);
                      LocalOrdinal        stridedBlockId = -1;
                
                
                      if (A->IsView(viewLabel)) {
                        rangeMap  = transposeA ? A->getColMap(viewLabel) : A->getRowMap(viewLabel);
                        domainMap = transposeA ? A->getRowMap(viewLabel) : A->getColMap(viewLabel); // will be overwritten if B != Teuchos::null
                
                      } else {
                        rangeMap  = transposeA ? A->getDomainMap()       : A->getRangeMap();
                        domainMap = transposeA ? A->getRangeMap()        : A->getDomainMap();
                
                        if (viewLabel == "stridedMaps") {
                          rangeMap  = Xpetra::StridedMapFactory<LocalOrdinal, GlobalOrdinal, Node>::Build(rangeMap,  stridingInfo, stridedBlockId);
                          domainMap = Xpetra::StridedMapFactory<LocalOrdinal, GlobalOrdinal, Node>::Build(domainMap, stridingInfo, stridedBlockId);
                        }
                      }
                
                      if (B != Teuchos::null ) {
                        // B has strided Maps
                
                        if (B->IsView(viewLabel)) {
                          domainMap = transposeB ? B->getRowMap(viewLabel) : B->getColMap(viewLabel);
                
                        } else {
                          domainMap = transposeB ? B->getRangeMap()        : B->getDomainMap();
                
                          if (viewLabel == "stridedMaps")
                            domainMap = Xpetra::StridedMapFactory<LocalOrdinal, GlobalOrdinal, Node>::Build(domainMap, stridingInfo, stridedBlockId);
                        }
                      }
                
                
                      if (IsView(viewLabel))
                        RemoveView(viewLabel);
                
                      CreateView(viewLabel, rangeMap, domainMap);
                    }
                
                    //! Print all of the views associated with the Matrix.
                    void PrintViews(Teuchos::FancyOStream &out) const {
                      int last = out.getOutputToRootOnly();
                      Teuchos::OSTab tab(out);
                      out.setOutputToRootOnly(0);
                      Teuchos::Array<viewLabel_t> viewLabels;
                      Teuchos::Array<RCP<MatrixView> > viewList;
                      operatorViewTable_.arrayify(viewLabels,viewList);
                      out << "views associated with this operator" << std::endl;
                      for (int i=0; i<viewLabels.size(); ++i)
                        out << viewLabels[i] << std::endl;
                      out.setOutputToRootOnly(last);
                    }
                
                
                    void RemoveView(const viewLabel_t viewLabel) {
                      TEUCHOS_TEST_FOR_EXCEPTION(operatorViewTable_.containsKey(viewLabel) == false, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.RemoveView(): view '" + viewLabel + "' does not exist.");
                      TEUCHOS_TEST_FOR_EXCEPTION(viewLabel == GetDefaultViewLabel(), Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.RemoveView(): view '" + viewLabel + "' is the default view and cannot be removed.");
                      operatorViewTable_.remove(viewLabel);
                    }
                
                    const viewLabel_t SwitchToView(const viewLabel_t viewLabel) {
                      TEUCHOS_TEST_FOR_EXCEPTION(operatorViewTable_.containsKey(viewLabel) == false, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.SwitchToView(): view '" + viewLabel + "' does not exist.");
                      viewLabel_t oldViewLabel = GetCurrentViewLabel();
                      currentViewLabel_ = viewLabel;
                      return oldViewLabel;
                    }
                
                    bool IsView(const viewLabel_t viewLabel) const {
                      return operatorViewTable_.containsKey(viewLabel);
                    }
                
                    const viewLabel_t SwitchToDefaultView() { return SwitchToView(GetDefaultViewLabel()); }
                
                    const viewLabel_t & GetDefaultViewLabel() const { return defaultViewLabel_; }
                
                    const viewLabel_t & GetCurrentViewLabel() const { return currentViewLabel_; }
                
                    //@}
                
                    //! @name Insertion/Removal Methods
                    //@{
                
                    //! Insert matrix entries, using global IDs.
                    /** All index values must be in the global space.
                        \pre \c globalRow exists as an ID in the global row map
                        \pre <tt>isLocallyIndexed() == false</tt>
                        \pre <tt>isStorageOptimized() == false</tt>
                
                        \post <tt>isGloballyIndexed() == true</tt>
                
                        \note If \c globalRow does not belong to the matrix on this node, then it will be communicated to the appropriate node when globalAssemble() is called (which will, at the latest, occur during the next call to fillComplete().) Otherwise, the entries will be inserted in the local matrix.
                        \note If the matrix row already contains values at the indices corresponding to values in \c cols, then the new values will be summed with the old values; this may happen at insertion or during the next call to fillComplete().
                        \note If <tt>hasColMap() == true</tt>, only (cols[i],vals[i]) where cols[i] belongs to the column map on this node will be inserted into the matrix.
                    */
                    virtual void insertGlobalValues(GlobalOrdinal globalRow, const ArrayView<const GlobalOrdinal> &cols, const ArrayView<const Scalar> &vals) = 0;
                
                    //! Insert matrix entries, using local IDs.
                    /** All index values must be in the local space.
                        \pre \c localRow exists as an ID in the local row map
                        \pre <tt>isGloballyIndexed() == false</tt>
                        \pre <tt>isStorageOptimized() == false</tt>
                
                        \post <tt>isLocallyIndexed() == true</tt>
                    */
                    virtual void insertLocalValues(LocalOrdinal localRow, const ArrayView<const LocalOrdinal> &cols, const ArrayView<const Scalar> &vals) = 0;
                
                    //! \brief Replace matrix entries, using global IDs.
                    /** All index values must be in the global space.
                
                        \pre \c globalRow is a global row belonging to the matrix on this node.
                
                        \note If (globalRow,cols[i]) corresponds to an entry that is duplicated in this matrix row (likely because it was inserted more than once and fillComplete() has not been called in the interim), the behavior of this function is not defined. */
                    virtual void replaceGlobalValues(GlobalOrdinal globalRow,
                                                     const ArrayView<const GlobalOrdinal> &cols,
                                                     const ArrayView<const Scalar>        &vals) = 0;
                
                    //! Replace matrix entries, using local IDs.
                    /** All index values must be in the local space.
                        Note that if a value is not already present for the specified location in the matrix, the input value will be ignored silently.
                     */
                    virtual void replaceLocalValues(LocalOrdinal localRow,
                                                    const ArrayView<const LocalOrdinal> &cols,
                                                    const ArrayView<const Scalar>       &vals) = 0;
                
                    //! Set all matrix entries equal to scalar
                    virtual void setAllToScalar(const Scalar &alpha)= 0;
                
                    //! Scale the current values of a matrix, this = alpha*this.
                    virtual void scale(const Scalar &alpha)= 0;
                
                    //@}
                
                    //! @name Transformational Methods
                    //@{
                
                    /*! Resume fill operations.
                      After calling fillComplete(), resumeFill() must be called before initiating any changes to the matrix.
                
                      resumeFill() may be called repeatedly.
                
                      \post  <tt>isFillActive() == true<tt>
                      \post  <tt>isFillComplete() == false<tt>
                    */
                    virtual void resumeFill(const RCP< ParameterList > &params=null) = 0;
                
                    /*! \brief Signal that data entry is complete, specifying domain and range maps.
                
                    Off-node indices are distributed (via globalAssemble()), indices are sorted, redundant indices are eliminated, and global indices are transformed to local indices.
                
                    \pre  <tt>isFillActive() == true<tt>
                    \pre <tt>isFillComplete()() == false<tt>
                
                    \post <tt>isFillActive() == false<tt>
                    \post <tt>isFillComplete() == true<tt>
                    \post if <tt>os == DoOptimizeStorage<tt>, then <tt>isStorageOptimized() == true</tt>
                    */
                    virtual void fillComplete(const RCP<const Map> &domainMap, const RCP<const Map> &rangeMap, const RCP<ParameterList> &params = null) =0;
                
                    /*! \brief Signal that data entry is complete.
                
                    Off-node entries are distributed (via globalAssemble()), repeated entries are summed, and global indices are transformed to local indices.
                
                    \note This method calls fillComplete( getRowMap(), getRowMap(), os ).
                
                    \pre  <tt>isFillActive() == true<tt>
                    \pre <tt>isFillComplete()() == false<tt>
                
                    \post <tt>isFillActive() == false<tt>
                    \post <tt>isFillComplete() == true<tt>
                    \post if <tt>os == DoOptimizeStorage<tt>, then <tt>isStorageOptimized() == true</tt>
                    */
                    //TODO : Get ride of "Tpetra"::OptimizeOption
                    virtual void fillComplete(const RCP<ParameterList> &params=null) =0;
                
                    //@}
                
                    //! @name Methods implementing RowMatrix
                    //@{
                
                    //! Returns the Map that describes the row distribution in this matrix.
       ##### ->     virtual const RCP<const Map> & getRowMap() const { return getRowMap(GetCurrentViewLabel()); }
                
                    //! Returns the Map that describes the row distribution in this matrix.
           1 ->     virtual const RCP<const Map> & getRowMap(viewLabel_t viewLabel) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(operatorViewTable_.containsKey(viewLabel) == false, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.GetRowMap(): view '" + viewLabel + "' does not exist.");
                      return operatorViewTable_.get(viewLabel)->GetRowMap();
                    }
                
                    //! \brief Returns the Map that describes the column distribution in this matrix.
                    //! This might be <tt>null</tt> until fillComplete() is called.
       ##### ->     virtual const RCP<const Map> & getColMap() const { return getColMap(GetCurrentViewLabel()); }
                
                    //! \brief Returns the Map that describes the column distribution in this matrix.
       ##### ->     virtual const RCP<const Map> & getColMap(viewLabel_t viewLabel) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(operatorViewTable_.containsKey(viewLabel) == false, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.GetColMap(): view '" + viewLabel + "' does not exist.");
                      return operatorViewTable_.get(viewLabel)->GetColMap();
                    }
                
                    //! Returns the number of global rows in this matrix.
                    /** Undefined if isFillActive().
                     */
                    virtual global_size_t getGlobalNumRows() const =0;
                
                    //! \brief Returns the number of global columns in the matrix.
                    /** Undefined if isFillActive().
                     */
                    virtual global_size_t getGlobalNumCols() const =0;
                
                    //! Returns the number of matrix rows owned on the calling node.
                    virtual size_t getNodeNumRows() const =0;
                
                    //! Returns the global number of entries in this matrix.
                    virtual global_size_t getGlobalNumEntries() const =0;
                
                    //! Returns the local number of entries in this matrix.
                    virtual size_t getNodeNumEntries() const =0;
                
                    //! Returns the current number of entries on this node in the specified local row.
                    /*! Returns OrdinalTraits<size_t>::invalid() if the specified local row is not valid for this matrix. */
                    virtual size_t getNumEntriesInLocalRow(LocalOrdinal localRow) const =0;
                
                    //! \brief Returns the number of global diagonal entries, based on global row/column index comparisons.
                    /** Undefined if isFillActive().
                     */
                    virtual global_size_t getGlobalNumDiags() const =0;
                
                    //! \brief Returns the number of local diagonal entries, based on global row/column index comparisons.
                    /** Undefined if isFillActive().
                     */
                    virtual size_t getNodeNumDiags() const =0;
                
                    //! \brief Returns the maximum number of entries across all rows/columns on all nodes.
                    /** Undefined if isFillActive().
                     */
                    virtual size_t getGlobalMaxNumRowEntries() const =0;
                
                    //! \brief Returns the maximum number of entries across all rows/columns on this node.
                    /** Undefined if isFillActive().
                     */
                    virtual size_t getNodeMaxNumRowEntries() const =0;
                
                    //! \brief If matrix indices are in the local range, this function returns true. Otherwise, this function returns false. */
                    virtual bool isLocallyIndexed() const =0;
                
                    //! \brief If matrix indices are in the global range, this function returns true. Otherwise, this function returns false. */
                    virtual bool isGloballyIndexed() const =0;
                
                    //! Returns \c true if fillComplete() has been called and the matrix is in compute mode.
                    virtual bool isFillComplete() const =0;
                
                    //! Extract a list of entries in a specified local row of the matrix. Put into storage allocated by calling routine.
                    /*!
                      \param LocalRow - (In) Local row number for which indices are desired.
                      \param Indices - (Out) Local column indices corresponding to values.
                      \param Values - (Out) Matrix values.
                      \param NumIndices - (Out) Number of indices.
                
                      Note: A std::runtime_error exception is thrown if either \c Indices or \c Values is not large enough to hold the data associated
                      with row \c LocalRow. If \c LocalRow is not valid for this node, then \c Indices and \c Values are unchanged and \c NumIndices is
                      returned as OrdinalTraits<size_t>::invalid().
                
                      \pre <tt>isLocallyIndexed()==true</tt> or <tt>hasColMap() == true</tt>
                    */
                    virtual void getLocalRowCopy(LocalOrdinal LocalRow,
                                                 const ArrayView<LocalOrdinal> &Indices,
                                                 const ArrayView<Scalar> &Values,
                                                 size_t &NumEntries
                                                 ) const =0;
                
                    //! Extract a const, non-persisting view of global indices in a specified row of the matrix.
                    /*!
                      \param GlobalRow - (In) Global row number for which indices are desired.
                      \param Indices   - (Out) Global column indices corresponding to values.
                      \param Values    - (Out) Row values
                      \pre <tt>isLocallyIndexed() == false</tt>
                      \post <tt>indices.size() == getNumEntriesInGlobalRow(GlobalRow)</tt>
                
                      Note: If \c GlobalRow does not belong to this node, then \c indices is set to null.
                    */
                    virtual void getGlobalRowView(GlobalOrdinal GlobalRow, ArrayView<const GlobalOrdinal> &indices, ArrayView<const Scalar> &values) const =0;
                
                    //! Extract a const, non-persisting view of local indices in a specified row of the matrix.
                    /*!
                      \param LocalRow - (In) Local row number for which indices are desired.
                      \param Indices  - (Out) Local column indices corresponding to values.
                      \param Values   - (Out) Row values
                      \pre <tt>isGloballyIndexed() == false</tt>
                      \post <tt>indices.size() == getNumEntriesInLocalRow(LocalRow)</tt>
                
                      Note: If \c LocalRow does not belong to this node, then \c indices is set to null.
                    */
                    virtual void getLocalRowView(LocalOrdinal LocalRow, ArrayView<const LocalOrdinal> &indices, ArrayView<const Scalar> &values) const =0;
                
                    //! \brief Get a copy of the diagonal entries owned by this node, with local row idices.
                    /*! Returns a distributed Vector object partitioned according to this matrix's row map, containing the
                      the zero and non-zero diagonals owned by this node. */
                    virtual void getLocalDiagCopy(Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &diag) const =0;
                
                    //! Get Frobenius norm of the matrix
                    virtual typename ScalarTraits<Scalar>::magnitudeType getFrobeniusNorm() const = 0;
                
                    //! Left scale matrix using the given vector entries
                    virtual void leftScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) = 0;
                
                    //! Right scale matrix using the given vector entries
                    virtual void rightScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) = 0;
                
                    //@}
                
                    //! @name Advanced Matrix-vector multiplication and solve methods
                    //@{
                
                    //! Multiplies this matrix by a MultiVector.
                    /*! \c X is required to be post-imported, i.e., described by the column map of the matrix. \c Y is required to be pre-exported, i.e., described by the row map of the matrix.
                
                    Both are required to have constant stride, and they are not permitted to ocupy overlapping space. No runtime checking will be performed in a non-debug build.
                
                    This method is templated on the scalar type of MultiVector objects, allowing this method to be applied to MultiVector objects of arbitrary type. However, it is recommended that multiply() not be called directly; instead, use the CrsMatrixMultiplyOp, as it will handle the import/exprt operations required to apply a matrix with non-trivial communication needs.
                
                    If \c beta is equal to zero, the operation will enjoy overwrite semantics (\c Y will be overwritten with the result of the multiplication). Otherwise, the result of the multiplication
                    will be accumulated into \c Y.
                    */
                    //TODO virtual=0 // TODO: Add default parameters ?
                //     virtual void multiply(const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> & X, MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &Y, Teuchos::ETransp trans, Scalar alpha, Scalar beta) const=0;
                
                    //@}
                
                    //! Implements DistObject interface
                    //{@
                
                    //! Access function for the Tpetra::Map this DistObject was constructed with.
                    virtual const Teuchos::RCP< const Xpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const = 0;
                
                    // TODO: first argument of doImport/doExport should be a Xpetra::DistObject
                
                    //! Import.
                    virtual void doImport(const Matrix &source,
                                          const Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) = 0;
                
                    //! Export.
                    virtual void doExport(const Matrix &dest,
                                          const Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) = 0;
                
                    //! Import (using an Exporter).
                    virtual void doImport(const Matrix &source,
                                          const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) = 0;
                
                    //! Export (using an Importer).
                    virtual void doExport(const Matrix &dest,
                                          const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) = 0;
                
                    // @}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    // TODO: describe of views can be done here
                
                    //   /** \brief Return a simple one-line description of this object. */
                    //   virtual std::string description() const =0;
                
                    //   /** \brief Print the object with some verbosity level to an FancyOStream object. */
                    //   virtual void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const =0;
                
                    //@}
                
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    /** \brief Return a simple one-line description of this object. */
                    virtual std::string description() const =0;
                
                    /** \brief Print the object with some verbosity level to an FancyOStream object. */
                    virtual void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const =0;
                    //@}
                
                    // JG: Added:
                
                    //! Returns the CrsGraph associated with this matrix.
                    virtual RCP<const CrsGraph> getCrsGraph() const =0;
                
                    // ----------------------------------------------------------------------------------
                    // "TEMPORARY" VIEW MECHANISM
                    /**
                     * Set fixed block size of operator (e.g., 3 for 3 DOFs per node).
                     *
                     * @param blksize: block size denoting how many DOFs per node are used (LocalOrdinal)
                     * @param offset:  global offset allows to define operators with global indices starting from a given value "offset" instead of 0. (GlobalOrdinal, default = 0)
                     * */
                    void SetFixedBlockSize(LocalOrdinal blksize, GlobalOrdinal offset=0) {
                
                      TEUCHOS_TEST_FOR_EXCEPTION(isFillComplete() == false, Exceptions::RuntimeError, "Xpetra::Matrix::SetFixedBlockSize(): operator is not filled and completed."); // TODO: do we need this? we just wanna "copy" the domain and range map
                
                      std::vector<size_t> stridingInfo;
                      stridingInfo.push_back(Teuchos::as<size_t>(blksize));
                      LocalOrdinal stridedBlockId = -1;
                
                      RCP<const Xpetra::StridedMap<LocalOrdinal, GlobalOrdinal, Node> > stridedRangeMap = Xpetra::StridedMapFactory<LocalOrdinal, GlobalOrdinal, Node>::Build(
                                                                    this->getRangeMap(),
                                                                    stridingInfo,
                                                                    stridedBlockId,
                                                                    offset
                                                                    );
                      RCP<const Map> stridedDomainMap = Xpetra::StridedMapFactory<LocalOrdinal, GlobalOrdinal, Node>::Build(
                                                              this->getDomainMap(),
                                                              stridingInfo,
                                                              stridedBlockId,
                                                              offset
                                                              );
                
                      if(IsView("stridedMaps") == true) RemoveView("stridedMaps");
                      CreateView("stridedMaps", stridedRangeMap, stridedDomainMap);
                    }
                
                    //==========================================================================
                
                    LocalOrdinal GetFixedBlockSize() const {
                      if(IsView("stridedMaps")==true) {
                        Teuchos::RCP<const StridedMap<LocalOrdinal, GlobalOrdinal, Node> > rangeMap = Teuchos::rcp_dynamic_cast<const StridedMap<LocalOrdinal, GlobalOrdinal, Node> >(getRowMap("stridedMaps"));
                        Teuchos::RCP<const StridedMap<LocalOrdinal, GlobalOrdinal, Node> > domainMap = Teuchos::rcp_dynamic_cast<const StridedMap<LocalOrdinal, GlobalOrdinal, Node> >(getColMap("stridedMaps"));
                        TEUCHOS_TEST_FOR_EXCEPTION(rangeMap  == Teuchos::null, Exceptions::BadCast, "Xpetra::Matrix::GetFixedBlockSize(): rangeMap is not of type StridedMap");
                        TEUCHOS_TEST_FOR_EXCEPTION(domainMap == Teuchos::null, Exceptions::BadCast, "Xpetra::Matrix::GetFixedBlockSize(): domainMap is not of type StridedMap");
                        TEUCHOS_TEST_FOR_EXCEPTION(domainMap->getFixedBlockSize() != rangeMap->getFixedBlockSize(), Exceptions::RuntimeError, "Xpetra::Matrix::GetFixedBlockSize(): block size of rangeMap and domainMap are different.");
                        return Teuchos::as<LocalOrdinal>(domainMap->getFixedBlockSize()); // TODO: why LocalOrdinal?
                      } else
                        //TEUCHOS_TEST_FOR_EXCEPTION(false, Exceptions::RuntimeError, "Xpetra::Matrix::GetFixedBlockSize(): no strided maps available."); // TODO remove this
                        return 1;
                    }; //TODO: why LocalOrdinal?
                
                    // ----------------------------------------------------------------------------------
                
       ##### ->     virtual void SetMaxEigenvalueEstimate(Scalar const &sigma) {
                      operatorViewTable_.get(GetCurrentViewLabel())->SetMaxEigenvalueEstimate(sigma);
                    }
                
                    // ----------------------------------------------------------------------------------
                
       ##### ->     virtual Scalar GetMaxEigenvalueEstimate() const {
                      return operatorViewTable_.get(GetCurrentViewLabel())->GetMaxEigenvalueEstimate();
                    }
                
                    // ----------------------------------------------------------------------------------
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    /// \brief Access the underlying local Kokkos::CrsMatrix object
                    virtual local_matrix_type getLocalMatrix () const = 0;
                #endif
                    // ----------------------------------------------------------------------------------
                
                    protected:
                      Teuchos::Hashtable<viewLabel_t, RCP<MatrixView> > operatorViewTable_; // hashtable storing the operator views (keys = view names, values = views).
                
                      viewLabel_t defaultViewLabel_;  // label of the view associated with inital Matrix construction
                      viewLabel_t currentViewLabel_;  // label of the current view
                
                  }; //class Matrix
                
                } //namespace Xpetra
                
                #define XPETRA_MATRIX_SHORT
                #endif //XPETRA_MATRIX_DECL_HPP


Top 10 Lines:

     Line      Count

      126          2
      321          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

        3   Total number of line executions
     0.38   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/stl_tree.h:
                // RB tree implementation -*- C++ -*-
                
                // Copyright (C) 2001-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 */
                
                /** @file bits/stl_tree.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{map,set}
                 */
                
                #ifndef _STL_TREE_H
                #define _STL_TREE_H 1
                
                #include <bits/stl_algobase.h>
                #include <bits/allocator.h>
                #include <bits/stl_function.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/alloc_traits.h>
                #if __cplusplus >= 201103L
                #include <ext/aligned_buffer.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Red-black tree class, designed for use in implementing STL
                  // associative containers (set, multiset, map, and multimap). The
                  // insertion and deletion algorithms are based on those in Cormen,
                  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                  // 1990), except that
                  //
                  // (1) the header cell is maintained with links not only to the root
                  // but also to the leftmost node of the tree, to enable constant
                  // time begin(), and to the rightmost node of the tree, to enable
                  // linear time performance when used with the generic set algorithms
                  // (set_union, etc.)
                  // 
                  // (2) when a node being deleted has two children its successor node
                  // is relinked into its place, rather than copied, so that the only
                  // iterators invalidated are those referring to the deleted node.
                
                  enum _Rb_tree_color { _S_red = false, _S_black = true };
                
                  struct _Rb_tree_node_base
                  {
                    typedef _Rb_tree_node_base* _Base_ptr;
                    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    _Rb_tree_color	_M_color;
                    _Base_ptr		_M_parent;
                    _Base_ptr		_M_left;
                    _Base_ptr		_M_right;
                
                    static _Base_ptr
                    _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Base_ptr
                    _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                  };
                
                  template<typename _Val>
                    struct _Rb_tree_node : public _Rb_tree_node_base
                    {
                      typedef _Rb_tree_node<_Val>* _Link_type;
                
                #if __cplusplus < 201103L
                      _Val _M_value_field;
                
                      _Val*
                      _M_valptr()
                      { return std::__addressof(_M_value_field); }
                
                      const _Val*
                      _M_valptr() const
                      { return std::__addressof(_M_value_field); }
                #else
                      __gnu_cxx::__aligned_buffer<_Val> _M_storage;
                
                      _Val*
                      _M_valptr()
                      { return _M_storage._M_ptr(); }
                
                      const _Val*
                      _M_valptr() const
                      { return _M_storage._M_ptr(); }
                #endif
                    };
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
                
                  template<typename _Tp>
                    struct _Rb_tree_iterator
                    {
                      typedef _Tp  value_type;
                      typedef _Tp& reference;
                      typedef _Tp* pointer;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
                      typedef _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
                      _Rb_tree_iterator(_Link_type __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
                      reference
                      operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
                
                      _Self&
                      operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                  };
                
                  template<typename _Tp>
                    struct _Rb_tree_const_iterator
                    {
                      typedef _Tp        value_type;
                      typedef const _Tp& reference;
                      typedef const _Tp* pointer;
                
                      typedef _Rb_tree_iterator<_Tp> iterator;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_const_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
                      typedef const _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_const_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
                      _Rb_tree_const_iterator(_Link_type __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
                      _Rb_tree_const_iterator(const iterator& __it) _GLIBCXX_NOEXCEPT
                      : _M_node(__it._M_node) { }
                
                      iterator
                      _M_const_cast() const _GLIBCXX_NOEXCEPT
                      { return iterator(static_cast<typename iterator::_Link_type>
                			(const_cast<typename iterator::_Base_ptr>(_M_node))); }
                
                      reference
                      operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      _Self&
                      operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                    };
                
                  template<typename _Val>
                    inline bool
                    operator==(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_node == __y._M_node; }
                
                  template<typename _Val>
                    inline bool
                    operator!=(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_node != __y._M_node; }
                
                  void
                  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                                _Rb_tree_node_base* __x,
                                                _Rb_tree_node_base* __p,
                                                _Rb_tree_node_base& __header) throw ();
                
                  _Rb_tree_node_base*
                  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                			       _Rb_tree_node_base& __header) throw ();
                
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc = allocator<_Val> >
                    class _Rb_tree
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
                
                      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
                
                    protected:
                      typedef _Rb_tree_node_base* 		_Base_ptr;
                      typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
                
                    public:
                      typedef _Key 				key_type;
                      typedef _Val 				value_type;
                      typedef value_type* 			pointer;
                      typedef const value_type* 		const_pointer;
                      typedef value_type& 			reference;
                      typedef const value_type& 		const_reference;
                      typedef _Rb_tree_node<_Val>* 		_Link_type;
                      typedef const _Rb_tree_node<_Val>*	_Const_Link_type;
                      typedef size_t 				size_type;
                      typedef ptrdiff_t 			difference_type;
                      typedef _Alloc 				allocator_type;
                
                      _Node_allocator&
                      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
                      
                      const _Node_allocator&
                      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Node_allocator()); }
                
                    protected:
                      _Link_type
                      _M_get_node()
                      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
                
                      void
                      _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
                
                #if __cplusplus < 201103L
                      _Link_type
                      _M_create_node(const value_type& __x)
                      {
                	_Link_type __tmp = _M_get_node();
                	__try
                	  { get_allocator().construct(__tmp->_M_valptr(), __x); }
                	__catch(...)
                	  {
                	    _M_put_node(__tmp);
                	    __throw_exception_again;
                	  }
                	return __tmp;
                      }
                
                      void
                      _M_destroy_node(_Link_type __p)
                      {
                	get_allocator().destroy(__p->_M_valptr());
                	_M_put_node(__p);
                      }
                #else
                      template<typename... _Args>
                        _Link_type
                        _M_create_node(_Args&&... __args)
                	{
                	  _Link_type __tmp = _M_get_node();
                	  __try
                	    {
                	      ::new(__tmp) _Rb_tree_node<_Val>;
                	      _Alloc_traits::construct(_M_get_Node_allocator(),
                				       __tmp->_M_valptr(),
                				       std::forward<_Args>(__args)...);
                	    }
                	  __catch(...)
                	    {
                	      _M_put_node(__tmp);
                	      __throw_exception_again;
                	    }
                	  return __tmp;
                	}
                
                      void
                      _M_destroy_node(_Link_type __p) noexcept
                      {
                	_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
                	__p->~_Rb_tree_node<_Val>();
                	_M_put_node(__p);
                      }
                #endif
                
                      _Link_type
                      _M_clone_node(_Const_Link_type __x)
                      {
                	_Link_type __tmp = _M_create_node(*__x->_M_valptr());
                	__tmp->_M_color = __x->_M_color;
                	__tmp->_M_left = 0;
                	__tmp->_M_right = 0;
                	return __tmp;
                      }
                
                    protected:
                      template<typename _Key_compare, 
                	       bool _Is_pod_comparator = __is_pod(_Key_compare)>
                        struct _Rb_tree_impl : public _Node_allocator
                        {
                	  _Key_compare		_M_key_compare;
                	  _Rb_tree_node_base 	_M_header;
                	  size_type 		_M_node_count; // Keeps track of size of tree.
                
                	  _Rb_tree_impl()
                	  : _Node_allocator(), _M_key_compare(), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
                	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                #if __cplusplus >= 201103L
                	  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
                	  : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
                	    _M_header(), _M_node_count(0)
                	  { _M_initialize(); }
                #endif
                
                	private:
                	  void
                	  _M_initialize()
                	  {
                	    this->_M_header._M_color = _S_red;
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	  }	    
                	};
                
                      _Rb_tree_impl<_Compare> _M_impl;
                
                    protected:
                      _Base_ptr&
                      _M_root() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Const_Base_ptr
                      _M_root() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Base_ptr&
                      _M_leftmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Const_Base_ptr
                      _M_leftmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Base_ptr&
                      _M_rightmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Const_Base_ptr
                      _M_rightmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Link_type
                      _M_begin() _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                
                      _Const_Link_type
                      _M_begin() const _GLIBCXX_NOEXCEPT
                      {
                	return static_cast<_Const_Link_type>
                	  (this->_M_impl._M_header._M_parent);
                      }
                
                      _Link_type
                      _M_end() _GLIBCXX_NOEXCEPT
                      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
                
                      _Const_Link_type
                      _M_end() const _GLIBCXX_NOEXCEPT
                      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }
                
                      static const_reference
                      _S_value(_Const_Link_type __x)
                      { return *__x->_M_valptr(); }
                
                      static const _Key&
                      _S_key(_Const_Link_type __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Link_type
                      _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_left); }
                
                      static _Const_Link_type
                      _S_left(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_left); }
                
                      static _Link_type
                      _S_right(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_right); }
                
                      static _Const_Link_type
                      _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_right); }
                
                      static const_reference
                      _S_value(_Const_Base_ptr __x)
                      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }
                
                      static const _Key&
                      _S_key(_Const_Base_ptr __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Base_ptr
                      _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Const_Base_ptr
                      _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Base_ptr
                      _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                      static _Const_Base_ptr
                      _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                    public:
                      typedef _Rb_tree_iterator<value_type>       iterator;
                      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                
                      typedef std::reverse_iterator<iterator>       reverse_iterator;
                      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                
                    private:
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_unique_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_equal_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_unique_pos(const_iterator __pos,
                				    const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_equal_pos(const_iterator __pos,
                				   const key_type& __k);
                
                #if __cplusplus >= 201103L
                      template<typename _Arg>
                        iterator
                        _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);
                
                      iterator
                      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_lower(_Base_ptr __y, _Arg&& __v);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_equal_lower(_Arg&& __x);
                
                      iterator
                      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
                
                      iterator
                      _M_insert_equal_lower_node(_Link_type __z);
                #else
                      iterator
                      _M_insert_(_Base_ptr __x, _Base_ptr __y,
                		 const value_type& __v);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 233. Insertion hints in associative containers.
                      iterator
                      _M_insert_lower(_Base_ptr __y, const value_type& __v);
                
                      iterator
                      _M_insert_equal_lower(const value_type& __x);
                #endif
                
                      _Link_type
                      _M_copy(_Const_Link_type __x, _Link_type __p);
                
                      void
                      _M_erase(_Link_type __x);
                
                      iterator
                      _M_lower_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                      iterator
                      _M_upper_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                    public:
                      // allocation/deallocation
                      _Rb_tree() { }
                
                      _Rb_tree(const _Compare& __comp,
                	       const allocator_type& __a = allocator_type())
                      : _M_impl(__comp, _Node_allocator(__a)) { }
                
                      _Rb_tree(const _Rb_tree& __x)
                      : _M_impl(__x._M_impl._M_key_compare,
                	        _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))
                      {
                	if (__x._M_root() != 0)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
                #if __cplusplus >= 201103L
                      _Rb_tree(const allocator_type& __a)
                      : _M_impl(_Compare(), _Node_allocator(__a))
                      { }
                
                      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
                      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
                      {
                	if (__x._M_root() != 0)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
                      _Rb_tree(_Rb_tree&& __x)
                      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
                      {
                	if (__x._M_root() != 0)
                	  _M_move_data(__x, std::true_type());
                      }
                
                      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
                      : _Rb_tree(std::move(__x), _Node_allocator(__a))
                      { }
                
                      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);
                #endif
                
                      ~_Rb_tree() _GLIBCXX_NOEXCEPT
                      { _M_erase(_M_begin()); }
                
                      _Rb_tree&
                      operator=(const _Rb_tree& __x);
                
                      // Accessors.
                      _Compare
                      key_comp() const
                      { return _M_impl._M_key_compare; }
                
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { 
                	return iterator(static_cast<_Link_type>
                			(this->_M_impl._M_header._M_left));
                      }
                
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (this->_M_impl._M_header._M_left));
                      }
                
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
                
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (&this->_M_impl._M_header));
                      }
                
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return _M_impl._M_node_count == 0; }
                
                      size_type
                      size() const _GLIBCXX_NOEXCEPT 
                      { return _M_impl._M_node_count; }
                
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
                
                      void
                #if __cplusplus >= 201103L
                      swap(_Rb_tree& __t) noexcept(_Alloc_traits::_S_nothrow_swap());
                #else
                      swap(_Rb_tree& __t);
                #endif
                
                      // Insert/erase.
                #if __cplusplus >= 201103L
                      template<typename _Arg>
                        pair<iterator, bool>
                        _M_insert_unique(_Arg&& __x);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_equal(_Arg&& __x);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_unique_(const_iterator __position, _Arg&& __x);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_equal_(const_iterator __position, _Arg&& __x);
                
                      template<typename... _Args>
                	pair<iterator, bool>
                	_M_emplace_unique(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_equal(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
                #else
                      pair<iterator, bool>
                      _M_insert_unique(const value_type& __x);
                
                      iterator
                      _M_insert_equal(const value_type& __x);
                
                      iterator
                      _M_insert_unique_(const_iterator __position, const value_type& __x);
                
                      iterator
                      _M_insert_equal_(const_iterator __position, const value_type& __x);
                #endif
                
                      template<typename _InputIterator>
                        void
                        _M_insert_unique(_InputIterator __first, _InputIterator __last);
                
                      template<typename _InputIterator>
                        void
                        _M_insert_equal(_InputIterator __first, _InputIterator __last);
                
                    private:
                      void
                      _M_erase_aux(const_iterator __position);
                
                      void
                      _M_erase_aux(const_iterator __first, const_iterator __last);
                
                    public:
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __position)
                      {
                	const_iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result._M_const_cast();
                      }
                
                      // LWG 2059.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(iterator __position)
                      {
                	iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result;
                      }
                #else
                      void
                      erase(iterator __position)
                      { _M_erase_aux(__position); }
                
                      void
                      erase(const_iterator __position)
                      { _M_erase_aux(__position); }
                #endif
                      size_type
                      erase(const key_type& __x);
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      {
                	_M_erase_aux(__first, __last);
                	return __last._M_const_cast();
                      }
                #else
                      void
                      erase(iterator __first, iterator __last)
                      { _M_erase_aux(__first, __last); }
                
                      void
                      erase(const_iterator __first, const_iterator __last)
                      { _M_erase_aux(__first, __last); }
                #endif
                      void
                      erase(const key_type* __first, const key_type* __last);
                
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      {
                        _M_erase(_M_begin());
                        _M_leftmost() = _M_end();
                        _M_root() = 0;
                        _M_rightmost() = _M_end();
                        _M_impl._M_node_count = 0;
                      }
                
                      // Set operations.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      iterator
                      lower_bound(const key_type& __k)
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      lower_bound(const key_type& __k) const
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      iterator
                      upper_bound(const key_type& __k)
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      upper_bound(const key_type& __k) const
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                      // Debugging.
                      bool
                      __rb_verify() const;
                
                #if __cplusplus >= 201103L
                      bool
                      _M_move_assign(_Rb_tree&);
                
                    private:
                      // Move elements from container with equal allocator.
                      void
                      _M_move_data(_Rb_tree&, std::true_type);
                
                      // Move elements from container with possibly non-equal allocator,
                      // which might result in a copy not a move.
                      void
                      _M_move_data(_Rb_tree&, std::false_type);
                #endif
                    };
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return __x.size() == __y.size()
                	     && std::equal(__x.begin(), __x.end(), __y.begin());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return std::lexicographical_compare(__x.begin(), __x.end(), 
                					  __y.begin(), __y.end());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
                    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
                    {
                      using __eq = integral_constant<bool, _Alloc_traits::_S_always_equal()>;
                      if (__x._M_root() != 0)
                	_M_move_data(__x, __eq());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_data(_Rb_tree& __x, std::true_type)
                    {
                      _M_root() = __x._M_root();
                      _M_leftmost() = __x._M_leftmost();
                      _M_rightmost() = __x._M_rightmost();
                      _M_root()->_M_parent = _M_end();
                
                      __x._M_root() = 0;
                      __x._M_leftmost() = __x._M_end();
                      __x._M_rightmost() = __x._M_end();
                
                      this->_M_impl._M_node_count = __x._M_impl._M_node_count;
                      __x._M_impl._M_node_count = 0;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_data(_Rb_tree& __x, std::false_type)
                    {
                      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
                	  _M_move_data(__x, std::true_type());
                      else
                	{
                	  _M_root() = _M_copy(__x._M_begin(), _M_end());
                	  _M_leftmost() = _S_minimum(_M_root());
                	  _M_rightmost() = _S_maximum(_M_root());
                	  _M_impl._M_node_count = __x._M_impl._M_node_count;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_assign(_Rb_tree& __x)
                    {
                      _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                      if (_Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal()
                	  || _M_get_Node_allocator() == __x._M_get_Node_allocator())
                	{
                	  clear();
                	  if (__x._M_root() != 0)
                	    _M_move_data(__x, std::true_type());
                	  std::__alloc_on_move(_M_get_Node_allocator(),
                			       __x._M_get_Node_allocator());
                	  return true;
                	}
                      return false;
                    }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(const _Rb_tree& __x)
                    {
                      if (this != &__x)
                	{
                	  // Note that _Key may be a constant type.
                	  clear();
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      auto& __this_alloc = this->_M_get_Node_allocator();
                	      auto& __that_alloc = __x._M_get_Node_allocator();
                	      if (!_Alloc_traits::_S_always_equal()
                		  && __this_alloc != __that_alloc)
                		{
                		  std::__alloc_on_copy(__this_alloc, __that_alloc);
                		}
                	    }
                #endif
                	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                	  if (__x._M_root() != 0)
                	    {
                	      _M_root() = _M_copy(__x._M_begin(), _M_end());
                	      _M_leftmost() = _S_minimum(_M_root());
                	      _M_rightmost() = _S_maximum(_M_root());
                	      _M_impl._M_node_count = __x._M_impl._M_node_count;
                	    }
                	}
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)
                #else
                    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
                #endif
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_KeyOfValue()(__v),
                						      _S_key(__p)));
                
                      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
                #else
                    _M_insert_lower(_Base_ptr __p, const _Val& __v)
                #endif
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _KeyOfValue()(__v)));
                
                      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal_lower(_Arg&& __v)
                #else
                    _M_insert_equal_lower(const _Val& __v)
                #endif
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                    _M_copy(_Const_Link_type __x, _Link_type __p)
                    {
                      // Structural copy.  __x and __p must be non-null.
                      _Link_type __top = _M_clone_node(__x);
                      __top->_M_parent = __p;
                
                      __try
                	{
                	  if (__x->_M_right)
                	    __top->_M_right = _M_copy(_S_right(__x), __top);
                	  __p = __top;
                	  __x = _S_left(__x);
                
                	  while (__x != 0)
                	    {
                	      _Link_type __y = _M_clone_node(__x);
                	      __p->_M_left = __y;
                	      __y->_M_parent = __p;
                	      if (__x->_M_right)
                		__y->_M_right = _M_copy(_S_right(__x), __y);
                	      __p = __y;
                	      __x = _S_left(__x);
                	    }
                	}
                      __catch(...)
                	{
                	  _M_erase(__top);
                	  __throw_exception_again;
                	}
                      return __top;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
          11 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase(_Link_type __x)
                    {
                      // Erase without rebalancing.
                      while (__x != 0)
                	{
                	  _M_erase(_S_right(__x));
                	  _Link_type __y = _S_left(__x);
                	  _M_destroy_node(__x);
                	  __x = __y;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator>
       ##### ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<iterator,
                		          iterator>(_M_lower_bound(__x, __y, __k),
                				    _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<iterator, iterator>(iterator(__y),
                				      iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin();
                      _Const_Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Const_Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<const_iterator,
                		          const_iterator>(_M_lower_bound(__x, __y, __k),
                					  _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<const_iterator, const_iterator>(const_iterator(__y),
                						  const_iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
                #if __cplusplus >= 201103L
                    noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                    {
                      if (_M_root() == 0)
                	{
                	  if (__t._M_root() != 0)
                	    {
                	      _M_root() = __t._M_root();
                	      _M_leftmost() = __t._M_leftmost();
                	      _M_rightmost() = __t._M_rightmost();
                	      _M_root()->_M_parent = _M_end();
                	      
                	      __t._M_root() = 0;
                	      __t._M_leftmost() = __t._M_end();
                	      __t._M_rightmost() = __t._M_end();
                	    }
                	}
                      else if (__t._M_root() == 0)
                	{
                	  __t._M_root() = _M_root();
                	  __t._M_leftmost() = _M_leftmost();
                	  __t._M_rightmost() = _M_rightmost();
                	  __t._M_root()->_M_parent = __t._M_end();
                	  
                	  _M_root() = 0;
                	  _M_leftmost() = _M_end();
                	  _M_rightmost() = _M_end();
                	}
                      else
                	{
                	  std::swap(_M_root(),__t._M_root());
                	  std::swap(_M_leftmost(),__t._M_leftmost());
                	  std::swap(_M_rightmost(),__t._M_rightmost());
                	  
                	  _M_root()->_M_parent = _M_end();
                	  __t._M_root()->_M_parent = __t._M_end();
                	}
                      // No need to swap header's color as it does not change.
                      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                
                      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
                				__t._M_get_Node_allocator());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
          47 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_unique_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      bool __comp = true;
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
                	  __x = __comp ? _S_left(__x) : _S_right(__x);
                	}
                      iterator __j = iterator(__y);
                      if (__comp)
                	{
                	  if (__j == begin())
                	    return _Res(__x, __y);
                	  else
                	    --__j;
                	}
                      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
                	return _Res(__x, __y);
                      return _Res(__j._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_equal_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _Res(__x, __y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator, bool>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_unique(_Arg&& __v)
                #else
                    _M_insert_unique(const _Val& __v)
                #endif
                    {
                      typedef pair<iterator, bool> _Res;
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_unique_pos(_KeyOfValue()(__v));
                
                      if (__res.second)
                	return _Res(_M_insert_(__res.first, __res.second,
                			       _GLIBCXX_FORWARD(_Arg, __v)),
                		    true);
                
                      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal(_Arg&& __v)
                #else
                    _M_insert_equal(const _Val& __v)
                #endif
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_equal_pos(_KeyOfValue()(__v));
                      return _M_insert_(__res.first, __res.second, _GLIBCXX_FORWARD(_Arg, __v));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
           2 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_unique_pos(const_iterator __position,
                				  const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // ... then try after.
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else
                	// Equivalent keys.
                	return _Res(__pos._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
           7 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_unique_(const_iterator __position, _Arg&& __v)
                #else
                    _M_insert_unique_(const_iterator __position, const _Val& __v)
                #endif
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
                
                      if (__res.second)
                	return _M_insert_(__res.first, __res.second,
                			  _GLIBCXX_FORWARD(_Arg, __v));
                      return iterator(static_cast<_Link_type>(__res.first));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else
                	{
                	  // ... then try after.  
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _Res(0, 0);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal_(const_iterator __position, _Arg&& __v)
                #else
                    _M_insert_equal_(const_iterator __position, const _Val& __v)
                #endif
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
                
                      if (__res.second)
                	return _M_insert_(__res.first, __res.second,
                			  _GLIBCXX_FORWARD(_Arg, __v));
                
                      return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_S_key(__z),
                						      _S_key(__p)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _S_key(__z)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal_lower_node(_Link_type __z)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower_node(__y, __z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			     _Compare, _Alloc>::iterator, bool>
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_unique(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    typedef pair<iterator, bool> _Res;
                	    auto __res = _M_get_insert_unique_pos(_S_key(__z));
                	    if (__res.second)
                	      return _Res(_M_insert_node(__res.first, __res.second, __z), true);
                	
                	    _M_destroy_node(__z);
                	    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
                	  }
                	__catch(...)
                	  {
                	    _M_destroy_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_equal(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_equal_pos(_S_key(__z));
                	    return _M_insert_node(__res.first, __res.second, __z);
                	  }
                	__catch(...)
                	  {
                	    _M_destroy_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
         395 ->       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    _M_destroy_node(__z);
                	    return iterator(static_cast<_Link_type>(__res.first));
                	  }
                	__catch(...)
                	  {
                	    _M_destroy_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    return _M_insert_equal_lower_node(__z);
                	  }
                	__catch(...)
                	  {
                	    _M_destroy_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                #endif
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_unique(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  _M_insert_unique_(end(), *__first);
                      }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_equal(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  _M_insert_equal_(end(), *__first);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      _M_destroy_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
       ##### ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key& __x)
                    {
                      pair<iterator, iterator> __p = equal_range(__x);
                      const size_type __old_size = size();
                      erase(__p.first, __p.second);
                      return __old_size - size();
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key* __first, const _Key* __last)
                    {
                      while (__first != __last)
                	erase(*__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k)
                    {
                      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
         564 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k) const
                    {
                      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k, 
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    count(const _Key& __k) const
                    {
                      pair<const_iterator, const_iterator> __p = equal_range(__k);
                      const size_type __n = std::distance(__p.first, __p.second);
                      return __n;
                    }
                
                  _GLIBCXX_PURE unsigned int
                  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                                       const _Rb_tree_node_base* __root) throw ();
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                    {
                      if (_M_impl._M_node_count == 0 || begin() == end())
                	return _M_impl._M_node_count == 0 && begin() == end()
                	       && this->_M_impl._M_header._M_left == _M_end()
                	       && this->_M_impl._M_header._M_right == _M_end();
                
                      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                      for (const_iterator __it = begin(); __it != end(); ++__it)
                	{
                	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                	  _Const_Link_type __L = _S_left(__x);
                	  _Const_Link_type __R = _S_right(__x);
                
                	  if (__x->_M_color == _S_red)
                	    if ((__L && __L->_M_color == _S_red)
                		|| (__R && __R->_M_color == _S_red))
                	      return false;
                
                	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                	    return false;
                	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                	    return false;
                
                	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                	    return false;
                	}
                
                      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                	return false;
                      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                	return false;
                      return true;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

     1923        564
     1787        395
     1435         47
     1239         11
     1591          7
     1532          2

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

     1026   Total number of line executions
   128.25   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_Utilities_decl.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //        MueLu: A package for multigrid based preconditioning
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef MUELU_UTILITIES_DECL_HPP
                #define MUELU_UTILITIES_DECL_HPP
                
                #include <unistd.h> //necessary for "sleep" function in debugging methods
                #include <string>
                
                #include "MueLu_ConfigDefs.hpp"
                
                #include <Teuchos_DefaultComm.hpp>
                #include <Teuchos_ScalarTraits.hpp>
                #include <Teuchos_ParameterList.hpp>
                
                #ifdef HAVE_MUELU_TPETRA
                #include <Xpetra_TpetraBlockCrsMatrix.hpp>
                #endif
                #include <Xpetra_BlockedCrsMatrix_fwd.hpp>
                #include <Xpetra_CrsMatrix_fwd.hpp>
                #include <Xpetra_CrsMatrixWrap_fwd.hpp>
                #include <Xpetra_Map_fwd.hpp>
                #include <Xpetra_MapFactory_fwd.hpp>
                #include <Xpetra_Matrix_fwd.hpp>
                #include <Xpetra_MatrixFactory_fwd.hpp>
                #include <Xpetra_MultiVector_fwd.hpp>
                #include <Xpetra_MultiVectorFactory_fwd.hpp>
                #include <Xpetra_Operator_fwd.hpp>
                #include <Xpetra_Vector_fwd.hpp>
                #include <Xpetra_VectorFactory_fwd.hpp>
                #include <Xpetra_ExportFactory.hpp>
                
                #include <Xpetra_Import.hpp>
                #include <Xpetra_ImportFactory.hpp>
                #include <Xpetra_MatrixMatrix.hpp>
                
                #ifdef HAVE_MUELU_EPETRA
                #include <Xpetra_EpetraCrsMatrix_fwd.hpp>
                
                // needed because of inlined function
                //TODO: remove inline function?
                #include <Xpetra_EpetraCrsMatrix.hpp>
                #include <Xpetra_CrsMatrixWrap.hpp>
                
                #endif
                
                #include "MueLu_Exceptions.hpp"
                
                #ifdef HAVE_MUELU_EPETRAEXT
                class Epetra_CrsMatrix;
                class Epetra_MultiVector;
                class Epetra_Vector;
                #include "EpetraExt_Transpose_RowMatrix.h"
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                #include <Tpetra_CrsMatrix.hpp>
                #include <Tpetra_RowMatrixTransposer.hpp>
                #include <Tpetra_Map.hpp>
                #include <Tpetra_MultiVector.hpp>
                #include <Xpetra_TpetraCrsMatrix_fwd.hpp>
                #include <Xpetra_TpetraMultiVector_fwd.hpp>
                #endif
                
                #include <MueLu_UtilitiesBase.hpp>
                
                
                namespace MueLu {
                
                #ifdef HAVE_MUELU_EPETRA
                  //defined after Utilities class
                  template<typename SC,typename LO,typename GO,typename NO>
                  RCP<Xpetra::CrsMatrixWrap<SC,LO,GO,NO> >
                  Convert_Epetra_CrsMatrix_ToXpetra_CrsMatrixWrap(RCP<Epetra_CrsMatrix> &epAB);
                
                  template<typename SC,typename LO,typename GO,typename NO>
                  RCP<Xpetra::Matrix<SC, LO, GO, NO> >
                  EpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Epetra_CrsMatrix>& A);
                
                  template<typename SC,typename LO,typename GO,typename NO>
                  RCP<Xpetra::MultiVector<SC, LO, GO, NO> >
                  EpetraMultiVector_To_XpetraMultiVector(const Teuchos::RCP<Epetra_MultiVector>& V);
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                  template<typename SC,typename LO,typename GO,typename NO>
                  RCP<Xpetra::Matrix<SC, LO, GO, NO> >
                  TpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<SC, LO, GO, NO> >& Atpetra);
                
                
                  template<typename SC,typename LO,typename GO,typename NO>
                  RCP<Xpetra::MultiVector<SC, LO, GO, NO> >
                  TpetraCrs_To_XpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector<SC, LO, GO, NO> >& Vtpetra);
                #endif
                
                  /*!
                    @class Utilities
                    @brief MueLu utility class.
                
                    This class provides a number of static helper methods. Some are temporary and will eventually
                    go away, while others should be moved to Xpetra.
                    */
                  template <class Scalar,
                  class LocalOrdinal  = int,
                  class GlobalOrdinal = LocalOrdinal,
                  class Node          = KokkosClassic::DefaultNode::DefaultNodeType>
                  class Utilities : public UtilitiesBase<Scalar, LocalOrdinal, GlobalOrdinal, Node> {
                #undef MUELU_UTILITIES_SHORT
                    //#include "MueLu_UseShortNames.hpp"
                
                  public:
                    typedef typename Teuchos::ScalarTraits<Scalar>::magnitudeType Magnitude;
                
                #ifdef HAVE_MUELU_EPETRA
                    //! Helper utility to pull out the underlying Epetra objects from an Xpetra object
                    // @{
                    static RCP<const Epetra_MultiVector>                    MV2EpetraMV(RCP<Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > const vec);
                    static RCP<      Epetra_MultiVector>                    MV2NonConstEpetraMV(RCP<Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > vec);
                
                    static const Epetra_MultiVector&                        MV2EpetraMV(const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& vec);
                    static       Epetra_MultiVector&                        MV2NonConstEpetraMV(Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& vec);
                
                    static RCP<const Epetra_CrsMatrix>                      Op2EpetraCrs(RCP<const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                    static RCP<      Epetra_CrsMatrix>                      Op2NonConstEpetraCrs(RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                
                    static const Epetra_CrsMatrix&                          Op2EpetraCrs(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op);
                    static       Epetra_CrsMatrix&                          Op2NonConstEpetraCrs(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op);
                
                    static const Epetra_Map&                                Map2EpetraMap(const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node>& map);
                    // @}
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                    //! Helper utility to pull out the underlying Tpetra objects from an Xpetra object
                    static RCP<const Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2TpetraMV(RCP<Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > const vec);
                    static RCP<      Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2NonConstTpetraMV(RCP<Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > vec);
                    static RCP<      Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2NonConstTpetraMV2(Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& vec);
                
                    static const Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&      MV2TpetraMV(const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& vec);
                    static       Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&      MV2NonConstTpetraMV(Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& vec);
                
                    static RCP<const Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2TpetraCrs(RCP<const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                    static RCP<      Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2NonConstTpetraCrs(RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                
                    static const Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&        Op2TpetraCrs(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op);
                    static       Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&        Op2NonConstTpetraCrs(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op);
                
                    static RCP<const Tpetra::RowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2TpetraRow(RCP<const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                    static RCP<      Tpetra::RowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2NonConstTpetraRow(RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op);
                
                
                    static const RCP<const Tpetra::Map<LocalOrdinal, GlobalOrdinal, Node> >        Map2TpetraMap(const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node>& map);
                #endif
                
                    static RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >          Crs2Op(RCP<Xpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Op) { return UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Crs2Op(Op); }
                    static Teuchos::ArrayRCP<Scalar>                                             GetMatrixDiagonal(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixDiagonal(A); }
                    static RCP<Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> >          GetMatrixDiagonalInverse(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A, Magnitude tol = Teuchos::ScalarTraits<Scalar>::eps()*100) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixDiagonalInverse(A,tol); }
                    static Teuchos::ArrayRCP<Scalar>                                             GetLumpedMatrixDiagonal(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetLumpedMatrixDiagonal(A); }
                    static Teuchos::RCP<Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > GetLumpedMatrixDiagonal(Teuchos::RCP<const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetLumpedMatrixDiagonal(A); }
                    static RCP<Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> >          GetMatrixOverlappedDiagonal(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixOverlappedDiagonal(A); }
                    static Teuchos::RCP<Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > GetInverse(Teuchos::RCP<const Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > v, Magnitude tol = Teuchos::ScalarTraits<Scalar>::eps()*100, Scalar tolReplacement = Teuchos::ScalarTraits<Scalar>::zero()) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetInverse(v,tol,tolReplacement); }
                    static Teuchos::Array<Magnitude>                                             ResidualNorm(const Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& X, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& RHS) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::ResidualNorm(Op,X,RHS); }
                    static RCP<Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> >     Residual(const Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& X, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& RHS) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Residual(Op,X,RHS); }
                    static void                                                                  PauseForDebugger() { MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::PauseForDebugger(); }
                    static RCP<Teuchos::FancyOStream>                                            MakeFancy(std::ostream& os) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::MakeFancy(os); }
                    static typename Teuchos::ScalarTraits<Scalar>::magnitudeType                 Distance2(const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& v, LocalOrdinal i0, LocalOrdinal i1) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Distance2(v,i0,i1); }
                    static Teuchos::ArrayRCP<const bool>                                         DetectDirichletRows(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A, const Magnitude& tol = Teuchos::ScalarTraits<Scalar>::magnitude(0.)) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::DetectDirichletRows(A,tol); }
                    static void                                                                  SetRandomSeed(const Teuchos::Comm<int> &comm) { MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::SetRandomSeed(comm); }
                
                    static Scalar PowerMethod(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A, bool scaleByDiag = true,
                                              LocalOrdinal niters = 10, Magnitude tolerance = 1e-2, bool verbose = false, unsigned int seed = 123) {
                      return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::PowerMethod(A,scaleByDiag,niters,tolerance,verbose,seed);
                    }
                
                    static Scalar Frobenius(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A, const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& B) {
                      return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Frobenius(A, B);
                    }
                
                    static void MyOldScaleMatrix(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Teuchos::ArrayRCP<const Scalar>& scalingVector, bool doInverse = true,
                                                 bool doFillComplete = true, bool doOptimizeStorage = true);
                
                    static void MyOldScaleMatrix_Epetra(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Teuchos::ArrayRCP<Scalar>& scalingVector,
                                                        bool doFillComplete, bool doOptimizeStorage);
                    static void MyOldScaleMatrix_Tpetra(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Teuchos::ArrayRCP<Scalar>& scalingVector,
                                                        bool doFillComplete, bool doOptimizeStorage);
                
                    static RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > Transpose(Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, bool optimizeTranspose = false,const std::string & label = std::string());
                
                    static RCP<Xpetra::MultiVector<double,LocalOrdinal,GlobalOrdinal,Node> > ExtractCoordinatesFromParameterList(ParameterList& paramList);
                  }; // class Utilities
                
                  ///////////////////////////////////////////
                
                #ifdef HAVE_MUELU_EPETRA
                  /*!
                    @class Utilities
                    @brief MueLu utility class (specialization SC=double and LO=GO=int).
                
                    This class provides a number of static helper methods. Some are temporary and will eventually
                    go away, while others should be moved to Xpetra.
                
                  Note: this is the implementation for Epetra. Tpetra throws if TPETRA_INST_INT_INT is disabled!
                  */
                  template <>
                  class Utilities<double,int,int,Xpetra::EpetraNode> : public UtilitiesBase<double,int,int,Xpetra::EpetraNode> {
                  public:
                    typedef double              Scalar;
                    typedef int                 LocalOrdinal;
                    typedef int                 GlobalOrdinal;
                    typedef Xpetra::EpetraNode  Node;
                    typedef Teuchos::ScalarTraits<Scalar>::magnitudeType Magnitude;
                
                  private:
                    typedef Xpetra::CrsMatrixWrap<Scalar,LocalOrdinal,GlobalOrdinal,Node> CrsMatrixWrap;
                    typedef Xpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> CrsMatrix;
                    typedef Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> Matrix;
                    typedef Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> Vector;
                    typedef Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> MultiVector;
                    typedef Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node> Map;
                #ifdef HAVE_MUELU_EPETRA
                    typedef Xpetra::EpetraMapT<GlobalOrdinal,Node> EpetraMap;
                    typedef Xpetra::EpetraMultiVectorT<GlobalOrdinal,Node> EpetraMultiVector;
                    typedef Xpetra::EpetraCrsMatrixT<GlobalOrdinal,Node> EpetraCrsMatrix;
                #endif
                  public:
                
                #ifdef HAVE_MUELU_EPETRA
                    //! Helper utility to pull out the underlying Epetra objects from an Xpetra object
                    // @{
                    static RCP<const Epetra_MultiVector>                    MV2EpetraMV(RCP<MultiVector> const vec) {
                      RCP<const EpetraMultiVector > tmpVec = rcp_dynamic_cast<EpetraMultiVector>(vec);
                      if (tmpVec == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::MultiVector to Xpetra::EpetraMultiVector failed");
                      return tmpVec->getEpetra_MultiVector();
                    }
                    static RCP<      Epetra_MultiVector>                    MV2NonConstEpetraMV(RCP<MultiVector> vec) {
                      RCP<const EpetraMultiVector> tmpVec = rcp_dynamic_cast<EpetraMultiVector>(vec);
                      if (tmpVec == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::MultiVector to Xpetra::EpetraMultiVector failed");
                      return tmpVec->getEpetra_MultiVector();
                    }
                
                    static const Epetra_MultiVector&                        MV2EpetraMV(const MultiVector& vec) {
                      const EpetraMultiVector& tmpVec = dynamic_cast<const EpetraMultiVector&>(vec);
                      return *(tmpVec.getEpetra_MultiVector());
                    }
                    static       Epetra_MultiVector&                        MV2NonConstEpetraMV(MultiVector& vec) {
                      const EpetraMultiVector& tmpVec = dynamic_cast<const EpetraMultiVector&>(vec);
                      return *(tmpVec.getEpetra_MultiVector());
                    }
                
                    static RCP<const Epetra_CrsMatrix>                      Op2EpetraCrs(RCP<const Matrix> Op) {
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      const RCP<const EpetraCrsMatrix>& tmp_ECrsMtx = rcp_dynamic_cast<const EpetraCrsMatrix>(crsOp->getCrsMatrix());
                      if (tmp_ECrsMtx == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::EpetraCrsMatrix failed");
                      return tmp_ECrsMtx->getEpetra_CrsMatrix();
                    }
                    static RCP<      Epetra_CrsMatrix>                      Op2NonConstEpetraCrs(RCP<Matrix> Op) {
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      const RCP<const EpetraCrsMatrix> &tmp_ECrsMtx = rcp_dynamic_cast<const EpetraCrsMatrix>(crsOp->getCrsMatrix());
                      if (tmp_ECrsMtx == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::EpetraCrsMatrix failed");
                      return tmp_ECrsMtx->getEpetra_CrsMatrixNonConst();
                    }
                
                    static const Epetra_CrsMatrix&                          Op2EpetraCrs(const Matrix& Op) {
                      try {
                        const CrsMatrixWrap& crsOp = dynamic_cast<const CrsMatrixWrap&>(Op);
                        try {
                          const EpetraCrsMatrix& tmp_ECrsMtx = dynamic_cast<const EpetraCrsMatrix&>(*crsOp.getCrsMatrix());
                          return *tmp_ECrsMtx.getEpetra_CrsMatrix();
                        } catch (std::bad_cast) {
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::EpetraCrsMatrix failed");
                        }
                      } catch (std::bad_cast) {
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      }
                    }
                    static       Epetra_CrsMatrix&                          Op2NonConstEpetraCrs(Matrix& Op) {
                      try {
                        CrsMatrixWrap& crsOp = dynamic_cast<CrsMatrixWrap&>(Op);
                        try {
                          EpetraCrsMatrix& tmp_ECrsMtx = dynamic_cast<EpetraCrsMatrix&>(*crsOp.getCrsMatrix());
                          return *tmp_ECrsMtx.getEpetra_CrsMatrixNonConst();
                        } catch (std::bad_cast) {
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::EpetraCrsMatrix failed");
                        }
                      } catch (std::bad_cast) {
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      }
                    }
                
                    static const Epetra_Map&                                Map2EpetraMap(const Map& map) {
                      RCP<const EpetraMap> xeMap = rcp_dynamic_cast<const EpetraMap>(rcpFromRef(map));
                      if (xeMap == Teuchos::null)
                        throw Exceptions::BadCast("Utilities::Map2EpetraMap : Cast from Xpetra::Map to Xpetra::EpetraMap failed");
                      return xeMap->getEpetra_Map();
                    }
                    // @}
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                    //! Helper utility to pull out the underlying Tpetra objects from an Xpetra object
                    static RCP<const Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2TpetraMV(RCP<MultiVector> const vec)   {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("MV2TpetraMV: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      RCP<const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmpVec = rcp_dynamic_cast<Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(vec);
                      if (tmpVec == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::MultiVector to Xpetra::TpetraMultiVector failed");
                      return tmpVec->getTpetra_MultiVector();
                #endif
                    }
                    static RCP<      Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2NonConstTpetraMV(RCP<MultiVector> vec) {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("MV2NonConstTpetraMV: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      RCP<const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmpVec = rcp_dynamic_cast<Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(vec);
                      if (tmpVec == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::MultiVector to Xpetra::TpetraMultiVector failed");
                      return tmpVec->getTpetra_MultiVector();
                #endif
                
                    }
                    static RCP<      Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > MV2NonConstTpetraMV2(MultiVector& vec)    {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("MV2NonConstTpetraMV2: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& tmpVec = dynamic_cast<const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&>(vec);
                      return tmpVec.getTpetra_MultiVector();
                #endif
                    }
                
                    static const Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&      MV2TpetraMV(const MultiVector& vec)   {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("MV2TpetraMV: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& tmpVec = dynamic_cast<const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&>(vec);
                      return *(tmpVec.getTpetra_MultiVector());
                #endif
                    }
                    static       Tpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&      MV2NonConstTpetraMV(MultiVector& vec) {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("MV2NonConstTpetraMV: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& tmpVec = dynamic_cast<const Xpetra::TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>&>(vec);
                      return *(tmpVec.getTpetra_MultiVector());
                #endif
                    }
                
                    static RCP<const Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2TpetraCrs(RCP<const Matrix> Op)  {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2TpetraCrs: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      // Get the underlying Tpetra Mtx
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      const RCP<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > &tmp_ECrsMtx = rcp_dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsOp->getCrsMatrix());
                      if (tmp_ECrsMtx == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix failed");
                      return tmp_ECrsMtx->getTpetra_CrsMatrix();
                #endif
                    }
                    static RCP<      Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2NonConstTpetraCrs(RCP<Matrix> Op){
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2NonConstTpetraCrs: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      const RCP<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > &tmp_ECrsMtx = rcp_dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsOp->getCrsMatrix());
                      if (tmp_ECrsMtx == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix failed");
                      return tmp_ECrsMtx->getTpetra_CrsMatrixNonConst();
                #endif
                    };
                
                    static const Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&        Op2TpetraCrs(const Matrix& Op)   {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2TpetraCrs: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      try {
                        const CrsMatrixWrap& crsOp = dynamic_cast<const CrsMatrixWrap&>(Op);
                        try {
                          const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& tmp_ECrsMtx = dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&>(*crsOp.getCrsMatrix());
                          return *tmp_ECrsMtx.getTpetra_CrsMatrix();
                        } catch (std::bad_cast) {
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix failed");
                        }
                      } catch (std::bad_cast) {
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      }
                #endif
                    }
                    static       Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&        Op2NonConstTpetraCrs(Matrix& Op) {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2NonConstTpetraCrs: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      try {
                        CrsMatrixWrap& crsOp = dynamic_cast<CrsMatrixWrap&>(Op);
                        try {
                          Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& tmp_ECrsMtx = dynamic_cast<Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>&>(*crsOp.getCrsMatrix());
                          return *tmp_ECrsMtx.getTpetra_CrsMatrixNonConst();
                        } catch (std::bad_cast) {
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix failed");
                        }
                      } catch (std::bad_cast) {
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                      }
                #endif
                    }
                
                    static RCP<const Tpetra::RowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2TpetraRow(RCP<const Matrix> Op)   {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2TpetraRow: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                
                      RCP<const CrsMatrix> crsMat = crsOp->getCrsMatrix();
                      const RCP<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmp_Crs = rcp_dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsMat);
                      RCP<const Xpetra::TpetraBlockCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmp_BlockCrs;
                      if(!tmp_Crs.is_null()) {
                        return tmp_Crs->getTpetra_CrsMatrixNonConst();
                      }
                      else {
                        tmp_BlockCrs= rcp_dynamic_cast<const Xpetra::TpetraBlockCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsMat);
                        if (tmp_BlockCrs.is_null())
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix and Xpetra::TpetraBlockCrsMatrix failed");
                        return tmp_BlockCrs->getTpetra_BlockCrsMatrixNonConst();
                      }
                #endif
                    }
                    static RCP<      Tpetra::RowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >   Op2NonConstTpetraRow(RCP<Matrix> Op) {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Op2NonConstTpetraRow: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      RCP<const CrsMatrixWrap> crsOp = rcp_dynamic_cast<const CrsMatrixWrap>(Op);
                      if (crsOp == Teuchos::null)
                        throw Exceptions::BadCast("Cast from Xpetra::Matrix to Xpetra::CrsMatrixWrap failed");
                
                      RCP<const CrsMatrix> crsMat = crsOp->getCrsMatrix();
                      const RCP<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmp_Crs = rcp_dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsMat);
                      RCP<const Xpetra::TpetraBlockCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tmp_BlockCrs;
                      if(!tmp_Crs.is_null()) {
                        return tmp_Crs->getTpetra_CrsMatrixNonConst();
                      }
                      else {
                        tmp_BlockCrs= rcp_dynamic_cast<const Xpetra::TpetraBlockCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(crsMat);
                        if (tmp_BlockCrs.is_null())
                          throw Exceptions::BadCast("Cast from Xpetra::CrsMatrix to Xpetra::TpetraCrsMatrix and Xpetra::TpetraBlockCrsMatrix failed");
                        return tmp_BlockCrs->getTpetra_BlockCrsMatrixNonConst();
                      }
                #endif
                    };
                
                
                    static const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >          Map2TpetraMap(const Map& map) {
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Map2TpetraMap: Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      const RCP<const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node>>& tmp_TMap = rcp_dynamic_cast<const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node> >(rcpFromRef(map));
                      if (tmp_TMap == Teuchos::null)
                        throw Exceptions::BadCast("Utilities::Map2TpetraMap : Cast from Xpetra::Map to Xpetra::TpetraMap failed");
                      return tmp_TMap->getTpetra_Map();
                #endif
                    };
                #endif
                
                    static RCP<Matrix>                                                           Crs2Op(RCP<CrsMatrix> Op) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Crs2Op(Op); }
                    static Teuchos::ArrayRCP<Scalar>                                             GetMatrixDiagonal(const Matrix& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixDiagonal(A); }
                    static RCP<Vector>                                                           GetMatrixDiagonalInverse(const Matrix& A, Magnitude tol = Teuchos::ScalarTraits<Scalar>::eps()*100) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixDiagonalInverse(A,tol); }
                    static Teuchos::ArrayRCP<Scalar>                                             GetLumpedMatrixDiagonal(const Matrix& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetLumpedMatrixDiagonal(A); }
                    static Teuchos::RCP<Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> > GetLumpedMatrixDiagonal(Teuchos::RCP<const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetLumpedMatrixDiagonal(A); }
                    static RCP<Vector>                                                           GetMatrixOverlappedDiagonal(const Matrix& A) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetMatrixOverlappedDiagonal(A); }
                    static RCP<Vector>                                                           GetInverse(Teuchos::RCP<const Vector> v, Magnitude tol = Teuchos::ScalarTraits<Scalar>::eps()*100, Scalar tolReplacement = Teuchos::ScalarTraits<Scalar>::zero()) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::GetInverse(v,tol,tolReplacement); }
                    static Teuchos::Array<Magnitude>                                             ResidualNorm(const Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& X, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& RHS) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::ResidualNorm(Op,X,RHS); }
                    static RCP<MultiVector>                                                      Residual(const Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Op, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& X, const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& RHS) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Residual(Op,X,RHS); }
                    static void                                                                  PauseForDebugger() { MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::PauseForDebugger(); }
                    static RCP<Teuchos::FancyOStream>                                            MakeFancy(std::ostream& os) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::MakeFancy(os); }
                    static Teuchos::ScalarTraits<Scalar>::magnitudeType                 Distance2(const MultiVector& v, LocalOrdinal i0, LocalOrdinal i1) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Distance2(v,i0,i1); }
                    static Teuchos::ArrayRCP<const bool>                                         DetectDirichletRows(const Matrix& A, const Magnitude& tol = Teuchos::ScalarTraits<Scalar>::zero()) { return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::DetectDirichletRows(A,tol); }
                    static void                                                                  SetRandomSeed(const Teuchos::Comm<int> &comm) { MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::SetRandomSeed(comm); }
                
                    static Scalar PowerMethod(const Matrix& A, bool scaleByDiag = true,
                                              LocalOrdinal niters = 10, Magnitude tolerance = 1e-2, bool verbose = false, unsigned int seed = 123) {
                      return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::PowerMethod(A,scaleByDiag,niters,tolerance,verbose,seed);
                    }
                
                    static Scalar Frobenius(const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& A, const Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>& B) {
                      return MueLu::UtilitiesBase<Scalar,LocalOrdinal,GlobalOrdinal,Node>::Frobenius(A, B);
                    }
                
                    static void MyOldScaleMatrix(Matrix& Op, const Teuchos::ArrayRCP<const Scalar>& scalingVector, bool doInverse = true,
                                                 bool doFillComplete = true, bool doOptimizeStorage = true) {
                      Scalar one = Teuchos::ScalarTraits<Scalar>::one();
                      Teuchos::ArrayRCP<Scalar> sv(scalingVector.size());
                      if (doInverse) {
                        for (int i = 0; i < scalingVector.size(); ++i)
                          sv[i] = one / scalingVector[i];
                      } else {
                        for (int i = 0; i < scalingVector.size(); ++i)
                          sv[i] = scalingVector[i];
                      }
                
                      switch (Op.getRowMap()->lib()) {
                        case Xpetra::UseTpetra:
                          MyOldScaleMatrix_Tpetra(Op, sv, doFillComplete, doOptimizeStorage);
                          break;
                
                        case Xpetra::UseEpetra:
                          MyOldScaleMatrix_Epetra(Op, sv, doFillComplete, doOptimizeStorage);
                          break;
                
                        default:
                          throw Exceptions::RuntimeError("Only Epetra and Tpetra matrices can be scaled.");
                          break;
                      }
                    }
                
                    // TODO This is the <double,int,int> specialization
                    static void MyOldScaleMatrix_Tpetra(Matrix& Op, const Teuchos::ArrayRCP<Scalar>& scalingVector,
                                                        bool doFillComplete, bool doOptimizeStorage) {
                #ifdef HAVE_MUELU_TPETRA
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                      throw Exceptions::RuntimeError("Matrix scaling is not possible because Tpetra has not been compiled with support for LO=GO=int.");
                #else
                      try {
                        Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>& tpOp = Op2NonConstTpetraCrs(Op);
                
                        const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > rowMap    = tpOp.getRowMap();
                        const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > domainMap = tpOp.getDomainMap();
                        const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > rangeMap  = tpOp.getRangeMap();
                
                        size_t maxRowSize = tpOp.getNodeMaxNumRowEntries();
                        if (maxRowSize == Teuchos::as<size_t>(-1)) // hasn't been determined yet
                          maxRowSize = 20;
                
                        std::vector<Scalar> scaledVals(maxRowSize);
                        if (tpOp.isFillComplete())
                          tpOp.resumeFill();
                
                        if (Op.isLocallyIndexed() == true) {
                          Teuchos::ArrayView<const LocalOrdinal> cols;
                          Teuchos::ArrayView<const Scalar> vals;
                
                          for (size_t i = 0; i < rowMap->getNodeNumElements(); ++i) {
                            tpOp.getLocalRowView(i, cols, vals);
                            size_t nnz = tpOp.getNumEntriesInLocalRow(i);
                            if (nnz > maxRowSize) {
                              maxRowSize = nnz;
                              scaledVals.resize(maxRowSize);
                            }
                            for (size_t j = 0; j < nnz; ++j)
                              scaledVals[j] = vals[j]*scalingVector[i];
                
                            if (nnz > 0) {
                              Teuchos::ArrayView<const Scalar> valview(&scaledVals[0], nnz);
                              tpOp.replaceLocalValues(i, cols, valview);
                            }
                          } //for (size_t i=0; ...
                
                        } else {
                          Teuchos::ArrayView<const GlobalOrdinal> cols;
                          Teuchos::ArrayView<const Scalar> vals;
                
                          for (size_t i = 0; i < rowMap->getNodeNumElements(); ++i) {
                            GlobalOrdinal gid = rowMap->getGlobalElement(i);
                            tpOp.getGlobalRowView(gid, cols, vals);
                            size_t nnz = tpOp.getNumEntriesInGlobalRow(gid);
                            if (nnz > maxRowSize) {
                              maxRowSize = nnz;
                              scaledVals.resize(maxRowSize);
                            }
                            // FIXME FIXME FIXME FIXME FIXME FIXME
                            for (size_t j = 0; j < nnz; ++j)
                              scaledVals[j] = vals[j]*scalingVector[i]; //FIXME i or gid?
                
                            if (nnz > 0) {
                              Teuchos::ArrayView<const Scalar> valview(&scaledVals[0], nnz);
                              tpOp.replaceGlobalValues(gid, cols, valview);
                            }
                          } //for (size_t i=0; ...
                        }
                
                        if (doFillComplete) {
                          if (domainMap == Teuchos::null || rangeMap == Teuchos::null)
                            throw Exceptions::RuntimeError("In Utilities::Scaling: cannot fillComplete because the domain and/or range map hasn't been defined");
                
                          RCP<Teuchos::ParameterList> params = rcp(new Teuchos::ParameterList());
                          params->set("Optimize Storage",    doOptimizeStorage);
                          params->set("No Nonlocal Changes", true);
                          Op.fillComplete(Op.getDomainMap(), Op.getRangeMap(), params);
                        }
                      } catch(...) {
                        throw Exceptions::RuntimeError("Only Tpetra::CrsMatrix types can be scaled (Err.1)");
                      }
                #endif
                #else
                      throw Exceptions::RuntimeError("Matrix scaling is not possible because Tpetra has not been enabled.");
                #endif
                    }
                
                    static void MyOldScaleMatrix_Epetra (Matrix& Op, const Teuchos::ArrayRCP<Scalar>& scalingVector, bool doFillComplete, bool doOptimizeStorage) {
                #ifdef HAVE_MUELU_EPETRA
                      try {
                        //const Epetra_CrsMatrix& epOp = Utilities<double,int,int>::Op2NonConstEpetraCrs(Op);
                        const Epetra_CrsMatrix& epOp = Op2NonConstEpetraCrs(Op);
                
                        Epetra_Map const &rowMap = epOp.RowMap();
                        int nnz;
                        double *vals;
                        int *cols;
                
                        for (int i = 0; i < rowMap.NumMyElements(); ++i) {
                          epOp.ExtractMyRowView(i, nnz, vals, cols);
                          for (int j = 0; j < nnz; ++j)
                            vals[j] *= scalingVector[i];
                        }
                
                      } catch (...){
                        throw Exceptions::RuntimeError("Only Epetra_CrsMatrix types can be scaled");
                      }
                #else
                      throw Exceptions::RuntimeError("Matrix scaling is not possible because Epetra has not been enabled.");
                #endif // HAVE_MUELU_EPETRA
                    }
                
                    /*! @brief Transpose a Xpetra::Matrix
                
                        Note: Currently, an error is thrown if the matrix isn't a Tpetra::CrsMatrix or Epetra_CrsMatrix.
                        In principle, however, we could allow any Epetra_RowMatrix because the Epetra transposer does.
                    */
                    static RCP<Matrix> Transpose(Matrix& Op, bool optimizeTranspose = false,const std::string & label = std::string()) {
                      switch (Op.getRowMap()->lib()) {
                        case Xpetra::UseTpetra: {
                #ifdef HAVE_MUELU_TPETRA
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                            throw Exceptions::RuntimeError("Utilities::Transpose: Tpetra is not compiled with LO=GO=int. Add TPETRA_INST_INT_INT:BOOL=ON to your configuration!");
                #else
                            try {
                              const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>& tpetraOp = Utilities<Scalar, LocalOrdinal, GlobalOrdinal, Node>::Op2TpetraCrs(Op);
                
                              // Compute the transpose A of the Tpetra matrix tpetraOp.
                              RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > A;
                              Tpetra::RowMatrixTransposer<Scalar, LocalOrdinal, GlobalOrdinal, Node> transposer(rcpFromRef(tpetraOp),label);
                              A = transposer.createTranspose();
                              RCP<Xpetra::TpetraCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > AA   = rcp(new Xpetra::TpetraCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>(A));
                              RCP<CrsMatrix>                                                           AAA  = rcp_implicit_cast<CrsMatrix>(AA);
                              RCP<Matrix>                                                              AAAA = rcp( new CrsMatrixWrap(AAA));
                
                              if (Op.IsView("stridedMaps"))
                                AAAA->CreateView("stridedMaps", Teuchos::rcpFromRef(Op), true/*doTranspose*/);
                
                              return AAAA;
                            }
                            catch (std::exception& e) {
                              std::cout << "threw exception '" << e.what() << "'" << std::endl;
                              throw Exceptions::RuntimeError("Utilities::Transpose failed, perhaps because matrix is not a Crs matrix");
                            }
                #endif
                #else
                            throw Exceptions::RuntimeError("Utilities::Transpose: Tpetra is not compiled!");
                #endif
                            break;
                          }
                        case Xpetra::UseEpetra:
                          {
                #if defined(HAVE_MUELU_EPETRA) && defined(HAVE_MUELU_EPETRAEXT)
                            Teuchos::TimeMonitor tm(*Teuchos::TimeMonitor::getNewTimer("ZZ Entire Transpose"));
                            // Epetra case
                            Epetra_CrsMatrix& epetraOp = Utilities<Scalar, LocalOrdinal, GlobalOrdinal, Node>::Op2NonConstEpetraCrs(Op);
                            EpetraExt::RowMatrix_Transpose transposer;
                            Epetra_CrsMatrix * A = dynamic_cast<Epetra_CrsMatrix*>(&transposer(epetraOp));
                            transposer.ReleaseTranspose(); // So we can keep A in Muelu...
                
                            RCP<Epetra_CrsMatrix> rcpA(A);
                            RCP<EpetraCrsMatrix> AA   = rcp(new EpetraCrsMatrix(rcpA));
                            RCP<CrsMatrix>       AAA  = rcp_implicit_cast<CrsMatrix>(AA);
                            RCP<Matrix>          AAAA = rcp( new CrsMatrixWrap(AAA));
                            AAAA->fillComplete(Op.getRangeMap(), Op.getDomainMap());
                
                            if (Op.IsView("stridedMaps"))
                              AAAA->CreateView("stridedMaps", Teuchos::rcpFromRef(Op), true/*doTranspose*/);
                
                            return AAAA;
                #else
                            throw Exceptions::RuntimeError("Epetra (Err. 2)");
                #endif
                            break;
                          }
                        default:
                          throw Exceptions::RuntimeError("Only Epetra and Tpetra matrices can be transposed.");
                          break;
                      }
                
                      return Teuchos::null;
                    }
                
                    /*! @brief Extract coordinates from parameter list and return them in a Xpetra::MultiVector
                    */
                    static RCP<Xpetra::MultiVector<double,LocalOrdinal,GlobalOrdinal,Node> > ExtractCoordinatesFromParameterList(ParameterList& paramList) {
                      RCP<Xpetra::MultiVector<double,LocalOrdinal,GlobalOrdinal,Node> > coordinates = Teuchos::null;
                
                      // check whether coordinates are contained in parameter list
                      if(paramList.isParameter ("Coordinates") == false)
                        return coordinates;
                
                  #if defined(HAVE_MUELU_TPETRA)
                  #if ( defined(EPETRA_HAVE_OMP) && defined(HAVE_TPETRA_INST_OPENMP) && defined(HAVE_TPETRA_INST_INT_INT)) || \
                      (!defined(EPETRA_HAVE_OMP) && defined(HAVE_TPETRA_INST_SERIAL) && defined(HAVE_TPETRA_INST_INT_INT))
                
                      // define Tpetra::MultiVector type with Scalar=float only if
                      // * ETI is turned off, since then the compiler will instantiate it automatically OR
                      // * Tpetra is instantiated on Scalar=float
                  #if !defined(HAVE_TPETRA_EXPLICIT_INSTANTIATION) || defined(HAVE_TPETRA_INST_FLOAT)
                      typedef Tpetra::MultiVector<float, LocalOrdinal, GlobalOrdinal, Node> tfMV;
                      RCP<tfMV> floatCoords = Teuchos::null;
                  #endif
                
                      // define Tpetra::MultiVector type with Scalar=double only if
                      // * ETI is turned off, since then the compiler will instantiate it automatically OR
                      // * Tpetra is instantiated on Scalar=double
                      typedef Tpetra::MultiVector<double, LocalOrdinal, GlobalOrdinal, Node> tdMV;
                      RCP<tdMV> doubleCoords = Teuchos::null;
                      if (paramList.isType<RCP<tdMV> >("Coordinates")) {
                        // Coordinates are stored as a double vector
                        doubleCoords = paramList.get<RCP<tdMV> >("Coordinates");
                        paramList.remove("Coordinates");
                      }
                  #if !defined(HAVE_TPETRA_EXPLICIT_INSTANTIATION) || defined(HAVE_TPETRA_INST_FLOAT)
                      else if (paramList.isType<RCP<tfMV> >("Coordinates")) {
                        // check if coordinates are stored as a float vector
                        floatCoords = paramList.get<RCP<tfMV> >("Coordinates");
                        paramList.remove("Coordinates");
                        doubleCoords = rcp(new tdMV(floatCoords->getMap(), floatCoords->getNumVectors()));
                        deep_copy(*doubleCoords, *floatCoords);
                      }
                  #endif
                      // We have the coordinates in a Tpetra double vector
                      if(doubleCoords != Teuchos::null) {
                        coordinates = Teuchos::rcp(new Xpetra::TpetraMultiVector<double, LocalOrdinal, GlobalOrdinal, Node>(doubleCoords));
                        TEUCHOS_TEST_FOR_EXCEPT(doubleCoords->getNumVectors() != coordinates->getNumVectors());
                      }
                  #endif // Tpetra instantiated on GO=int and EpetraNode
                  #endif // endif HAVE_TPETRA
                
                  #if defined(HAVE_MUELU_EPETRA)
                      RCP<Epetra_MultiVector> doubleEpCoords;
                      if (paramList.isType<RCP<Epetra_MultiVector> >("Coordinates")) {
                        doubleEpCoords = paramList.get<RCP<Epetra_MultiVector> >("Coordinates");
                        paramList.remove("Coordinates");
                        RCP<Xpetra::EpetraMultiVectorT<GlobalOrdinal,Node> > epCoordinates = Teuchos::rcp(new Xpetra::EpetraMultiVectorT<GlobalOrdinal,Node>(doubleEpCoords));
                        coordinates = rcp_dynamic_cast<Xpetra::MultiVector<double,LocalOrdinal,GlobalOrdinal,Node> >(epCoordinates);
                        TEUCHOS_TEST_FOR_EXCEPT(doubleEpCoords->NumVectors() != Teuchos::as<int>(coordinates->getNumVectors()));
                      }
                  #endif
                      TEUCHOS_TEST_FOR_EXCEPT(Teuchos::is_null(coordinates));
                      return coordinates;
                    }
                
                  }; // class Utilities (specialization SC=double LO=GO=int)
                
                #endif // HAVE_MUELU_EPETRA
                
                
                
                  /*! Removes the following non-serializable data (A,P,R,Nullspace,Coordinates) from level-specific sublists from inList
                    and moves it to nonSerialList.  Everything else is copied to serialList.  This function returns the level number of the highest level
                    for which non-serializable data was provided.
                    */
                  long ExtractNonSerializableData(const Teuchos::ParameterList& inList, Teuchos::ParameterList& serialList, Teuchos::ParameterList& nonSerialList);
                
                
                  /*! Tokenizes a (comma)-separated string, removing all leading and trailing whitespace
                  WARNING: This routine is not threadsafe on most architectures
                  */
                  void TokenizeStringAndStripWhiteSpace(const std::string & stream, std::vector<std::string> & tokenList, const char* token = ",");
                
                  /*! Returns true if a parameter name is a valid Muemex custom level variable, e.g. "MultiVector myArray"
                  */
                  bool IsParamMuemexVariable(const std::string& name);
                
                #ifdef HAVE_MUELU_EPETRA
                  /*! \fn EpetraCrs_To_XpetraMatrix
                      @brief Helper function to convert a Epetra::CrsMatrix to an Xpetra::Matrix
                      TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  EpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Epetra_CrsMatrix>& A) {
                    typedef Xpetra::EpetraCrsMatrixT<GlobalOrdinal, Node>                      XECrsMatrix;
                    typedef Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>       XCrsMatrix;
                    typedef Xpetra::CrsMatrixWrap<Scalar, LocalOrdinal, GlobalOrdinal, Node>   XCrsMatrixWrap;
                
                    RCP<XCrsMatrix> Atmp = rcp(new XECrsMatrix(A));
                    return rcp(new XCrsMatrixWrap(Atmp));
                  }
                
                  /*! \fn EpetraMultiVector_To_XpetraMultiVector
                    @brief Helper function to convert a Epetra::MultiVector to an Xpetra::MultiVector
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  EpetraMultiVector_To_XpetraMultiVector(const Teuchos::RCP<Epetra_MultiVector>& V) {
                    return rcp(new Xpetra::EpetraMultiVectorT<GlobalOrdinal, Node>(V));
                  }
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                  /*! \fn TpetraCrs_To_XpetraMatrix
                    @brief Helper function to convert a Tpetra::CrsMatrix to an Xpetra::Matrix
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
           1 ->   TpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& Atpetra) {
                    typedef Xpetra::TpetraCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> XTCrsMatrix;
                    typedef Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>       XCrsMatrix;
                    typedef Xpetra::CrsMatrixWrap<Scalar, LocalOrdinal, GlobalOrdinal, Node>   XCrsMatrixWrap;
                
                    RCP<XCrsMatrix> Atmp = rcp(new XTCrsMatrix(Atpetra));
                    return rcp(new XCrsMatrixWrap(Atmp));
                  }
                
                  /*! \fn TpetraMultiVector_To_XpetraMultiVector
                    @brief Helper function to convert a Tpetra::MultiVector to an Xpetra::MultiVector
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
       ##### ->   TpetraMultiVector_To_XpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& Vtpetra) {
                    return rcp(new Xpetra::TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>(Vtpetra));
                  }
                #endif
                
                  //! Little helper function to convert non-string types to strings
                  template<class T>
                  std::string toString(const T& what) {
                    std::ostringstream buf;
                    buf << what;
                    return buf.str();
                  }
                
                #ifdef HAVE_MUELU_EPETRA
                  /*! \fn EpetraCrs_To_XpetraMatrix
                    @brief Helper function to convert a Epetra::CrsMatrix to an Xpetra::Matrix
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  EpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Epetra_CrsMatrix>& A);
                
                  /*! \fn EpetraMultiVector_To_XpetraMultiVector
                    @brief Helper function to convert a Epetra::MultiVector to an Xpetra::MultiVector
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  EpetraMultiVector_To_XpetraMultiVector(const Teuchos::RCP<Epetra_MultiVector>& V);
                #endif
                
                #ifdef HAVE_MUELU_TPETRA
                  /*! \fn TpetraCrs_To_XpetraMatrix
                    @brief Helper function to convert a Tpetra::CrsMatrix to an Xpetra::Matrix
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  TpetraCrs_To_XpetraMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& Atpetra);
                
                  /*! \fn TpetraMultiVector_To_XpetraMultiVector
                    @brief Helper function to convert a Tpetra::MultiVector to an Xpetra::MultiVector
                    TODO move this function to an Xpetra utility file
                    */
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >
                  TpetraMultiVector_To_XpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> >& Vtpetra);
                #endif
                
                } //namespace MueLu
                
                #define MUELU_UTILITIES_SHORT
                #endif // MUELU_UTILITIES_DECL_HPP


Top 10 Lines:

     Line      Count

      881          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
                      struct _Vector_impl 
                      : public _Tp_alloc_type
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
                	_Vector_impl()
                	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
                	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a)),
                	  _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                #endif
                
                	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
                	{
                	  std::swap(_M_start, __x._M_start);
                	  std::swap(_M_finish, __x._M_finish);
                	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
                	}
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
                      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
                      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                      _Vector_base()
                      : _M_impl() { }
                
                      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                
                      _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x) noexcept
                      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_swap_data(__x._M_impl); }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                #endif
                
                      ~_Vector_base() _GLIBCXX_NOEXCEPT
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
                      _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : 0;
                      }
                
                      void
                      _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    private:
                      void
                      _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Base::pointer                    pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
                      vector()
                #if __cplusplus >= 201103L
                      noexcept(is_nothrow_default_constructible<_Alloc>::value)
                #endif
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
           7 ->       vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a __x.  All the elements of @a __x are copied,
                       *  but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.
                       */
       ##### ->       vector(const vector& __x)
                      : _Base(__x.size(),
                        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %vector.
                       */
                      vector(vector&& __x) noexcept
                      : _Base(std::move(__x)) { }
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept(_Alloc_traits::_S_always_equal())
                      : _Base(std::move(__rv), __m)
                      {
                	if (__rv.get_allocator() != __m)
                	  {
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
                      vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        { _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
          10 ->       ~vector() _GLIBCXX_NOEXCEPT
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  @a __x is a valid, but unspecified %vector.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                        constexpr bool __move_storage =
                          _Alloc_traits::_S_propagate_on_move_assign()
                          || _Alloc_traits::_S_always_equal();
                        _M_move_assign(std::move(__x),
                                       integral_constant<bool, __move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        { _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
           1 ->       resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
       ##### ->       resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      { return *(this->_M_impl._M_start + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      { return *(this->_M_impl._M_start + __n); }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front() _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                #if __cplusplus >= 201103L
                      _Tp*
                #else
                      pointer
                #endif
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                #if __cplusplus >= 201103L
                      const _Tp*
                #else
                      const_pointer
                #endif
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
                      push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                	                             __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                #if __cplusplus >= 201103L
                	  _M_emplace_back_aux(__x);
                #else
                	  _M_insert_aux(end(), __x);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(const_iterator __position, _Args&&... __args);
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the 
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      { return this->insert(__position, __l.begin(), __l.end()); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        iterator
                        insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                #if __cplusplus >= 201103L
                      noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      {
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                	                          __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                        pointer
                        _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	    emplace_back(*__first);
                #else
                	    push_back(*__first);
                #endif
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, 
                				      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, 
                					 _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        { _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      // Called by insert(p,x)
                #if __cplusplus < 201103L
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                #else
                      template<typename... _Args>
                        void
                        _M_insert_aux(iterator __position, _Args&&... __args);
                
                      template<typename... _Args>
                        void
                        _M_emplace_back_aux(_Args&&... __args);
                #endif
                
                      // Called by the latter.
                      size_type
                      _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
                      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                	this->_M_impl._M_finish = __pos;
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, std::true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__tmp._M_impl);
                	this->_M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, std::false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), std::true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__addressof(*__ptr); }
                #else
                      template<typename _Ptr>
                	_Ptr
                	_M_data_ptr(_Ptr __ptr) const
                	{ return __ptr; }
                #endif
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

      423         10
      277          7
      673          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

       18   Total number of line executions
     3.60   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_FancyOStream.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_FANCY_O_STREAM_HPP
                #define TEUCHOS_FANCY_O_STREAM_HPP
                
                #include "Teuchos_RCP.hpp"
                #include "Teuchos_GlobalMPISession.hpp"
                #include "Teuchos_oblackholestream.hpp"
                #include "Teuchos_as.hpp"
                
                
                namespace Teuchos {
                
                
                /** \brief Stream buffering class that performs the magic of indenting
                 * data sent to an std::ostream object.
                 *
                 * \ingroup teuchos_outputting_grp
                 *
                 * Note, this is not a user-level class.  Users should use
                 * <tt>basic_FancyOStream</tt>.
                 */
                template<typename CharT, typename Traits>
       ##### -> class basic_FancyOStream_buf : public std::basic_streambuf<CharT,Traits>
                {
                public:
                
                  /** \brief . */
                  typedef CharT char_type;
                  /** \brief . */
                  typedef Traits                                         traits_type;
                  /** \brief . */
                  typedef typename traits_type::int_type                int_type;
                  /** \brief . */
                  typedef typename traits_type::pos_type                pos_type;
                  /** \brief . */
                  typedef typename traits_type::off_type                off_type;
                
                  /** \brief . */
                  basic_FancyOStream_buf(
                    const RCP<std::basic_ostream<char_type,traits_type> > &oStream
                    ,const std::basic_string<char_type,traits_type> &tabIndentStr
                    ,const int startingTab
                    ,const bool showLinePrefix
                    ,const int maxLenLinePrefix
                    ,const bool showTabCount
                    ,const bool showProcRank
                    );
                
                  /** \brief . */
                  void initialize(
                    const RCP<std::basic_ostream<char_type,traits_type> > &oStream
                    ,const std::basic_string<char_type,traits_type> &tabIndentStr
                    ,const int startingTab
                    ,const bool showLinePrefix
                    ,const int maxLenLinePrefix
                    ,const bool showTabCount
                    ,const bool showProcRank
                    );
                
                  /** \brief . */
                  RCP<std::basic_ostream<char_type,traits_type> > getOStream();
                
                  /** \brief . */
                  void setTabIndentStr(const std::basic_string<char_type,traits_type> &tabIndentStr);
                
                  /** \brief . */
                  const std::basic_string<char_type,traits_type>& getTabIndentStr() const;
                
                  /** \brief .*/
                  void setShowLinePrefix(const bool showLinePrefix);
                
                  /** \brief .*/
                  bool getShowLinePrefix() const;
                
                  /** \brief .*/
                  void setMaxLenLinePrefix(const int maxLenLinePrefix);
                
                  /** \brief .*/
                  int getMaxLenLinePrefix() const;
                
                  /** \brief . */
                  void setShowTabCount(const bool showTabCount);
                
                  /** \brief . */
                  bool getShowTabCount() const;
                
                  /** \brief . */
                  void setShowProcRank(const bool showProcRank);
                
                  /** \brief . */
                  bool getShowProcRank() const;
                
                  /// \brief Set the (MPI) process rank and the number of processes in the communicator.
                  ///
                  /// \param procRank [in] The rank of the calling process.
                  /// \param numProcs [in] The number of processes in the communicator.
                  ///
                  /// You must call this method before you may call setOutputToRootOnly().
                  void setProcRankAndSize( const int procRank, const int numProcs );
                
                  /// \brief Get the rank of the calling (MPI) process.
                  ///
                  /// \pre The calling process rank and the number of processes in the
                  ///   communicator were set via a call to setProcRankAndSize().
                  int getProcRank() const;
                
                  /// \brief Get the number of processes in the communicator.
                  ///
                  /// \pre The calling process rank and the number of processes in the
                  ///   communicator were set via a call to setProcRankAndSize().
                  int getNumProcs() const;
                
                  /// \brief Set the stream to print only on the (MPI) process with the given rank.
                  ///
                  /// \pre The calling process rank and the number of processes in the
                  ///   communicator were set via a call to setProcRankAndSize().
                  ///
                  /// \param rootRank [in] The rank of the process on which to print.
                  ///   The convention is to use Process 0 as the "root" process, but
                  ///   this is not required.
                  ///
                  /// \warning The effect of this method is currently irreversible.
                  ///   This commits downstream users of this output stream to the
                  ///   same assignment of ranks to processes.  The result of calling
                  ///   setProcRankAndSize() after this method has been called is
                  ///   undefined.  It will likely have no effect.
                  void setOutputToRootOnly( const int rootRank );
                
                  /** \brief . */
                  int getOutputToRootOnly() const;
                
                  /// \brief Push one or more tabs.
                  ///
                  /// Users should generally not call this method directly.  It is
                  /// better to use OSTab to automate the process.  OSTab's
                  /// constructor calls pushTab() for you.  It also calls popTab()
                  /// automatically on scope exit, whether the scope was exited
                  /// normally or by an exception throw.  This "puts things back how
                  /// you found them."
                  void pushTab(const int tabs);
                
                  /** \brief . */
                  int getNumCurrTabs() const;
                
                  /// \brief Pop the current tab.
                  ///
                  /// Users should generally not call this method directly.  It is
                  /// better to use OSTab to automate the process.  OSTab calls
                  /// popTab() automatically on scope exit, whether the scope was
                  /// exited normally or by an exception throw.  This "puts things
                  /// back how you found them."
                  void popTab();
                
                  /** \brief . */
                  void pushLinePrefix(
                    const std::basic_string<char_type,traits_type> &linePrefix
                    );
                
                  /** \brief . */
                  void popLinePrefix();
                
                  /** \brief . */
                  const std::basic_string<char_type,traits_type>& getTopLinePrefix() const;
                
                  /** \brief . */
                  void pushDisableTabbing();
                
                  /** \brief . */
                  void popDisableTabbing();
                
                protected:
                
                  //! @name Protected overridden functions from std::basic_streambuf
                  //@{
                
                  /** \brief . */
                  std::streamsize xsputn(const char_type* s, std::streamsize n);
                
                  /** \brief . */
                  int_type overflow(int_type c);
                
                #ifdef TEUCHOS_FANCY_OSTREAM_SHOW_ALL_CALLS
                
                  void imbue(const locale& l)
                    {
                      std::cerr << "\ncalled imbue()\n";
                      std::basic_streambuf<CharT,Traits>::imbue(l);
                    }
                
                  basic_streambuf<char_type,Traits>*
                  setbuf(char_type* s, streamsize n)
                    {
                      std::cerr << "\ncalled setbuf()\n";
                      return std::basic_streambuf<CharT,Traits>::setbuf(s,n);
                    }
                
                  pos_type
                  seekoff(off_type a, ios_base::seekdir b,ios_base::openmode c)
                    {
                      std::cerr << "\ncalled seekoff()\n";
                      return std::basic_streambuf<CharT,Traits>::seekoff(a,b,c);
                    }
                
                  pos_type
                  seekpos(pos_type a, ios_base::openmode b)
                    {
                      std::cerr << "\ncalled seekpos()\n";
                      return std::basic_streambuf<CharT,Traits>::seekpos(a,b);
                    }
                
                  int
                  sync()
                    {
                      std::cerr << "\ncalled sync()\n";
                      return std::basic_streambuf<CharT,Traits>::sync();
                    }
                
                  streamsize
                  showmanyc()
                    {
                      std::cerr << "\ncalled showmanyc()\n";
                      return std::basic_streambuf<CharT,Traits>::showmanyc();
                    }
                
                  streamsize
                  xsgetn(char_type* s, streamsize n)
                    {
                      std::cerr << "\ncalled xsgetn()\n";
                      return std::basic_streambuf<CharT,Traits>::xsgetn(s,n);
                    }
                
                  int_type
                  underflow()
                    {
                      std::cerr << "\ncalled underflow()\n";
                      return std::basic_streambuf<CharT,Traits>::underflow();
                    }
                
                  int_type
                  uflow()
                    {
                      std::cerr << "\ncalled uflow()\n";
                      return std::basic_streambuf<CharT,Traits>::uflow();
                    }
                
                  int_type
                  pbackfail(int_type c = traits_type::eof())
                    {
                      std::cerr << "\ncalled pbackfail()\n";
                      return std::basic_streambuf<CharT,Traits>::pbackfail(c);
                    }
                
                #endif // TEUCHOS_FANCY_OSTREAM_SHOW_ALL_CALLS
                
                  //@}
                
                private:
                
                  // ////////////////////////
                  // Private types
                
                  typedef std::basic_string<char_type,traits_type> string_t;
                  typedef std::deque<int> tabIndentStack_t;
                  typedef std::deque<string_t> linePrefixStack_t;
                
                  // ////////////////////////
                  // Private data members
                
                  RCP<std::basic_ostream<char_type,traits_type> > oStreamSet_;
                  RCP<std::basic_ostream<char_type,traits_type> > oStream_;
                  std::basic_string<char_type,traits_type> tabIndentStr_;
                  bool showLinePrefix_;
                  int maxLenLinePrefix_;
                  bool showTabCount_;
                  bool showProcRank_;
                  int rootRank_;
                  int procRank_;
                  int numProcs_;
                  int rankPrintWidth_;
                
                  RCP<std::ostringstream> lineOut_;
                
                  int tabIndent_;
                  tabIndentStack_t tabIndentStack_;
                  linePrefixStack_t linePrefixStack_;
                  int enableTabbingStack_;
                
                  bool wroteNewline_;
                
                  // ////////////////////////
                  // Private member functions
                
                  std::ostream& out();
                
                  void writeChars( const char_type s[], std::streamsize n );
                
                  void writeFrontMatter();
                
                  // Not defined and not to be called
                  basic_FancyOStream_buf();
                  basic_FancyOStream_buf(const basic_FancyOStream_buf<CharT,Traits>&);
                  basic_FancyOStream_buf<CharT,Traits> operator=(
                    const basic_FancyOStream_buf<CharT,Traits>&
                    );
                
                };
                
                
                /** \brief std::ostream subclass that performs the magic of indenting data
                 * sent to an std::ostream object among other things.
                 *
                 * Use the typedef <tt>FancyOStream</tt> for support for the <tt>char</tt>
                 * character type.
                 *
                 * Indentation of the stream is accomplished through creating
                 * <tt>basic_OSTab</tt> objects.
                 *
                 * In addition to indenting output, this stream object can also print various
                 * types of information at the beginning of each line. The type of information
                 * supported is:
                 * <ul>
                 * <li> (MPI) process rank: Set using <tt>setShowProcRank()</tt>.
                 * <li> Line prefix name: Set using <tt>showLinePrefix()</tt> and <tt>OSTab::OSTab()</tt>.
                 * <li> Tab counts (useful for debugging): Set using <tt>setShowTabCount()</tt>.
                 * </ul>
                 *
                 * See <tt>FancyOutputting_test.cpp</tt> for examples of how this class is
                 * used and the output it generates.
                 */
                template <typename CharT, typename Traits = std::char_traits<CharT> >
           5 -> class basic_FancyOStream : public std::basic_ostream<CharT, Traits>
                {
                public:
                
                  //! @name Public types
                  //@{
                
                  /** \brief . */
                  typedef CharT char_type;
                  /** \brief . */
                  typedef Traits traits_type;
                  /** \brief . */
                  typedef typename traits_type::int_type int_type;
                  /** \brief . */
                  typedef typename traits_type::pos_type pos_type;
                  /** \brief . */
                  typedef typename traits_type::off_type off_type;
                  /** \brief . */
                
                  /** \brief . */
                  typedef basic_FancyOStream_buf<CharT,Traits> streambuf_t;
                  /** \brief . */
                  typedef std::basic_ostream<char_type, traits_type> ostream_t;
                
                  //@}
                
                  //! @name Public client functions
                  //@{
                
                  /// \brief Constructor.
                  ///
                  /// \param oStream [in/out] Output stream to wrap.
                  /// \param tabIndentStr [in] String to use as a prefix for each tab
                  ///   level.  Default is a single space (per tab level).
                  /// \param startingTab [in] Starting tab level.  Default is 0.
                  /// \param showLinePrefix [in] Whether to show the line prefix.
                  ///   (This does not include the tab indent string.  Tabs will
                  ///   indent regardless.)
                  /// \param maxLenLinePrefix [in] Maximum number of characters in the
                  ///   line prefix.  (This does not include the tab indent string.)
                  /// \param showTabCount [in] Whether to show the tab count in front
                  ///   of each line of text.
                  /// \param showProcRank [in] Whether to print the rank of the
                  ///   calling (MPI) process in front of each line of text.  If you
                  ///   set this to true, you <i>must</i> call setProcRankAndSize()
                  ///   before printing to this output stream, or the process rank
                  ///   will not be defined.
                  ///
                  /// The following things are called "front matter":
                  ///   - Rank of the calling (MPI) process
                  ///   - Line prefix
                  ///   - Tab count
                  ///
                  /// This object may print any or all of these things in front of
                  /// each line.  (Delimit each line by using <tt>std::endl</tt>, not
                  /// with "\n".  The latter is not portable in any case!)  You may
                  /// control which of these get printed by the corresponding Boolean
                  /// argument of this constructor.
                  explicit
                  basic_FancyOStream(
                    const RCP< std::basic_ostream<char_type,traits_type> > &oStream
                    ,const std::basic_string<char_type,traits_type> &tabIndentStr = " "
                    ,const int startingTab = 0
                    ,const bool showLinePrefix = false
                    ,const int maxLenLinePrefix = 10
                    ,const bool showTabCount = false
                    ,const bool showProcRank = false
                    );
                
                  /// \brief Initialize the output stream.
                  ///
                  /// This takes the same arguments as the constructor.
                  void initialize(
                    const RCP< std::basic_ostream<char_type,traits_type> > &oStream
                    ,const std::basic_string<char_type,traits_type> &tabIndentStr = " "
                    ,const int startingTab = 0
                    ,const bool showLinePrefix = false
                    ,const int maxLenLinePrefix = 10
                    ,const bool showTabCount = false
                    ,const bool showProcRank = false
                    );
                
                  //! Get the output stream this object wraps.
                  RCP<std::basic_ostream<char_type,traits_type> > getOStream();
                
                  //! Set the tab indent string.
                  basic_FancyOStream& setTabIndentStr(
                    const std::basic_string<char_type,traits_type> &tabIndentStr
                    );
                
                  //! Get the tab indent string.
                  const std::basic_string<char_type,traits_type>& getTabIndentStr() const;
                
                  /// \brief Control whether this stream prints "front matter."
                  ///
                  /// "Front matter" includes the following things:
                  ///   - Rank of the calling (MPI) process
                  ///   - Line prefix
                  ///   - Tab count
                  ///
                  /// This object may print any or all of these things in front of
                  /// each line.  (Delimit each line by using <tt>std::endl</tt>, not
                  /// with "\n".  The latter is not portable in any case!)  You may
                  /// control <i>individually</i> which of these get printed by the
                  /// corresponding Boolean argument of this object's constructor.
                  /// You may also call this method to turn on or off printing of
                  /// <i>all</i> front matter.
                  basic_FancyOStream& setShowAllFrontMatter(const bool showAllFrontMatter);
                
                  /** \brief .*/
                  basic_FancyOStream& setShowLinePrefix(const bool showLinePrefix);
                
                  /** \brief .*/
                  basic_FancyOStream& setMaxLenLinePrefix(const int maxLenLinePrefix);
                
                  /** \brief . */
                  basic_FancyOStream& setShowTabCount(const bool showTabCount);
                
                  /** \brief . */
                  basic_FancyOStream& setShowProcRank(const bool showProcRank);
                
                  /// \brief Set the (MPI) process rank and the number of processes in the communicator.
                  ///
                  /// \param procRank [in] The rank of the calling process.
                  /// \param numProcs [in] The number of processes in the communicator.
                  ///
                  /// You must call this method before you may call setOutputToRootOnly().
                  basic_FancyOStream& setProcRankAndSize( const int procRank, const int numProcs );
                
                  /// \brief Set the stream to print only on the (MPI) process with the given rank.
                  ///
                  /// \pre The calling process rank and the number of processes in the
                  ///   communicator were set via a call to setProcRankAndSize().
                  ///
                  /// \param rootRank [in] The rank of the process on which to print.
                  ///   The convention is to use Process 0 as the "root" process, but
                  ///   this is not required.
                  ///
                  /// \warning The effect of this method is currently irreversible.
                  ///   This commits downstream users of this output stream to the
                  ///   same assignment of ranks to processes.  The result of calling
                  ///   setProcRankAndSize() after this method has been called is
                  ///   undefined.  It will likely have no effect.
                  basic_FancyOStream& setOutputToRootOnly( const int rootRank );
                
                  /** \brief . */
                  int getOutputToRootOnly() const;
                
                  /** \brief . */
                  void copyAllOutputOptions(const basic_FancyOStream<CharT,Traits> &oStream);
                
                  //@}
                
                  //! @name Functions designed to be used by basic_OSTab
                  //@{
                
                  /// \brief Push one or more tabs.
                  ///
                  /// Users should generally not call this method directly.  It is
                  /// better to use OSTab to automate the process.  OSTab's
                  /// constructor calls pushTab() for you.  It also calls popTab()
                  /// automatically on scope exit, whether the scope was exited
                  /// normally or by an exception throw.  This "puts things back how
                  /// you found them."
                  void pushTab(const int tabs = 1);
                
                  /** \brief . */
                  int getNumCurrTabs() const;
                
                  /// \brief Pop the current tab.
                  ///
                  /// Users should generally not call this method directly.  It is
                  /// better to use OSTab to automate the process.  OSTab calls
                  /// popTab() automatically on scope exit, whether the scope was
                  /// exited normally or by an exception throw.  This "puts things
                  /// back how you found them."
                  void popTab();
                
                  /** \brief . */
                  void pushLinePrefix(const std::basic_string<char_type,traits_type> &linePrefix);
                
                  /** \brief . */
                  void popLinePrefix();
                
                  /** \brief . */
                  const std::basic_string<char_type,traits_type>& getTopLinePrefix() const;
                
                  /** \brief . */
                  void pushDisableTabbing();
                
                  /** \brief . */
                  void popDisableTabbing();
                
                  //@}
                
                private:
                
                  streambuf_t   streambuf_;
                
                  // Not defined and not to be called
                  basic_FancyOStream();
                  basic_FancyOStream(const basic_FancyOStream<CharT,Traits>&);
                  basic_FancyOStream<CharT,Traits> operator=(const basic_FancyOStream<CharT,Traits>&);
                
                };
                
                
                /** \brief Dynamically allocate a FancyOStream and return it wrapped in an RCP
                 * object.
                 *
                 * Returns a <tt>null</tt> object if the input stream is null.
                 *
                 * \relates basic_FancyOStream
                 */
                inline
                RCP<basic_FancyOStream<char> >
                fancyOStream(
                  const RCP< std::basic_ostream<char> >& oStream,
                  const std::basic_string<char>& tabIndentStr = " ",
                  const int startingTab = 0,
                  const bool showLinePrefix = false,
                  const int maxLenLinePrefix = 10,
                  const bool showTabCount = false,
                  const bool showProcRank = false
                  )
                {
                  if (nonnull(oStream)) {
                    return rcp(
                      new basic_FancyOStream<char>(
                        oStream,tabIndentStr,startingTab,showLinePrefix,
                        maxLenLinePrefix,showTabCount,showProcRank
                        )
                      );
                  }
                  return null;
                }
                
                
                /** \brief Get a FancyOStream from an std::ostream object.
                 *
                 * If the object already is a FancyOStream, then nothing has to be done.
                 * Otherwise, a temp FancyOStream is created for this purpose. If
                 * <tt>out.get()==NULL</tt> then <tt>return.get()==NULL</tt> on return also!
                 *
                 * \relates basic_FancyOStream
                 */
                inline
                RCP<basic_FancyOStream<char> >
                getFancyOStream( const RCP<std::basic_ostream<char> > &out )
           3 -> {
                  if (is_null(out))
                    return Teuchos::null;
                  RCP<basic_FancyOStream<char> >
                    fancyOut = rcp_dynamic_cast<basic_FancyOStream<char> >(out);
                  if(nonnull(fancyOut))
                    return fancyOut;
                  return rcp(new basic_FancyOStream<char>(out));
                }
                
                
                /** \brief Tabbing class for helping to create formated, indented output for a
                 * <tt>basic_FancyOStream</tt> object.
                 *
                 * Use the typedef <tt>OSStream</tt> for support for the <tt>char</tt>
                 * character type.
                 *
                 * This class is used to create tab indents and set line prefix names for
                 * output that is generated by a <tt>basic_FancyOStream</tt> object.
                 *
                 * \relates basic_FancyOStream
                 */
                template <typename CharT, typename Traits = std::char_traits<CharT> >
                class basic_OSTab
                {
                public:
                
                  /** \brief . */
                  static const int DISABLE_TABBING = -99999; // This magic number should be just fine!
                  /** \brief. */
                  basic_OSTab(
                    const RCP<basic_FancyOStream<CharT,Traits> > &fancyOStream
                    ,const int tabs = 1
                    ,const std::basic_string<CharT,Traits> linePrefix = ""
                    )
                    :fancyOStream_(fancyOStream)
                    ,tabs_(tabs)
                    ,linePrefix_(linePrefix)
                    {
                      updateState();
                    }
                  /** \brief. */
                  basic_OSTab(
                    const RCP<std::basic_ostream<CharT,Traits> > &oStream
                    ,const int tabs = 1
                    ,const std::basic_string<CharT,Traits> linePrefix = ""
                    )
                    :fancyOStream_(getFancyOStream(oStream))
                    ,tabs_(tabs)
                    ,linePrefix_(linePrefix)
                    {
                      updateState();
                    }
                  /** \brief Warning: Only call this constructor for stack-based object. */
                  basic_OSTab(
                    basic_FancyOStream<CharT,Traits> &fancyOStream
                    ,const int tabs = 1
                    ,const std::basic_string<CharT,Traits> linePrefix = ""
                    )
                    :fancyOStream_(rcp(&fancyOStream,false))
                    ,tabs_(tabs)
                    ,linePrefix_(linePrefix)
                    {
                      updateState();
                    }
                  /** \brief Warning: Only call this constructor for stack-based object. */
                  basic_OSTab(
                    std::basic_ostream<CharT,Traits> &oStream
                    ,const int tabs = 1
                    ,const std::basic_string<CharT,Traits> linePrefix = ""
                    )
                    :fancyOStream_(getFancyOStream(rcp(&oStream, false)))
                    ,tabs_(tabs)
                    ,linePrefix_(linePrefix)
                    {
                      updateState();
                    }
                  /** \brief. */
                  basic_OSTab( const basic_OSTab &osTab )
                    :fancyOStream_(osTab.fancyOStream_)
                    ,tabs_(osTab.tabs_)
                    {
                      updateState();
                    }
                  /** \brief. */
          24 ->   ~basic_OSTab()
                    {
                      if(fancyOStream_.get()) {
                        if(tabs_==DISABLE_TABBING)
                          fancyOStream_->popDisableTabbing();
                        else
                          fancyOStream_->popTab();
                        if(linePrefix_.length()) fancyOStream_->popLinePrefix();
                      }
                    }
                  /** \brief. */
                  basic_OSTab<CharT,Traits>& operator=( const basic_OSTab &osTab )
                    {
                      fancyOStream_ = osTab.fancyOStream_;
                      tabs_ = osTab.tabs_;
                      updateState();
                      return *this;
                    }
                  /** \brief. */
                  basic_OSTab<CharT,Traits>& incrTab(const int tabs = 1)
                    {
                      tabs_ += tabs;
                      if(fancyOStream_.get()) {
                        fancyOStream_->popTab();
                        fancyOStream_->pushTab(tabs_);
                      }
                      return *this;
                    }
                  /** \brief. */
                  basic_FancyOStream<CharT,Traits>& o() const
                    {
                      return *fancyOStream_;
                    }
                  /** \brief. */
                  basic_FancyOStream<CharT,Traits>* get() const
                    {
                      return fancyOStream_.get();
                    }
                
                private:
                
                  RCP<basic_FancyOStream<CharT,Traits> > fancyOStream_;
                  int tabs_;
                  std::basic_string<CharT,Traits> linePrefix_;
                
                  void updateState()
                    {
                      if(fancyOStream_.get()) {
                        if(tabs_==DISABLE_TABBING)
                          fancyOStream_->pushDisableTabbing();
                        else
                          fancyOStream_->pushTab(tabs_);
                        if(linePrefix_.length()) fancyOStream_->pushLinePrefix(linePrefix_);
                      }
                    }
                
                };
                
                
                /** \brief Create a tab for an RCP-wrapped <tt>basic_FancyOStream</tt> object
                 * to cause the indentation of all output automatically!.
                 *
                 * This function returns an RCP object to a <tt>basic_FancyOStream</tt> object
                 * that has its tab indented by one.  If the input <tt>*out</tt> object is
                 * already a <tt>%basic_FancyOStream</tt> object, then that object is used as
                 * is.  If the <tt>*out</tt> object is not a <tt>%basic_FancyOStream</tt>
                 * object, then a new <tt>%basic_FancyOStream</tt> object is created and its
                 * tab is set!"
                 *
                 * In any case, when the returned RCP object is destroyed, the tab will be
                 * removed automatically!
                 *
                 * \relates basic_FancyOStream
                 */
                template <typename CharT, typename Traits>
                RCP<basic_FancyOStream<CharT,Traits> >
                tab(
                  const RCP<basic_FancyOStream<CharT,Traits> > &out,
                  const int tabs = 1,
                  const std::basic_string<CharT,Traits> linePrefix = ""
                  )
                {
                  if(out.get()==NULL)
                    return Teuchos::null;
                  RCP<basic_FancyOStream<CharT,Traits> > fancyOut = out;
                  set_extra_data(
                    rcp(new basic_OSTab<CharT,Traits>(out,tabs,linePrefix)),
                    "OSTab",
                    inOutArg(fancyOut),
                    PRE_DESTROY,
                    false
                    );
                  return fancyOut;
                }
                
                
                /** \brief Create a tab for an RCP-wrapped <tt>std:: std::ostream</tt> object
                 * to cause the indentation of all output automatically!.
                 *
                 * This function returns an RCP object to a <tt>basic_FancyOStream</tt> object
                 * that has its tab indented by one.  If the input <tt>*out</tt> object is
                 * already a <tt>%basic_FancyOStream</tt> object, then that object is used as
                 * is.  If the <tt>*out</tt> object is not a <tt>%basic_FancyOStream</tt>
                 * object, then a new <tt>%basic_FancyOStream</tt> object is created and its
                 * tab is set!"
                 *
                 * In any case, when the returned RCP object is destroyed, the tab will be
                 * removed automatically!
                 *
                 * \relates basic_FancyOStream
                 */
                template <typename CharT, typename Traits>
                RCP<basic_FancyOStream<CharT,Traits> >
                tab(
                  const RCP<std::basic_ostream<CharT,Traits> > &out
                  ,const int tabs = 1
                  ,const std::basic_string<CharT,Traits> linePrefix = ""
                  )
                {
                  return tab(getFancyOStream(out),tabs,linePrefix);
                }
                
                
                // ///////////////////////////////
                // Typedefs
                
                
                /** \brief .
                 * \ingroup teuchos_outputting_grp
                 */
                typedef basic_FancyOStream<char> FancyOStream;
                
                
                /** \brief .
                 * \ingroup teuchos_outputting_grp
                 */
                typedef basic_OSTab<char> OSTab;
                
                
                /** \brief .
                 * \ingroup teuchos_outputting_grp
                 */
                #define TEUCHOS_OSTAB ::Teuchos::OSTab __localThisTab = this->getOSTab()
                
                /** \brief .
                 * \ingroup teuchos_outputting_grp
                 */
                #define TEUCHOS_OSTAB_DIFF( DIFF ) ::Teuchos::OSTab DIFF ## __localThisTab = this->getOSTab()
                
                
                // ////////////////////////////////
                // Defintions
                
                
                //
                // basic_FancyOStream_buf
                //
                
                
                template<typename CharT, typename Traits>
           4 -> basic_FancyOStream_buf<CharT,Traits>::basic_FancyOStream_buf(
                  const RCP<std::basic_ostream<char_type,traits_type> > &oStream
                  ,const std::basic_string<char_type,traits_type> &tabIndentStr
                  ,const int startingTab
                  ,const bool showLinePrefix
                  ,const int maxLenLinePrefix
                  ,const bool showTabCount
                  ,const bool showProcRank
                  )
                {
                  this->initialize(oStream,tabIndentStr,startingTab,showLinePrefix,
                    maxLenLinePrefix,showTabCount,showProcRank);
                }
                
                
                template<typename CharT, typename Traits>
           5 -> void basic_FancyOStream_buf<CharT,Traits>::initialize(
                  const RCP<std::basic_ostream<char_type,traits_type> > &oStream
                  ,const std::basic_string<char_type,traits_type> &tabIndentStr
                  ,const int startingTab
                  ,const bool showLinePrefix
                  ,const int maxLenLinePrefix
                  ,const bool showTabCount
                  ,const bool showProcRank
                  )
                {
                  oStreamSet_ = oStream;
                  oStream_ = oStream;
                  tabIndentStr_ = tabIndentStr;
                  showLinePrefix_ = showLinePrefix;
                  maxLenLinePrefix_ = maxLenLinePrefix;
                  showTabCount_ = showTabCount;
                  showProcRank_ = showProcRank;
                  rootRank_ = -1;
                  procRank_ = GlobalMPISession::getRank();
                  numProcs_ = GlobalMPISession::getNProc();
                  rankPrintWidth_ = int(std::log10(float(numProcs_)))+1;
                  tabIndent_ = startingTab;
                  tabIndentStack_.clear();
                  linePrefixStack_.clear();
                  wroteNewline_ = true;
                  enableTabbingStack_ = 0;
                }
                
                
                template<typename CharT, typename Traits>
                RCP<std::basic_ostream<CharT,Traits> >
                basic_FancyOStream_buf<CharT,Traits>::getOStream()
                {
                  return oStreamSet_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setTabIndentStr(
                  const std::basic_string<char_type,traits_type> &tabIndentStr
                  )
                {
                  tabIndentStr_ = tabIndentStr;
                }
                
                
                template<typename CharT, typename Traits>
                const std::basic_string<CharT,Traits>&
                basic_FancyOStream_buf<CharT,Traits>::getTabIndentStr() const
                {
                  return tabIndentStr_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setShowLinePrefix(const bool showLinePrefix)
                {
                  showLinePrefix_ = showLinePrefix;
                }
                
                
                template<typename CharT, typename Traits>
                bool basic_FancyOStream_buf<CharT,Traits>::getShowLinePrefix() const
                {
                  return showLinePrefix_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setMaxLenLinePrefix(const int maxLenLinePrefix)
                {
                  TEUCHOS_TEST_FOR_EXCEPT( !(maxLenLinePrefix>=5) );
                  maxLenLinePrefix_ = maxLenLinePrefix;
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream_buf<CharT,Traits>::getMaxLenLinePrefix() const
                {
                  return maxLenLinePrefix_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setShowTabCount(const bool showTabCount)
                {
                  showTabCount_ = showTabCount;
                }
                
                
                template<typename CharT, typename Traits>
                bool basic_FancyOStream_buf<CharT,Traits>::getShowTabCount() const
                {
                  return showTabCount_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setShowProcRank(const bool showProcRank)
                {
                  showProcRank_ = showProcRank;
                }
                
                
                template<typename CharT, typename Traits>
                bool basic_FancyOStream_buf<CharT,Traits>::getShowProcRank() const
                {
                  return showProcRank_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setProcRankAndSize(
                  const int procRank, const int numProcs
                  )
                {
                  procRank_ = procRank;
                  numProcs_ = numProcs;
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream_buf<CharT,Traits>::getProcRank() const
                {
                  return procRank_;
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream_buf<CharT,Traits>::getNumProcs() const
                {
                  return numProcs_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::setOutputToRootOnly(
                  const int rootRank
                  )
                {
                  rootRank_ = rootRank;
                  if(rootRank >= 0) {
                    if(rootRank == procRank_)
                      oStream_ = oStreamSet_;
                    else
                      oStream_ = rcp(new oblackholestream());
                    // Only processor is being output to so there is no need for line
                    // batching!
                    lineOut_ = null;
                  }
                  else {
                    oStream_ = oStreamSet_;
                    // Output is being sent to all processors so we need line batching to
                    // insure that each line will be printed all together!
                    lineOut_ = rcp(new std::ostringstream());
                  }
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream_buf<CharT,Traits>::getOutputToRootOnly() const
                {
                  return rootRank_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::pushTab(const int tabs)
                {
                  if( tabIndent_ + tabs < 0 ) {
                    tabIndentStack_.push_back(-tabIndent_);
                    tabIndent_ = 0;
                  }
                  else {
                    tabIndentStack_.push_back(tabs);
                    tabIndent_ += tabs;
                  }
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream_buf<CharT,Traits>::getNumCurrTabs() const
                {
                  return tabIndent_;
                }
                
                
                template<typename CharT, typename Traits>
       ##### -> void basic_FancyOStream_buf<CharT,Traits>::popTab()
                {
                  tabIndent_ -= tabIndentStack_.back();
                  tabIndentStack_.pop_back();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::pushLinePrefix(
                  const std::basic_string<char_type,traits_type> &linePrefix
                  )
                {
                  linePrefixStack_.push_back(linePrefix);
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::popLinePrefix()
                {
                  linePrefixStack_.pop_back();
                }
                
                
                template<typename CharT, typename Traits>
                const std::basic_string<CharT,Traits>&
                basic_FancyOStream_buf<CharT,Traits>::getTopLinePrefix() const
                {
                  return linePrefixStack_.back();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::pushDisableTabbing()
                {
                  ++enableTabbingStack_;
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream_buf<CharT,Traits>::popDisableTabbing()
                {
                  --enableTabbingStack_;
                }
                
                
                // protected
                
                
                template<typename CharT, typename Traits>
       ##### -> std::streamsize basic_FancyOStream_buf<CharT,Traits>::xsputn(
                  const char_type* s, std::streamsize n
                  )
                {
                #ifdef TEUCHOS_FANCY_OSTREAM_SHOW_ALL_CALLS
                  std::cerr << "\ncalled xsputn()\n";
                #endif
                  writeChars(s,n);
                  return n;
                }
                
                
                template<typename CharT, typename Traits>
                typename basic_FancyOStream_buf<CharT,Traits>::int_type
       ##### -> basic_FancyOStream_buf<CharT,Traits>::overflow(int_type c)
                {
                #ifdef TEUCHOS_FANCY_OSTREAM_SHOW_ALL_CALLS
                  std::cerr << "\ncalled overflow()\n";
                #endif
                  if(c != traits_type::eof()) {
                    const char_type cc[] = { traits_type::to_char_type(c) };
                    this->writeChars(cc,1);
                  }
                  return traits_type::not_eof(c);
                  //return std::basic_streambuf<CharT,Traits>::overflow(c);
                }
                
                
                // private
                
                
                template<typename CharT, typename Traits>
                std::ostream& basic_FancyOStream_buf<CharT,Traits>::out()
                {
                  if(lineOut_.get())
                    return *lineOut_;
                  return *oStream_;
                }
                
                
                template<typename CharT, typename Traits>
         144 -> void basic_FancyOStream_buf<CharT,Traits>::writeChars(
                  const char_type s[], std::streamsize n
                  )
                {
                  if(n == 0) return;
                  std::streamsize p = 0, first_p = 0;
                  bool done_outputting = false;
                  const char_type newline = '\n';
                  while( !done_outputting ) {
                    // Find the next newline
                    for( p = first_p; p < n; ++p ) {
                      if(s[p] == newline) {
                        break;
                      }
                    }
                    if(p == n) {
                      // We did not find a newline at the end!
                      --p;
                      done_outputting = true;
                    }
                    else if( p == n-1 && s[p] == newline ) {
                      // The last character in the std::string is a newline
                      done_outputting = true;
                    }
                    // Write the beginning of the line if we need to
                    if(wroteNewline_) {
                      writeFrontMatter();
                      wroteNewline_ = false;
                    }
                    // Write up to the newline or the end of the std::string
                    out().write(s+first_p,p-first_p+1);
                    if(s[p] == newline) {
                      wroteNewline_ = true;
                      if(lineOut_.get()) {
                        *oStream_ << lineOut_->str() << std::flush;
                        lineOut_->str("");
                      }
                    }
                    // Update for next search
                    if(!done_outputting)
                      first_p = p+1;
                  }
                }
                
                
                template<typename CharT, typename Traits>
          37 -> void basic_FancyOStream_buf<CharT,Traits>::writeFrontMatter()
                {
                  bool didOutput = false;
                  std::ostream &o = this->out();
                  if(showProcRank_) {
                    o << "p=" << std::right << std::setw(rankPrintWidth_) << procRank_;
                    didOutput = true;
                  }
                  if(showLinePrefix_) {
                    if(didOutput)
                      o << ", ";
                    std::string currLinePrefix = "";
                    if ( linePrefixStack_.size() )
                      currLinePrefix = this->getTopLinePrefix();
                    const int localMaxLenLinePrefix =
                      TEUCHOS_MAX( as<int>(currLinePrefix.length()), maxLenLinePrefix_ );
                    o << std::left << std::setw(localMaxLenLinePrefix);
                    o << currLinePrefix;
                    didOutput = true;
                  }
                  if(showTabCount_) {
                    if(didOutput)
                      o << ", ";
                    o << "tabs=" << std::right << std::setw(2) << tabIndent_;
                    didOutput = true;
                  }
                  // ToDo: Add the Prefix name if asked
                  // ToDo: Add the processor number if asked
                  // ToDo: Add the number of indents if asked
                  if(didOutput) {
                    o << " |" << tabIndentStr_;
                  }
                  if(enableTabbingStack_==0) {
                    for( int i = 0; i < tabIndent_; ++i )
                      o << tabIndentStr_;
                  }
                }
                
                
                //
                // basic_FancyOStream
                //
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>::basic_FancyOStream(
                  const RCP< std::basic_ostream<char_type,traits_type> > &oStream
                  ,const std::basic_string<char_type,traits_type> &tabIndentStr
                  ,const int startingTab
                  ,const bool showLinePrefix
                  ,const int maxLenLinePrefix
                  ,const bool showTabCount
                  ,const bool showProcRank
                  )
                  :ostream_t(NULL),
                   streambuf_(oStream,tabIndentStr,startingTab,showLinePrefix,
                     maxLenLinePrefix,showTabCount,showProcRank)
                {
                  this->init(&streambuf_);
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::initialize(
                  const RCP< std::basic_ostream<char_type,traits_type> > &oStream
                  ,const std::basic_string<char_type,traits_type> &tabIndentStr
                  ,const int startingTab
                  ,const bool showLinePrefix
                  ,const int maxLenLinePrefix
                  ,const bool showTabCount
                  ,const bool showProcRank
                  )
                {
                  streambuf_.initialize(oStream,tabIndentStr,startingTab,
                    showLinePrefix,maxLenLinePrefix,showTabCount,showProcRank);
                  this->init(&streambuf_);
                }
                
                
                template<typename CharT, typename Traits>
                RCP<std::basic_ostream<CharT,Traits> >
                basic_FancyOStream<CharT,Traits>::getOStream()
                {
                  return streambuf_.getOStream();
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setTabIndentStr(
                  const std::basic_string<char_type,traits_type> &tabIndentStr
                  )
                {
                  streambuf_.setTabIndentStr(tabIndentStr);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                const std::basic_string<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::getTabIndentStr() const
                {
                  return streambuf_.getTabIndentStr();
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setShowAllFrontMatter(
                  const bool showAllFrontMatter
                  )
                {
                  streambuf_.setShowLinePrefix(showAllFrontMatter);
                  streambuf_.setShowTabCount(showAllFrontMatter);
                  streambuf_.setShowProcRank(showAllFrontMatter);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setShowLinePrefix(const bool showLinePrefix)
                {
                  streambuf_.setShowLinePrefix(showLinePrefix);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setMaxLenLinePrefix(const int maxLenLinePrefix)
                {
                  streambuf_.setMaxLenLinePrefix(maxLenLinePrefix);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setShowTabCount(const bool showTabCount)
                {
                  streambuf_.setShowTabCount(showTabCount);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setShowProcRank(const bool showProcRank)
                {
                  streambuf_.setShowProcRank(showProcRank);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setProcRankAndSize( const int procRank, const int numProcs )
                {
                  streambuf_.setProcRankAndSize(procRank,numProcs);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                basic_FancyOStream<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::setOutputToRootOnly( const int rootRank )
                {
                  streambuf_.setOutputToRootOnly(rootRank);
                  return *this;
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream<CharT,Traits>::getOutputToRootOnly() const
                {
                  return streambuf_.getOutputToRootOnly();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::copyAllOutputOptions(
                  const basic_FancyOStream<CharT,Traits> &oStream )
                {
                  //streambuf_.setTabIndentStr(oStream.streambuf_.getTabIndentStr());
                  streambuf_.setShowLinePrefix(oStream.streambuf_.getShowLinePrefix());
                  streambuf_.setMaxLenLinePrefix(oStream.streambuf_.getMaxLenLinePrefix());
                  streambuf_.setShowTabCount(oStream.streambuf_.getShowTabCount());
                  streambuf_.setShowProcRank(oStream.streambuf_.getShowProcRank());
                  streambuf_.setProcRankAndSize(oStream.streambuf_.getProcRank(),
                    oStream.streambuf_.getNumProcs());
                  streambuf_.setOutputToRootOnly(oStream.streambuf_.getOutputToRootOnly());
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::pushTab(const int tabs)
                {
                  streambuf_.pushTab(tabs);
                }
                
                
                template<typename CharT, typename Traits>
                int basic_FancyOStream<CharT,Traits>::getNumCurrTabs() const
                {
                  return streambuf_.getNumCurrTabs();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::popTab()
                {
                  streambuf_.popTab();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::pushLinePrefix(
                  const std::basic_string<char_type,traits_type> &linePrefix
                  )
                {
                  streambuf_.pushLinePrefix(linePrefix);
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::popLinePrefix()
                {
                  streambuf_.popLinePrefix();
                }
                
                
                template<typename CharT, typename Traits>
                const std::basic_string<CharT,Traits>&
                basic_FancyOStream<CharT,Traits>::getTopLinePrefix() const
                {
                  return streambuf_.getTopLinePrefix();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::pushDisableTabbing()
                {
                  streambuf_.pushDisableTabbing();
                }
                
                
                template<typename CharT, typename Traits>
                void basic_FancyOStream<CharT,Traits>::popDisableTabbing()
                {
                  return streambuf_.popDisableTabbing();
                }
                
                
                } // namespace Teuchos
                
                
                #endif // TEUCHOS_FANCY_O_STREAM_HPP


Top 10 Lines:

     Line      Count

     1159        144
     1205         37
      705         24
      371          5
      881          5
      865          4
      620          3

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

      222   Total number of line executions
    20.18   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosStatusTestResNormOutput.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                //
                
                #ifndef BELOS_STATUS_TEST_RESNORM_OUTPUT_HPP
                #define BELOS_STATUS_TEST_RESNORM_OUTPUT_HPP
                
                /*!
                  \file BelosStatusTestResNormOutput.hpp
                  \brief Special StatusTest for printing status tests in simple format for residuals.
                */
                
                #include <vector>
                #include "BelosConfigDefs.hpp"
                #include "BelosTypes.hpp"
                #include "BelosIteration.hpp"
                
                #include "BelosStatusTest.hpp"
                #include "BelosStatusTestCombo.hpp"
                #include "BelosStatusTestMaxIters.hpp"
                #include "BelosStatusTestResNorm.hpp"
                #include "BelosStatusTestOutput.hpp"
                
                namespace Belos {
                
                  /*! 
                    \class StatusTestResNormOutput
                    \brief A special StatusTest for printing other status tests in a simple format. 
                    
                    StatusTestResNormOutput is a wrapper around an StatusTest that calls 
                    StatusTest::print() on the underlying object on calls to StatusTestResNormOutput::checkStatus().
                    The frequency and occasion of the printing can be dictated according to some parameters passed to 
                    StatusTestResNormOutput::StatusTestResNormOutput().
                  */
                template <class ScalarType, class MV, class OP>
                class StatusTestResNormOutput : public StatusTestOutput<ScalarType,MV,OP> {
                
                  typedef MultiVecTraits<ScalarType,MV> MVT;
                  typedef Belos::StatusTestCombo<ScalarType,MV,OP>  StatusTestCombo_t;
                  typedef Belos::StatusTestResNorm<ScalarType,MV,OP>  StatusTestResNorm_t;
                  typedef Belos::StatusTestMaxIters<ScalarType,MV,OP>  StatusTestMaxIters_t;
                
                 public:
                  //! @name Constructors/destructors
                  //@{ 
                
                  /*! \brief Constructor
                   *
                   * The StatusTestResNormOutput requires an OutputManager for printing the underlying StatusTest on
                   * calls to checkStatus(), as well as an underlying StatusTest.
                   *
                   * The last two parameters, described below, in addition to the verbosity level of the OutputManager, control when printing is 
                   * called. When both the \c mod criterion and the \c printStates criterion are satisfied, the status test will be printed to the 
                   * OutputManager with ::MsgType of ::StatusTestDetails.
                   *
                   * @param[in] test A reference-counted pointer to an object that combines Belos::StatusTestMaxIters and a set of Belos::StatusTestResNorm
                   * @param[in] mod A positive number describes how often the output should be printed. On every call to checkStatus(), an internal counter
                   *                is incremented. Printing may only occur when this counter is congruent to zero modulo \c mod. Default: 1 (attempt to print on every call to checkStatus())
                   * @param[in] printStates A combination of ::StatusType values for which the output may be printed. Default: ::Passed (attempt to print whenever checkStatus() will return ::Passed)
                   *
                   */
                  StatusTestResNormOutput(const Teuchos::RCP<OutputManager<ScalarType> > &printer, 
                			Teuchos::RCP<StatusTest<ScalarType,MV,OP> > test,
                			int mod = 1,
                			int printStates = Passed)
                    : printer_(printer), 
                      state_(Undefined), 
                      headerPrinted_(false),
                      stateTest_(printStates), 
                      modTest_(mod), 
                      lastNumIters_(-1),
                      comboType_(0),
                      numResTests_(0),
                      blockSize_(1),
                      currNumRHS_(0),
                      currLSNum_(0),
                      numLSDgts_(1), 
                      numIterDgts_(1)
                    {
                      // Set the input test.
                      setChild(test);
                    }
                
                  //! Destructor
       ##### ->   virtual ~StatusTestResNormOutput() {};
                  //@}
                
                  //! @name Status methods
                  //@{ 
                  /*! Check and return status of underlying StatusTest.
                
                    This method calls checkStatus() on the StatusTest object passed in the constructor. If appropriate, the
                    method will follow this call with a call to print() on the underlying object, using the OutputManager passed via the constructor
                    with verbosity level ::StatusTestDetails.
                
                    The internal counter will be incremented during this call, but only after
                    performing the tests to decide whether or not to print the underlying
                    StatusTest. This way, the very first call to checkStatus() following
                    initialization or reset() will enable the underlying StatusTest to be
                    printed, regardless of the mod parameter, as the current number of calls
                    will be zero.
                
                    If the specified Teuchos::RCP for the child class is Teuchos::null, then calling checkStatus() will result in a StatusTestError std::exception being thrown.
                    
                    \return ::StatusType indicating whether the underlying test passed or failed.
                  */
           4 ->   StatusType checkStatus( Iteration<ScalarType,MV,OP>* solver ) 
                  {
                    TEUCHOS_TEST_FOR_EXCEPTION(iterTest_ == Teuchos::null,StatusTestError,"StatusTestResNormOutput::checkStatus():  iteration test pointer is null.");
                    TEUCHOS_TEST_FOR_EXCEPTION(resTestVec_.size() == 0,StatusTestError,"StatusTestResNormOutput::checkStatus():  residual test pointer is null.");
                    state_ = test_->checkStatus(solver);
                
                    // Update some information for the header, if it has not printed or the linear system has changed.
                    LinearProblem<ScalarType,MV,OP> currProb = solver->getProblem();
                    //if (!headerPrinted_ || currLSNum_ != currProb.getLSNumber()) {
                    if (currLSNum_ != currProb.getLSNumber()) {
                      currLSNum_ = currProb.getLSNumber();
                      blockSize_ = solver->getBlockSize();
                      currIdx_ = currProb.getLSIndex();
                      currNumRHS_ = currIdx_.size();
                      numLSDgts_ = (int)std::floor((double)MVT::GetNumberVecs(*(currProb.getRHS())))+1;
                      numIterDgts_ = (int)std::floor(std::log10((double)iterTest_->getMaxIters()))+1;
                    }
                    // Print out current iteration information if it hasn't already been printed, or the status has changed
                    if (((iterTest_->getNumIters() % modTest_ == 0) && (iterTest_->getNumIters()!=lastNumIters_)) || (state_ == Passed)) {
                      lastNumIters_ = iterTest_->getNumIters();
                      if ( (state_ & stateTest_) == state_) {
                        if ( printer_->isVerbosity(StatusTestDetails) ) {
                          print( printer_->stream(StatusTestDetails) );
                        }
                        else if ( printer_->isVerbosity(Debug) ) {
                          print( printer_->stream(Debug) );
                        }
                      }
                    }
                
                    return state_;
                  }
                
                  //! Return the result of the most recent checkStatus call, or undefined if it has not been run.
       ##### ->   StatusType getStatus() const {
                    return state_;
                  }
                  //@}
                
                
                  //! @name Accessor methods
                  //@{ 
                
                  /*! \brief Set the output manager.
                   */ 
       ##### ->   void setOutputManager(const Teuchos::RCP<OutputManager<ScalarType> > &printer) { printer_ = printer; }
                
                  /*! \brief Set how often the child test is printed.
                   */
       ##### ->   void setOutputFrequency(int mod) { modTest_ = mod; }
                
                  /*! \brief Set child test, which must be a combination of a Belos::StatusTestMaxIters AND a single or combination of Belos::StatusTestResNorms
                   *
                   *  \note This also resets the test status to ::Undefined.
                   */
           1 ->   void setChild(Teuchos::RCP<StatusTest<ScalarType,MV,OP> > test) {
                
                    // First check to see if this test is a combination test
                    Teuchos::RCP<StatusTestCombo_t> comboTest = Teuchos::rcp_dynamic_cast<StatusTestCombo_t>(test);
                    TEUCHOS_TEST_FOR_EXCEPTION(comboTest == Teuchos::null,StatusTestError,"StatusTestResNormOutput():  test must be a Belos::StatusTestCombo.");
                    std::vector<Teuchos::RCP<StatusTest<ScalarType,MV,OP> > > tmpVec = comboTest->getStatusTests();
                    
                    // Get the number of tests.
                    int numTests = tmpVec.size();
                
                    // Find the maximum iteration and residual tests
                    for (int i=0; i<numTests; ++i) {
                      
                      // Check if this is a maximum iteration test.
                      Teuchos::RCP<StatusTestMaxIters_t> tmpItrTest = Teuchos::rcp_dynamic_cast<StatusTestMaxIters_t>(tmpVec[i]);
                      if (tmpItrTest != Teuchos::null) {
                        iterTest_ = tmpItrTest;
                        continue;
                      }
                
                      // Check if this is a single residual test
                      Teuchos::RCP<StatusTestResNorm_t> tmpResTest = Teuchos::rcp_dynamic_cast<StatusTestResNorm_t>(tmpVec[i]);
                      // If the residual status test is a single test, put in the vector
                      if (tmpResTest != Teuchos::null) {
                	numResTests_ = 1;
                        resTestVec_.resize( numResTests_ );
                	resTestVec_[0] = tmpResTest;
                        continue;
                      }
                	
                      // Check if the residual test is a combination of several StatusTestResNorm objects.
                      Teuchos::RCP<StatusTestCombo_t> tmpComboTest = Teuchos::rcp_dynamic_cast<StatusTestCombo_t>(tmpVec[i]);
                      TEUCHOS_TEST_FOR_EXCEPTION(tmpComboTest == Teuchos::null,StatusTestError,"StatusTestResNormOutput():  test must be Belos::StatusTest[MaxIters|ResNorm|Combo].");
                      tmpVec = tmpComboTest->getStatusTests();
                      comboType_ = tmpComboTest->getComboType();
                      numResTests_ = tmpVec.size();
                      resTestVec_.resize( numResTests_ );
                      for (int j=0; j<numResTests_; ++j) {
                	tmpResTest = Teuchos::rcp_dynamic_cast<StatusTestResNorm_t>(tmpVec[j]);
                	TEUCHOS_TEST_FOR_EXCEPTION(tmpResTest == Teuchos::null,StatusTestError,"StatusTestResNormOutput():  test must be a vector of Belos::StatusTestResNorm.");
                	resTestVec_[j] = tmpResTest;
                      }
                    }
                
                    // Keep the pointer to the new test and reset the state to Undefined.
                    test_ = test;
                    state_ = Undefined;
                
                  }
                 
                  //! \brief Get child test.
       ##### ->   Teuchos::RCP<StatusTest<ScalarType,MV,OP> > getChild() const {
                    return test_;
                  }
                
                  /*! \brief Set a short solver description for output clarity.
                   */
           1 ->   void setSolverDesc(const std::string& solverDesc) { solverDesc_ = solverDesc; }
                
                  /*! \brief Set a short preconditioner description for output clarity.
                   */
       ##### ->   void setPrecondDesc(const std::string& precondDesc) { precondDesc_ = precondDesc; }
                  //@}
                
                
                  //! @name Reset methods
                  //@{ 
                  /*! \brief Informs the status test that it should reset its internal configuration to the uninitialized state.
                   *
                   *  This resets the cached state to an ::Undefined state and calls reset() on the underlying test. It also 
                   *  resets the counter for the number of calls to checkStatus().
                   */
           1 ->   void reset() { 
                    state_ = Undefined;
                    test_->reset();
                    lastNumIters_ = -1;
                    headerPrinted_ = false;
                  }
                
                  //! Informs the outputting status test that it should reset the number of calls to zero.
                  /*! \note This outputting status test relies on the number of iterations performed, not number of times
                      the status test has been called, so this method has no effect.
                  */
           1 ->   void resetNumCalls() {}
                
                  //@}
                
                  //! @name Print methods
                  //@{ 
                  
                  //! Output formatted description of stopping test to output stream.
       ##### ->   void print(std::ostream& os, int indent = 0) const {
                    std::string ind(indent,' ');
                    std::string starLine(55,'*');
                    std::string starFront(5,'*');
                
                    std::ios_base::fmtflags osFlags(os.flags());
                
                    os.setf(std::ios::scientific, std::ios::floatfield);
                    os.precision(6);
                    
                    // Print header if this is the first call to this output status test.
                    if (!headerPrinted_) {
                      os << std::endl << ind << starLine << std::endl;
                      os << ind << starFront << " Belos Iterative Solver: " << solverDesc_ << std::endl;
                      if (precondDesc_ != "")
                        os << ind << starFront << " Preconditioner: " << precondDesc_ << std::endl;
                      os << ind << starFront << " Maximum Iterations: " << iterTest_->getMaxIters() << std::endl;
                      os << ind << starFront << " Block Size: " << blockSize_ << std::endl;
                      if (numResTests_ > 1) {
                        os << ind << starFront << " Residual Tests (" 
                           << ((comboType_ == StatusTestCombo_t::OR) ? "OR" : (comboType_ == StatusTestCombo_t::AND) ? "AND" :"SEQ")
                           << "): " << std::endl;
                      } else {
                        os << ind << starFront << " Residual Test: " << std::endl;
                      } 
                      for (int i=0; i<numResTests_; ++i) {
                        os << ind << starFront << "   Test " << i+1 << " : " << resTestVec_[i]->description() << std::endl;
                      }
                      os << ind << starLine << std::endl;
                      headerPrinted_ = true;
                    }
                
                    // Print out residuals for each residual test.
                    os.setf(std::ios_base::right, std::ios_base::adjustfield);
                    std::string ind2( 7 + numIterDgts_, ' ' );
                    os << ind << "Iter " << std::setw(numIterDgts_) << iterTest_->getNumIters() << ", ";
                    for (int i=0; i<currNumRHS_; ++i) {
                      if ( i > 0 && currIdx_[i]!=-1 ) {
                        // Put in space where 'Iter :' is in the previous lines
                        os << ind << ind2;
                      }
                      os << "[" << std::setw(numLSDgts_) << currIdx_[i]+1 << "] : ";
                      for (int j=0; j<numResTests_; ++j) {
                        if ( resTestVec_[j]->getStatus() != Undefined && currIdx_[i]!=-1 ) {
                          os << std::setw(15) << (*resTestVec_[j]->getTestValue())[currIdx_[i]];
                        } else {
                          os << std::setw(15) << "---"; 
                        }
                      }
                      os << std::endl;
                    }
                    // reset os format
                    os.flags(osFlags);
                  }
                 
                  //@}
                
                  private:
                    // Output manager.
                    Teuchos::RCP<OutputManager<ScalarType> > printer_;
                
                    // Overall status test.
                    Teuchos::RCP<StatusTest<ScalarType,MV,OP> > test_;
                
                    // Iteration test (as passed in).
                    Teuchos::RCP<StatusTestMaxIters<ScalarType,MV,OP> > iterTest_;
                
                    //! Vector of residual status tests
                    std::vector<Teuchos::RCP<StatusTestResNorm<ScalarType,MV,OP> > > resTestVec_;
                
                    std::string solverDesc_;
                    std::string precondDesc_;
                    std::vector<int> currIdx_;
                    StatusType state_;
                    mutable bool headerPrinted_;
                    int stateTest_, modTest_;
                    int lastNumIters_, comboType_;
                    int numResTests_, blockSize_;
                    int currNumRHS_, currLSNum_;
                    int numLSDgts_, numIterDgts_;
                };
                
                } // end of Belos namespace
                
                #endif /* BELOS_STATUS_TEST_RESNORM_OUTPUT_HPP */


Top 10 Lines:

     Line      Count

      145          4
      200          1
      257          1
      272          1
      283          1

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     0.67   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosBiCGStabSolMgr.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_BICGSTAB_SOLMGR_HPP
                #define BELOS_BICGSTAB_SOLMGR_HPP
                
                /*! \file BelosBiCGStabSolMgr.hpp
                 *  \brief The Belos::BiCGStabSolMgr provides a solver manager for the BiCGStab linear solver.
                */
                
                #include "BelosConfigDefs.hpp"
                #include "BelosTypes.hpp"
                
                #include "BelosLinearProblem.hpp"
                #include "BelosSolverManager.hpp"
                
                #include "BelosBiCGStabIter.hpp"
                #include "BelosStatusTestMaxIters.hpp"
                #include "BelosStatusTestGenResNorm.hpp"
                #include "BelosStatusTestCombo.hpp"
                #include "BelosStatusTestOutputFactory.hpp"
                #include "BelosOutputManager.hpp"
                #include "Teuchos_BLAS.hpp"
                #include "Teuchos_LAPACK.hpp"
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                #include "Teuchos_TimeMonitor.hpp"
                #endif
                
                /** \example BiCGStab/BiCGStabEpetraExFile.cpp
                    This is an example of how to use the Belos::BiCGStabSolMgr solver manager.
                */
                /** \example BiCGStab/PseudoBlockPrecCGEpetraExFile.cpp
                    This is an example of how to use the Belos::BiCGStabSolMgr solver manager with an Ifpack preconditioner.
                */
                
                /*! \class Belos::BiCGStabSolMgr
                 *
                 *  \brief The Belos::BiCGStabSolMgr provides a powerful and fully-featured solver manager over the pseudo-block BiCGStab iteration.
                
                 \ingroup belos_solver_framework
                
                 \author Alicia Klinvex
                 */
                
                namespace Belos {
                
                  //! @name BiCGStabSolMgr Exceptions
                  //@{
                
                  /** \brief BiCGStabSolMgrLinearProblemFailure is thrown when the linear problem is
                   * not setup (i.e. setProblem() was not called) when solve() is called.
                   *
                   * This std::exception is thrown from the BiCGStabSolMgr::solve() method.
                   *
                   */
       ##### ->   class BiCGStabSolMgrLinearProblemFailure : public BelosError {public:
                    BiCGStabSolMgrLinearProblemFailure(const std::string& what_arg) : BelosError(what_arg)
                    {}};
                
                  /** \brief BiCGStabSolMgrOrthoFailure is thrown when the orthogonalization manager is
                   * unable to generate orthonormal columns from the initial basis vectors.
                   *
                   * This std::exception is thrown from the BiCGStabSolMgr::solve() method.
                   *
                   */
                  class BiCGStabSolMgrOrthoFailure : public BelosError {public:
                    BiCGStabSolMgrOrthoFailure(const std::string& what_arg) : BelosError(what_arg)
                    {}};
                
                  template<class ScalarType, class MV, class OP>
                  class BiCGStabSolMgr : public SolverManager<ScalarType,MV,OP> {
                
                  private:
                    typedef MultiVecTraits<ScalarType,MV> MVT;
                    typedef OperatorTraits<ScalarType,MV,OP> OPT;
                    typedef Teuchos::ScalarTraits<ScalarType> SCT;
                    typedef typename Teuchos::ScalarTraits<ScalarType>::magnitudeType MagnitudeType;
                    typedef Teuchos::ScalarTraits<MagnitudeType> MT;
                
                  public:
                
                    //! @name Constructors/Destructor
                    //@{
                
                    /*! \brief Empty constructor for BiCGStabSolMgr.
                     * This constructor takes no arguments and sets the default values for the solver.
                     * The linear problem must be passed in using setProblem() before solve() is called on this object.
                     * The solver values can be changed using setParameters().
                     */
                    BiCGStabSolMgr();
                
                    /*! \brief Basic constructor for BiCGStabSolMgr.
                     *
                     * This constructor accepts the LinearProblem to be solved in addition
                     * to a parameter list of options for the solver manager. These options include the following:
                     *   - "Maximum Iterations" - a \c int specifying the maximum number of iterations the underlying solver is allowed to perform.
                     *   - "Verbosity" - a sum of MsgType specifying the verbosity. Default: Belos::Errors
                     *   - "Output Style" - a OutputType specifying the style of output. Default: Belos::General
                     *   - "Convergence Tolerance" - a \c MagnitudeType specifying the level that residual norms must reach to decide convergence.
                     */
                    BiCGStabSolMgr( const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > &problem,
                                         const Teuchos::RCP<Teuchos::ParameterList> &pl );
                
                    //! Destructor.
       ##### ->     virtual ~BiCGStabSolMgr() {};
                    //@}
                
                    //! @name Accessor methods
                    //@{
                
       ##### ->     const LinearProblem<ScalarType,MV,OP>& getProblem() const {
                      return *problem_;
                    }
                
                    /*! \brief Get a parameter list containing the valid parameters for this object.
                     */
                    Teuchos::RCP<const Teuchos::ParameterList> getValidParameters() const;
                
                    /*! \brief Get a parameter list containing the current parameters for this object.
                     */
       ##### ->     Teuchos::RCP<const Teuchos::ParameterList> getCurrentParameters() const { return params_; }
                
                    /*! \brief Return the timers for this object.
                     *
                     * The timers are ordered as follows:
                     *   - time spent in solve() routine
                     */
                    Teuchos::Array<Teuchos::RCP<Teuchos::Time> > getTimers() const {
                      return Teuchos::tuple(timerSolve_);
                    }
                
                
                    /// \brief Tolerance achieved by the last \c solve() invocation.
                    ///
                    /// This is the maximum over all right-hand sides' achieved
                    /// convergence tolerances, and is set whether or not the solve
                    /// actually managed to achieve the desired convergence tolerance.
                    ///
                    /// \warning This result may not be meaningful if there was a loss
                    ///   of accuracy during the solve.  You should first call \c
                    ///   isLOADetected() to check for a loss of accuracy during the
                    ///   last solve.
       ##### ->     MagnitudeType achievedTol() const {
                      return achievedTol_;
                    }
                
                    //! Get the iteration count for the most recent call to \c solve().
       ##### ->     int getNumIters() const {
                      return numIters_;
                    }
                
                    /*! \brief Return whether a loss of accuracy was detected by this solver during the most current solve.
                        \note This flag will be reset the next time solve() is called.
                     */
       ##### ->     bool isLOADetected() const { return false; }
                
                    //@}
                
                    //! @name Set methods
                    //@{
                
                    //! Set the linear problem that needs to be solved.
       ##### ->     void setProblem( const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > &problem ) { problem_ = problem; }
                
                    //! Set the parameters the solver manager should use to solve the linear problem.
                    void setParameters( const Teuchos::RCP<Teuchos::ParameterList> &params );
                
                    //@}
                
                    //! @name Reset methods
                    //@{
                    /*! \brief Performs a reset of the solver manager specified by the \c ResetType.  This informs the
                     *  solver manager that the solver should prepare for the next call to solve by resetting certain elements
                     *  of the iterative solver strategy.
                     */
       ##### ->     void reset( const ResetType type ) { if ((type & Belos::Problem) && !Teuchos::is_null(problem_)) problem_->setProblem(); }
                    //@}
                
                    //! @name Solver application methods
                    //@{
                
                    /*! \brief This method performs possibly repeated calls to the underlying linear solver's iterate() routine
                     * until the problem has been solved (as decided by the solver manager) or the solver manager decides to
                     * quit.
                     *
                     * This method calls BiCGStabIter::iterate(), which will return either because a specially constructed status test evaluates to
                     * ::Passed or an std::exception is thrown.
                     *
                     * A return from BiCGStabIter::iterate() signifies one of the following scenarios:
                     *    - the maximum number of restarts has been exceeded. In this scenario, the current solutions to the linear system
                     *      will be placed in the linear problem and return ::Unconverged.
                     *    - global convergence has been met. In this case, the current solutions to the linear system will be placed in the linear
                     *      problem and the solver manager will return ::Converged
                     *
                     * \returns ::ReturnType specifying:
                     *     - ::Converged: the linear problem was solved to the specification required by the solver manager.
                     *     - ::Unconverged: the linear problem was not solved to the specification desired by the solver manager.
                     */
                    ReturnType solve();
                
                    //@}
                
                    /** \name Overridden from Teuchos::Describable */
                    //@{
                
                    /** \brief Method to return description of the block BiCGStab solver manager */
                    std::string description() const;
                
                    //@}
                  private:
                
                    // Linear problem.
                    Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > problem_;
                
                    // Output manager.
                    Teuchos::RCP<OutputManager<ScalarType> > printer_;
                    Teuchos::RCP<std::ostream> outputStream_;
                
                    // Status test.
                    Teuchos::RCP<StatusTest<ScalarType,MV,OP> > sTest_;
                    Teuchos::RCP<StatusTestMaxIters<ScalarType,MV,OP> > maxIterTest_;
                    Teuchos::RCP<StatusTestGenResNorm<ScalarType,MV,OP> > convTest_;
                    Teuchos::RCP<StatusTestOutput<ScalarType,MV,OP> > outputTest_;
                
                    // Orthogonalization manager.
                    Teuchos::RCP<MatOrthoManager<ScalarType,MV,OP> > ortho_;
                
                    // Current parameter list.
                    Teuchos::RCP<Teuchos::ParameterList> params_;
                
                    /// \brief List of valid parameters and their default values.
                    ///
                    /// This is declared "mutable" because the SolverManager interface
                    /// requires that getValidParameters() be declared const, yet we
                    /// want to create the valid parameter list only on demand.
                    mutable Teuchos::RCP<const Teuchos::ParameterList> validParams_;
                
                    // Default solver values.
                    static const MagnitudeType convtol_default_;
                    static const int maxIters_default_;
                    static const bool showMaxResNormOnly_default_;
                    static const int verbosity_default_;
                    static const int outputStyle_default_;
                    static const int outputFreq_default_;
                    static const int defQuorum_default_;
                    static const std::string resScale_default_;
                    static const std::string label_default_;
                    static const Teuchos::RCP<std::ostream> outputStream_default_;
                
                    // Current solver values.
                    MagnitudeType convtol_,achievedTol_;
                    int maxIters_, numIters_;
                    int verbosity_, outputStyle_, outputFreq_, defQuorum_;
                    bool showMaxResNormOnly_;
                    std::string resScale_;
                
                    // Timers.
                    std::string label_;
                    Teuchos::RCP<Teuchos::Time> timerSolve_;
                
                    // Internal state variables.
                    bool isSet_;
                  };
                
                
                // Default solver values.
                template<class ScalarType, class MV, class OP>
                const typename BiCGStabSolMgr<ScalarType,MV,OP>::MagnitudeType BiCGStabSolMgr<ScalarType,MV,OP>::convtol_default_ = 1e-8;
                
                template<class ScalarType, class MV, class OP>
                const int BiCGStabSolMgr<ScalarType,MV,OP>::maxIters_default_ = 1000;
                
                template<class ScalarType, class MV, class OP>
                const bool BiCGStabSolMgr<ScalarType,MV,OP>::showMaxResNormOnly_default_ = false;
                
                template<class ScalarType, class MV, class OP>
                const int BiCGStabSolMgr<ScalarType,MV,OP>::verbosity_default_ = Belos::Errors;
                
                template<class ScalarType, class MV, class OP>
                const int BiCGStabSolMgr<ScalarType,MV,OP>::outputStyle_default_ = Belos::General;
                
                template<class ScalarType, class MV, class OP>
                const int BiCGStabSolMgr<ScalarType,MV,OP>::outputFreq_default_ = -1;
                
                template<class ScalarType, class MV, class OP>
                const int BiCGStabSolMgr<ScalarType,MV,OP>::defQuorum_default_ = 1;
                
                template<class ScalarType, class MV, class OP>
                const std::string BiCGStabSolMgr<ScalarType,MV,OP>::resScale_default_ = "Norm of Initial Residual";
                
                template<class ScalarType, class MV, class OP>
                const std::string BiCGStabSolMgr<ScalarType,MV,OP>::label_default_ = "Belos";
                
                template<class ScalarType, class MV, class OP>
                const Teuchos::RCP<std::ostream> BiCGStabSolMgr<ScalarType,MV,OP>::outputStream_default_ = Teuchos::rcp(&std::cout,false);
                
                // Empty Constructor
                template<class ScalarType, class MV, class OP>
                BiCGStabSolMgr<ScalarType,MV,OP>::BiCGStabSolMgr() :
                  outputStream_(outputStream_default_),
                  convtol_(convtol_default_),
                  maxIters_(maxIters_default_),
                  numIters_(0),
                  verbosity_(verbosity_default_),
                  outputStyle_(outputStyle_default_),
                  outputFreq_(outputFreq_default_),
                  defQuorum_(defQuorum_default_),
                  showMaxResNormOnly_(showMaxResNormOnly_default_),
                  resScale_(resScale_default_),
                  label_(label_default_),
                  isSet_(false)
                {}
                
                // Basic Constructor
                template<class ScalarType, class MV, class OP>
       ##### -> BiCGStabSolMgr<ScalarType,MV,OP>::
                BiCGStabSolMgr (const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > &problem,
                                     const Teuchos::RCP<Teuchos::ParameterList> &pl ) :
                  problem_(problem),
                  outputStream_(outputStream_default_),
                  convtol_(convtol_default_),
                  maxIters_(maxIters_default_),
                  numIters_(0),
                  verbosity_(verbosity_default_),
                  outputStyle_(outputStyle_default_),
                  outputFreq_(outputFreq_default_),
                  defQuorum_(defQuorum_default_),
                  showMaxResNormOnly_(showMaxResNormOnly_default_),
                  resScale_(resScale_default_),
                  label_(label_default_),
                  isSet_(false)
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    problem_.is_null (), std::invalid_argument,
                    "Belos::BiCGStabSolMgr two-argument constructor: "
                    "'problem' is null.  You must supply a non-null Belos::LinearProblem "
                    "instance when calling this constructor.");
                
                  if (! pl.is_null ()) {
                    // Set the parameters using the list that was passed in.
                    setParameters (pl);
                  }
                }
                
                template<class ScalarType, class MV, class OP>
           1 -> void BiCGStabSolMgr<ScalarType,MV,OP>::setParameters( const Teuchos::RCP<Teuchos::ParameterList> &params )
                {
                  using Teuchos::ParameterList;
                  using Teuchos::parameterList;
                  using Teuchos::RCP;
                
                  RCP<const ParameterList> defaultParams = getValidParameters();
                
                  // Create the internal parameter list if one doesn't already exist.
                  if (params_.is_null()) {
                    params_ = parameterList (*defaultParams);
                  } else {
                    params->validateParameters (*defaultParams);
                  }
                
                  // Check for maximum number of iterations
                  if (params->isParameter("Maximum Iterations")) {
                    maxIters_ = params->get("Maximum Iterations",maxIters_default_);
                
                    // Update parameter in our list and in status test.
                    params_->set("Maximum Iterations", maxIters_);
                    if (maxIterTest_!=Teuchos::null)
                      maxIterTest_->setMaxIters( maxIters_ );
                  }
                
                  // Check to see if the timer label changed.
                  if (params->isParameter("Timer Label")) {
                    std::string tempLabel = params->get("Timer Label", label_default_);
                
                    // Update parameter in our list and solver timer
                    if (tempLabel != label_) {
                      label_ = tempLabel;
                      params_->set("Timer Label", label_);
                      std::string solveLabel = label_ + ": BiCGStabSolMgr total solve time";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      timerSolve_ = Teuchos::TimeMonitor::getNewCounter(solveLabel);
                #endif
                      if (ortho_ != Teuchos::null) {
                        ortho_->setLabel( label_ );
                      }
                    }
                  }
                
                  // Check for a change in verbosity level
                  if (params->isParameter("Verbosity")) {
                    if (Teuchos::isParameterType<int>(*params,"Verbosity")) {
                      verbosity_ = params->get("Verbosity", verbosity_default_);
                    } else {
                      verbosity_ = (int)Teuchos::getParameter<Belos::MsgType>(*params,"Verbosity");
                    }
                
                    // Update parameter in our list.
                    params_->set("Verbosity", verbosity_);
                    if (printer_ != Teuchos::null)
                      printer_->setVerbosity(verbosity_);
                  }
                
                  // Check for a change in output style
                  if (params->isParameter("Output Style")) {
                    if (Teuchos::isParameterType<int>(*params,"Output Style")) {
                      outputStyle_ = params->get("Output Style", outputStyle_default_);
                    } else {
                      outputStyle_ = (int)Teuchos::getParameter<Belos::OutputType>(*params,"Output Style");
                    }
                
                    // Reconstruct the convergence test if the explicit residual test is not being used.
                    params_->set("Output Style", outputStyle_);
                    outputTest_ = Teuchos::null;
                  }
                
                  // output stream
                  if (params->isParameter("Output Stream")) {
                    outputStream_ = Teuchos::getParameter<Teuchos::RCP<std::ostream> >(*params,"Output Stream");
                
                    // Update parameter in our list.
                    params_->set("Output Stream", outputStream_);
                    if (printer_ != Teuchos::null)
                      printer_->setOStream( outputStream_ );
                  }
                
                  // frequency level
                  if (verbosity_ & Belos::StatusTestDetails) {
                    if (params->isParameter("Output Frequency")) {
                      outputFreq_ = params->get("Output Frequency", outputFreq_default_);
                    }
                
                    // Update parameter in out list and output status test.
                    params_->set("Output Frequency", outputFreq_);
                    if (outputTest_ != Teuchos::null)
                      outputTest_->setOutputFrequency( outputFreq_ );
                  }
                
                  // Create output manager if we need to.
                  if (printer_ == Teuchos::null) {
                    printer_ = Teuchos::rcp( new OutputManager<ScalarType>(verbosity_, outputStream_) );
                  }
                
                  // Convergence
                  typedef Belos::StatusTestCombo<ScalarType,MV,OP>  StatusTestCombo_t;
                  typedef Belos::StatusTestGenResNorm<ScalarType,MV,OP>  StatusTestResNorm_t;
                
                  // Check for convergence tolerance
                  if (params->isParameter("Convergence Tolerance")) {
                    convtol_ = params->get("Convergence Tolerance",convtol_default_);
                
                    // Update parameter in our list and residual tests.
                    params_->set("Convergence Tolerance", convtol_);
                    if (convTest_ != Teuchos::null)
                      convTest_->setTolerance( convtol_ );
                  }
                
                  if (params->isParameter("Show Maximum Residual Norm Only")) {
                    showMaxResNormOnly_ = Teuchos::getParameter<bool>(*params,"Show Maximum Residual Norm Only");
                
                    // Update parameter in our list and residual tests
                    params_->set("Show Maximum Residual Norm Only", showMaxResNormOnly_);
                    if (convTest_ != Teuchos::null)
                      convTest_->setShowMaxResNormOnly( showMaxResNormOnly_ );
                  }
                
                  // Check for a change in scaling, if so we need to build new residual tests.
                  bool newResTest = false;
                  {
                    // "Residual Scaling" is the old parameter name; "Implicit
                    // Residual Scaling" is the new name.  We support both options for
                    // backwards compatibility.
                    std::string tempResScale = resScale_;
                    bool implicitResidualScalingName = false;
                    if (params->isParameter ("Residual Scaling")) {
                      tempResScale = params->get<std::string> ("Residual Scaling");
                    }
                    else if (params->isParameter ("Implicit Residual Scaling")) {
                      tempResScale = params->get<std::string> ("Implicit Residual Scaling");
                      implicitResidualScalingName = true;
                    }
                
                    // Only update the scaling if it's different.
                    if (resScale_ != tempResScale) {
                      Belos::ScaleType resScaleType = convertStringToScaleType( tempResScale );
                      resScale_ = tempResScale;
                
                      // Update parameter in our list and residual tests, using the
                      // given parameter name.
                      if (implicitResidualScalingName) {
                        params_->set ("Implicit Residual Scaling", resScale_);
                      }
                      else {
                        params_->set ("Residual Scaling", resScale_);
                      }
                
                      if (! convTest_.is_null()) {
                        try {
                          convTest_->defineScaleForm( resScaleType, Belos::TwoNorm );
                        }
                        catch (std::exception& e) {
                          // Make sure the convergence test gets constructed again.
                          newResTest = true;
                        }
                      }
                    }
                  }
                
                  // Get the deflation quorum, or number of converged systems before deflation is allowed
                  if (params->isParameter("Deflation Quorum")) {
                    defQuorum_ = params->get("Deflation Quorum", defQuorum_);
                    params_->set("Deflation Quorum", defQuorum_);
                    if (convTest_ != Teuchos::null)
                      convTest_->setQuorum( defQuorum_ );
                  }
                
                  // Create status tests if we need to.
                
                  // Basic test checks maximum iterations and native residual.
                  if (maxIterTest_ == Teuchos::null)
                    maxIterTest_ = Teuchos::rcp( new StatusTestMaxIters<ScalarType,MV,OP>( maxIters_ ) );
                
                  // Implicit residual test, using the native residual to determine if convergence was achieved.
                  if (convTest_ == Teuchos::null || newResTest) {
                    convTest_ = Teuchos::rcp( new StatusTestResNorm_t( convtol_, defQuorum_, showMaxResNormOnly_ ) );
                    convTest_->defineScaleForm( convertStringToScaleType( resScale_ ), Belos::TwoNorm );
                  }
                
                  if (sTest_ == Teuchos::null || newResTest)
                    sTest_ = Teuchos::rcp( new StatusTestCombo_t( StatusTestCombo_t::OR, maxIterTest_, convTest_ ) );
                
                  if (outputTest_ == Teuchos::null || newResTest) {
                
                    // Create the status test output class.
                    // This class manages and formats the output from the status test.
                    StatusTestOutputFactory<ScalarType,MV,OP> stoFactory( outputStyle_ );
                    outputTest_ = stoFactory.create( printer_, sTest_, outputFreq_, Passed+Failed+Undefined );
                
                    // Set the solver string for the output test
                    std::string solverDesc = " Pseudo Block BiCGStab ";
                    outputTest_->setSolverDesc( solverDesc );
                
                  }
                
                  // Create the timer if we need to.
                  if (timerSolve_ == Teuchos::null) {
                    std::string solveLabel = label_ + ": BiCGStabSolMgr total solve time";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                    timerSolve_ = Teuchos::TimeMonitor::getNewCounter(solveLabel);
                #endif
                  }
                
                  // Inform the solver manager that the current parameters were set.
                  isSet_ = true;
                }
                
                
                template<class ScalarType, class MV, class OP>
                Teuchos::RCP<const Teuchos::ParameterList>
           1 -> BiCGStabSolMgr<ScalarType,MV,OP>::getValidParameters() const
                {
                  using Teuchos::ParameterList;
                  using Teuchos::parameterList;
                  using Teuchos::RCP;
                
                  if (validParams_.is_null()) {
                    // Set all the valid parameters and their default values.
                    RCP<ParameterList> pl = parameterList ();
                    pl->set("Convergence Tolerance", convtol_default_,
                      "The relative residual tolerance that needs to be achieved by the\n"
                      "iterative solver in order for the linera system to be declared converged.");
                    pl->set("Maximum Iterations", maxIters_default_,
                      "The maximum number of block iterations allowed for each\n"
                      "set of RHS solved.");
                    pl->set("Verbosity", verbosity_default_,
                      "What type(s) of solver information should be outputted\n"
                      "to the output stream.");
                    pl->set("Output Style", outputStyle_default_,
                      "What style is used for the solver information outputted\n"
                      "to the output stream.");
                    pl->set("Output Frequency", outputFreq_default_,
                      "How often convergence information should be outputted\n"
                      "to the output stream.");
                    pl->set("Deflation Quorum", defQuorum_default_,
                      "The number of linear systems that need to converge before\n"
                      "they are deflated.  This number should be <= block size.");
                    pl->set("Output Stream", outputStream_default_,
                      "A reference-counted pointer to the output stream where all\n"
                      "solver output is sent.");
                    pl->set("Show Maximum Residual Norm Only", showMaxResNormOnly_default_,
                      "When convergence information is printed, only show the maximum\n"
                      "relative residual norm when the block size is greater than one.");
                    pl->set("Implicit Residual Scaling", resScale_default_,
                      "The type of scaling used in the residual convergence test.");
                    // We leave the old name as a valid parameter for backwards
                    // compatibility (so that validateParametersAndSetDefaults()
                    // doesn't raise an exception if it encounters "Residual
                    // Scaling").  The new name was added for compatibility with other
                    // solvers, none of which use "Residual Scaling".
                    pl->set("Residual Scaling", resScale_default_,
                            "The type of scaling used in the residual convergence test.  This "
                            "name is deprecated; the new name is \"Implicit Residual Scaling\".");
                    pl->set("Timer Label", label_default_,
                      "The string to use as a prefix for the timer labels.");
                    //  defaultParams_->set("Restart Timers", restartTimers_);
                    validParams_ = pl;
                  }
                  return validParams_;
                }
                
                
                template<class ScalarType, class MV, class OP>
       ##### -> ReturnType BiCGStabSolMgr<ScalarType,MV,OP>::solve ()
                {
                  // Set the current parameters if they were not set before.
                  // NOTE:  This may occur if the user generated the solver manager with the default constructor and
                  // then didn't set any parameters using setParameters().
                  if (! isSet_) {
                    setParameters (params_);
                  }
                
                  Teuchos::BLAS<int,ScalarType> blas;
                
                  TEUCHOS_TEST_FOR_EXCEPTION
                    (! problem_->isProblemSet (), BiCGStabSolMgrLinearProblemFailure,
                     "Belos::BiCGStabSolMgr::solve: Linear problem is not ready.  "
                     "You must call setProblem() on the LinearProblem before you may solve it.");
                  TEUCHOS_TEST_FOR_EXCEPTION
                    (problem_->isLeftPrec (), std::logic_error, "Belos::BiCGStabSolMgr::solve: "
                     "The left-preconditioned case has not yet been implemented.  Please use "
                     "right preconditioning for now.  If you need to use left preconditioning, "
                     "please contact the Belos developers.  Left preconditioning is more "
                     "interesting in BiCGStab because whether it works depends on the initial "
                     "guess (e.g., an initial guess of all zeros might NOT work).");
                
                  // Create indices for the linear systems to be solved.
                  int startPtr = 0;
                  int numRHS2Solve = MVT::GetNumberVecs( *(problem_->getRHS()) );
                  int numCurrRHS = numRHS2Solve;
                
                  std::vector<int> currIdx( numRHS2Solve ), currIdx2( numRHS2Solve );
                  for (int i=0; i<numRHS2Solve; ++i) {
                    currIdx[i] = startPtr+i;
                    currIdx2[i]=i;
                  }
                
                  // Inform the linear problem of the current linear system to solve.
                  problem_->setLSIndex( currIdx );
                
                  //////////////////////////////////////////////////////////////////////////////////////
                  // Parameter list (iteration)
                  Teuchos::ParameterList plist;
                
                  // Reset the status test.
                  outputTest_->reset();
                
                  // Assume convergence is achieved, then let any failed convergence set this to false.
                  bool isConverged = true;
                
                  //////////////////////////////////////////////////////////////////////////////////////
                  // Pseudo-Block BiCGStab solver
                
                  Teuchos::RCP<BiCGStabIter<ScalarType,MV,OP> > block_cg_iter
                    = Teuchos::rcp( new BiCGStabIter<ScalarType,MV,OP>(problem_,printer_,outputTest_,plist) );
                
                  // Enter solve() iterations
                  {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                    Teuchos::TimeMonitor slvtimer(*timerSolve_);
                #endif
                
                    //bool first_time=true;
                    while ( numRHS2Solve > 0 ) {
                      // Reset the active / converged vectors from this block
                      std::vector<int> convRHSIdx;
                      std::vector<int> currRHSIdx( currIdx );
                      currRHSIdx.resize(numCurrRHS);
                
                      // Reset the number of iterations.
                      block_cg_iter->resetNumIters();
                
                      // Reset the number of calls that the status test output knows about.
                      outputTest_->resetNumCalls();
                
                      // Get the current residual for this block of linear systems.
                      Teuchos::RCP<MV> R_0 = MVT::CloneViewNonConst( *(Teuchos::rcp_const_cast<MV>(problem_->getInitResVec())), currIdx );
                
                      // Get a new state struct and initialize the solver.
                      BiCGStabIterationState<ScalarType,MV> newState;
                      newState.R = R_0;
                      block_cg_iter->initializeBiCGStab(newState);
                
                      while(1) {
                
                        // tell block_gmres_iter to iterate
                        try {
                
                          block_cg_iter->iterate();
                
                          ////////////////////////////////////////////////////////////////////////////////////
                          //
                          // check convergence first
                          //
                          ////////////////////////////////////////////////////////////////////////////////////
                          if ( convTest_->getStatus() == Passed ) {
                
                            // Figure out which linear systems converged.
                            std::vector<int> convIdx = Teuchos::rcp_dynamic_cast<StatusTestGenResNorm<ScalarType,MV,OP> >(convTest_)->convIndices();
                
                            // If the number of converged linear systems is equal to the
                            // number of current linear systems, then we are done with this block.
                            if (convIdx.size() == currRHSIdx.size())
                              break;  // break from while(1){block_cg_iter->iterate()}
                
                            // Inform the linear problem that we are finished with this current linear system.
                            problem_->setCurrLS();
                
                            // Reset currRHSIdx to have the right-hand sides that are left to converge for this block.
                            int have = 0;
                            std::vector<int> unconvIdx(currRHSIdx.size());
                            for (unsigned int i=0; i<currRHSIdx.size(); ++i) {
                              bool found = false;
                              for (unsigned int j=0; j<convIdx.size(); ++j) {
                                if (currRHSIdx[i] == convIdx[j]) {
                                  found = true;
                                  break;
                                }
                              }
                              if (!found) {
                                currIdx2[have] = currIdx2[i];
                                currRHSIdx[have++] = currRHSIdx[i];
                              }
                            }
                            currRHSIdx.resize(have);
                            currIdx2.resize(have);
                
                            // Set the remaining indices after deflation.
                            problem_->setLSIndex( currRHSIdx );
                
                            // Get the current residual vector.
                            std::vector<MagnitudeType> norms;
                            R_0 = MVT::CloneCopy( *(block_cg_iter->getNativeResiduals(&norms)),currIdx2 );
                            for (int i=0; i<have; ++i) { currIdx2[i] = i; }
                
                            // Set the new state and initialize the solver.
                            BiCGStabIterationState<ScalarType,MV> defstate;
                            defstate.R = R_0;
                            block_cg_iter->initializeBiCGStab(defstate);
                          }
                
                          ////////////////////////////////////////////////////////////////////////////////////
                          //
                          // check for maximum iterations
                          //
                          ////////////////////////////////////////////////////////////////////////////////////
                          else if ( maxIterTest_->getStatus() == Passed ) {
                            // we don't have convergence
                            isConverged = false;
                            break;  // break from while(1){block_cg_iter->iterate()}
                          }
                
                          ////////////////////////////////////////////////////////////////////////////////////
                          //
                          // we returned from iterate(), but none of our status tests Passed.
                          // something is wrong, and it is probably our fault.
                          //
                          ////////////////////////////////////////////////////////////////////////////////////
                
                          else {
                            TEUCHOS_TEST_FOR_EXCEPTION(true,std::logic_error,
                                               "Belos::BiCGStabSolMgr::solve(): Invalid return from BiCGStabIter::iterate().");
                          }
                        }
                        catch (const std::exception &e) {
                          printer_->stream(Errors) << "Error! Caught std::exception in BiCGStabIter::iterate() at iteration "
                                                   << block_cg_iter->getNumIters() << std::endl
                                                   << e.what() << std::endl;
                          throw;
                        }
                      }
                
                      // Inform the linear problem that we are finished with this block linear system.
                      problem_->setCurrLS();
                
                      // Update indices for the linear systems to be solved.
                      startPtr += numCurrRHS;
                      numRHS2Solve -= numCurrRHS;
                
                      if ( numRHS2Solve > 0 ) {
                
                        numCurrRHS = numRHS2Solve;
                        currIdx.resize( numCurrRHS );
                        currIdx2.resize( numCurrRHS );
                        for (int i=0; i<numCurrRHS; ++i)
                          { currIdx[i] = startPtr+i; currIdx2[i] = i; }
                
                        // Set the next indices.
                        problem_->setLSIndex( currIdx );
                      }
                      else {
                        currIdx.resize( numRHS2Solve );
                      }
                
                      //first_time=false;
                    }// while ( numRHS2Solve > 0 )
                
                  }
                
                  // print final summary
                  sTest_->print( printer_->stream(FinalSummary) );
                
                  // print timing information
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                  // Calling summarize() can be expensive, so don't call unless the
                  // user wants to print out timing details.  summarize() will do all
                  // the work even if it's passed a "black hole" output stream.
                  if (verbosity_ & TimingDetails)
                    Teuchos::TimeMonitor::summarize( printer_->stream(TimingDetails) );
                #endif
                
                  // get iteration information for this solve
                  numIters_ = maxIterTest_->getNumIters();
                
                
                  // Save the convergence test value ("achieved tolerance") for this
                  // solve.
                  const std::vector<MagnitudeType>* pTestValues = convTest_->getTestValue();
                  achievedTol_ = *std::max_element (pTestValues->begin(), pTestValues->end());
                
                
                  if (!isConverged ) {
                    return Unconverged; // return from BiCGStabSolMgr::solve()
                  }
                  return Converged; // return from BiCGStabSolMgr::solve()
                }
                
                //  This method requires the solver manager to return a std::string that describes itself.
                template<class ScalarType, class MV, class OP>
       ##### -> std::string BiCGStabSolMgr<ScalarType,MV,OP>::description() const
                {
                  std::ostringstream oss;
                  oss << "Belos::BiCGStabSolMgr<...,"<<Teuchos::ScalarTraits<ScalarType>::name()<<">";
                  oss << "{";
                  oss << "}";
                  return oss.str();
                }
                
                
                
                } // end Belos namespace
                
                #endif /* BELOS_BICGSTAB_SOLMGR_HPP */


Top 10 Lines:

     Line      Count

      384          1
      597          1

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.14   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_Level.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //        MueLu: A package for multigrid based preconditioning
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef MUELU_LEVEL_HPP
                #define MUELU_LEVEL_HPP
                
                #include <algorithm>                    // for swap
                #include <map>                          // for _Rb_tree_const_iterator, etc
                #include <ostream>                      // for basic_ostream, etc
                #include <string>                       // for char_traits, string, etc
                #include <utility>                      // for pair
                
                #include <Teuchos_Describable.hpp>      // for operator<<
                #include <Teuchos_FancyOStream.hpp>     // for FancyOStream
                #include <Teuchos_RCPDecl.hpp>          // for RCP
                #include <Teuchos_RCP.hpp>              // for RCP::operator->, etc
                #include <Teuchos_TestForException.hpp> // for TEUCHOS_TEST_FOR_EXCEPTION
                
                #include <Xpetra_Map.hpp>               // for UnderlyingLib definition
                
                #include "MueLu_BoostGraphviz.hpp"
                #include "MueLu_Exceptions.hpp"         // for RuntimeError
                #include "MueLu_FactoryManagerBase_fwd.hpp"
                #include "MueLu_KeepType.hpp"
                #include "MueLu_NoFactory.hpp"
                #include "MueLu_Utilities.hpp"
                #include "MueLu_VariableContainer.hpp"
                #include "MueLu_VerbosityLevel.hpp"     // for MsgType::Default, VerbLevel
                
                namespace MueLu {
                
                  /*!
                    @class Level
                    @brief Class that holds all level-specific information.
                
                    All data that is stored in the <tt>Level</tt> class need a variable name
                    (e.g. "A", "P", ...) and a pointer to the generating factory. Only with
                    both the variable name and the generating factory the data can be accessed.
                
                    If no pointer to the generating factory is provided (or it is NULL) then
                    the Level class uses the information from a factory manager, which stores
                    default factories for different variable names.
                
                    We use a "two key" map for storage of data, with the pointer to the
                    generating factory as primary key and the variable name as secondary key.
                    The pointer to the generating factory is only used as primary "key".  It
                    doesn't matter if the given factory pointer is valid or not. So the NULL
                    pointer can also be used.
                
                    The data itself is stored within a VariableContainer object.  A reference
                    counter keeps track of the storage and automatically frees the memory if
                    the data is not needed any more. In the standard mode, the data first has
                    to be requested by calling the Request function. Then the data can be set
                    by calling Set.  With Get the user can fetch data when needed. Release
                    decrements the reference counter for the given variable.
                  */
                  class Level : public BaseClass {
                
                  public:
                    //@{
                
                    //! @name Constructors / Destructors
                
                    Level() : lib_(Xpetra::NotSpecified), levelID_(-1) { }
                
                    Level(RCP<FactoryManagerBase>& factoryManager) : lib_(Xpetra::UseTpetra), levelID_(-1), factoryManager_(factoryManager) { }
                
                    //! Destructor
       ##### ->     virtual ~Level() { }
                
                    //@}
                
                    //@{
                    //! @name Build methods
                    //! Builds a new Level object.
                    RCP<Level> Build();
                
                    //@}
                
                    //@{
                    //! @name Level handling
                
                    //! @brief Return level number.
                    int GetLevelID() const;
                
                    //! @brief Set level number.
                    void SetLevelID(int levelID);
                
                    //! Previous level
                    RCP<Level>& GetPreviousLevel() { return previousLevel_; }
                
                    //! Set previous level object
                    //! @\param[in] const RCP<Level>& previousLevel
                    void SetPreviousLevel(const RCP<Level>& previousLevel);
                    //@}
                
                    //! @name Set/Get factory manager
                    //@{
                    //! Set default factories (used internally by Hierarchy::SetLevel()).
                    // Users should not use this method.
                    void SetFactoryManager(const RCP<const FactoryManagerBase>& factoryManager);
                
                    //! returns the current factory manager
                    // Users should not use this method
                    const RCP<const FactoryManagerBase> GetFactoryManager();
                    //@}
                
                    //@{
                    //! @name Set functions
                
                    //! Store need label and its associated data. This does not increment the storage counter.
                    //! - If factory is not specified or factory == NoFactory::get(), mark data as user-defined by default
                    //! - If factory is == NULL, use defaultFactory (FactoryManager have to be available).
                    template <class T>
           2 ->     void Set(const std::string& ename, const T& entry, const FactoryBase* factory = NoFactory::get()) {
                      const FactoryBase* fac = GetFactory(ename, factory);
                
                      if (fac == NoFactory::get()) {
                        // Any data set with a NoFactory gets UserData keep flag by default
                        AddKeepFlag(ename, NoFactory::get(), MueLu::UserData);
                      }
                
                      // Store entry only if data have been requested (or any keep flag)
                      if (IsRequested(ename, factory) || GetKeepFlag(ename, factory) != 0) {
                        TEUCHOS_TEST_FOR_EXCEPTION(!IsKey(factory, ename), Exceptions::RuntimeError, "" + ename + " not found in");
                        map_[factory][ename]->SetData(entry);
                
                      } else {
                        GetOStream(Warnings1) << "Level::Set: unable to store \"" << ename << "\" generated by factory " << factory
                            << " on level " << toString(GetLevelID()) << ", as it has not been requested and no keep flags were set for it" << std::endl;
                      }
                    } // Set
                
                    //@}
                
                    //! @name Get functions
                    //! @brief Get functions for accessing stored data
                
                    //@{
                    /*! @brief Get data without decrementing associated storage counter (i.e., read-only access).
                     *   Usage: Level->Get< RCP<Matrix> >("A", factory)
                     *   if factory == NULL => use default factory
                     *
                     *  @param[in] const std::string& ename
                     *  @param[in] const FactoryBase* factory
                     *  @return data (templated)
                     * */
                    template <class T>
          25 ->     T& Get(const std::string& ename, const FactoryBase* factory = NoFactory::get()) {
                      const FactoryBase* fac = GetFactory(ename, factory);
                      // printf("(l=%d)                                               getting    \"%20s\" generated by %10p  [actually, generated by %p (%43s)]\n",
                             // levelID_, ename.c_str(), factory, fac, fac->description().c_str());
                
                      TEUCHOS_TEST_FOR_EXCEPTION(!IsKey(fac, ename), Exceptions::RuntimeError, "\"" + ename + "\" not found");
                
                      if (!IsAvailable(ename, fac)) {
                        TEUCHOS_TEST_FOR_EXCEPTION(NumRequests(fac, ename) < 1 && GetKeepFlag(ename, fac) == 0, Exceptions::RuntimeError,
                                                   "\"" << ename << "\" has not been requested (counter = " << NumRequests(fac, ename) << ", "
                                                   "KeepFlag = " << GetKeepFlag(ename, fac) << "). " << std::endl <<
                                                   "Generating factory:" << *fac << " NoFactory = " << NoFactory::get());
                        fac->CallBuild(*this);
                        Release(*fac);
                      }
                
                      TEUCHOS_TEST_FOR_EXCEPTION(!IsAvailable(ename, fac), Exceptions::RuntimeError, "MueLu::Level::Get(): factory did not produce expected output. "
                                                 "\"" << ename << "\" has not been generated by " << *fac);
                
                      return map_[fac][ename]->template GetData<T>();
                    }
                
                    /*! @brief Get data without decrementing associated storage counter (i.e., read-only access).*/
                    template <class T>
                    void Get(const std::string& ename, T& rValue, const FactoryBase* factory = NoFactory::get()) {
                      rValue = Get<T>(ename, factory);
                    }
                
                    //@}
                
                    //! @name Permanent storage
                    //@{
                
                    //! Request to keep variable 'ename' generated by 'factory' after the setup phase.
                    //  This method is intented to be used by user drivers for printing, debugging or to keep some computed data for a next run of the setup phase.
                    //
                    //  This method is an alias for: AddKeepFlag(ename, factory, MueLu::Keep)
                    //  See also the description of KeepEnum for more information.
                    //
                    //  To undo a keep request, one can use:
                    //  - Delete(ename, factory) to delete the data and remove the "Keep" flag
                    //  - or RemoveKeepFlag(ename, factory, MueLu::Keep) to go back to previous condition (data are kept only if internal MueLu logic need so).
                    //
                    // Note: Level variables tagged using this methods are also keep on the levels built using this.Build().
                    //       This means that is you request to keep a specific variable on a fine level, all the coarser level that are created automatically during the setup phase will also retain the same variable.
                    void Keep(const std::string & ename, const FactoryBase* factory) { AddKeepFlag(ename, factory, MueLu::Keep); } // Note: do not add default value for input parameter 'factory'
                
                    //! Delete data that have been retained after the setup phase (using Keep(), AddKeepFlag(), or internal MueLu logic).
                    // Special cases:
                    // - If entry (ename, factory) does not exist, nothing is done.
                    // - If entry exists but counter !=, entry cannot be desallocated before counter set to 0 (using Release()) so an exeption is thrown.
                    void Delete(const std::string& ename, const FactoryBase* factory) { // Note: do not add default value for input parameter 'factory'
                      if (!IsKey(factory, ename))
                        return;
                
                      // Precondition:
                      // Delete() should only be called if counter == 0
                      // Note: It better to throw an exception rather than deleting the data if counter != 0 because users are not supposed to manipulate data with counter != 0
                      TEUCHOS_TEST_FOR_EXCEPTION(IsRequested(ename, factory) == true, Exceptions::RuntimeError, "MueLu::Level::Delete(): IsRequested() == true. Ref counter != 0. You are not allowed to delete data that are still in use.");
                      // If counter == 0 and entry exists, this means that a keep flag is set. Or there is an internal logic problem.
                      TEUCHOS_TEST_FOR_EXCEPTION(GetKeepFlag(ename, factory) == 0, Exceptions::RuntimeError, "MueLu::Level::Delete(), Keep flag == 0?");
                
                      RemoveKeepFlag(ename, factory, MueLu::All); // will delete the data if counter == 0
                
                      // Post condition: data must have been deleted
                      TEUCHOS_TEST_FOR_EXCEPTION(IsAvailable(ename, factory) == true, Exceptions::RuntimeError, "MueLu::Level::Delete(): Internal error (Post condition). Data have not been deleted.");
                    }
                
                    //! Delete all data that have been retained after the setup phase using Final flag
                    void Clear();
                
                    //! Delete all data from level that has no Keep flag set.
                    //! This is a function for experts only
                    void ExpertClear();
                
                    //! Test if a keep flag is set for variable 'ename' generated by 'factory'
                    //! The input parameter keep can be a combination of flags. IsKept() will then return true if at least one of the flag is set.
                    //! Note: There is no default parameter for IsKept() because it might be confusing (user generally wants to test IsKept with keep=MueLu::Keep but classes Level and Needs generally use keep = All)
                    bool IsKept(const std::string& ename, const FactoryBase* factory, KeepType keep) const { return GetKeepFlag(ename, factory) & keep; }
                
                    //! Add a keep flag for variable 'ename' generated by 'factory'
                    //! A variable can cumulate several keep flags (UserData+Final for example). This function just add a flag to the current flag combination.
                    //! By default, the flag 'Keep' is added. So Keep(ename, factory) is the same as AddKeepFlag(ename, factory).
                    //! See also the description of KeepEnum for more information.
                    void AddKeepFlag(const std::string & ename, const FactoryBase* factory = NoFactory::get(), KeepType keep = MueLu::Keep); // TODO: remove default value for input parameter 'factory'?
                
                    //! Remove a keep flag for variable 'ename' generated by 'factory'
                    //! A variable can cumulate several keep flags (UserData+Final for example). This function just add a flag to the current flag combination.
                    //! By default, all the flags are removed.
                    void RemoveKeepFlag(const std::string & ename, const FactoryBase* factory, KeepType keep = MueLu::All);
                
                    //! Get the flag combination set for variable 'ename' generated by 'factory'
                    KeepType GetKeepFlag(const std::string& ename, const FactoryBase* factory) const;
                
                    //@}
                
                    //! @name Request/Release functions
                    //! @brief Request and Release for incrementing/decrementing the reference count pointer for a specific variable.
                    //@{
                
                    //! Increment the storage counter for all the inputs of a factory
                    void Request(const FactoryBase& factory);
                
                    //! Decrement the storage counter for all the inputs of a factory
                    void Release(const FactoryBase& factory);
                
                    //! Callback from FactoryBase::CallDeclareInput() and FactoryBase::DeclareInput()
                    void DeclareInput(const std::string& ename, const FactoryBase* factory, const FactoryBase* requestedBy = NoFactory::get() );
                
                    //! Callback from FactoryBase::CallDeclareInput() and FactoryBase::DeclareInput() to declare factory dependencies
                    void DeclareDependencies(const FactoryBase* factory, bool bRequestOnly = false, bool bReleaseOnly = false);
                
                    //! Indicate that an object is needed. This increments the storage counter.
                    void Request(const std::string& ename, const FactoryBase* factory = NoFactory::get(), const FactoryBase* requestedBy = NoFactory::get());
                
                    //! Decrement the storage counter.
                    void Release(const std::string& ename, const FactoryBase* factory = NoFactory::get(), const FactoryBase* requestedBy = NoFactory::get());
                
                    //@}
                
                    //! @name Utility functions
                    //@{
                
                    //! Test whether a need's value has been saved.
          37 ->     bool IsAvailable(const std::string& ename, const FactoryBase* factory = NoFactory::get()) const {
                      if (!IsKey(factory, ename))
                        return false;
                      try {
                        return Get(factory, ename)->IsAvailable();
                      } catch (...) {
                        return false;
                      }
                    }
                
                    //! Test whether a need has been requested.  Note: this tells nothing about whether the need's value exists.
                    bool IsRequested(const std::string& ename, const FactoryBase* factory = NoFactory::get()) const {
                      if (!IsKey(factory, ename))
                        return false;
                      try {
                        return IsRequested(Get(factory, ename));
                      } catch (...) {
                        return false;
                      }
                    }
                
                
                    //@}
                    //! @name I/O Functions
                    //@{
                
                    //! Return a simple one-line description of this object.
                    std::string description() const;
                
                    //! Printing method
                    // TODO: print only shows requested variables. check if we also list kept factories with ref counter=0?
                    void print(std::ostream& out, const VerbLevel verbLevel = Default) const;
                
                #if defined(HAVE_MUELU_BOOST) && defined(HAVE_MUELU_BOOST_FOR_REAL) && defined(BOOST_VERSION) && (BOOST_VERSION >= 104400)
                    void UpdateGraph(std::map<const FactoryBase*, BoostVertex>&                   vindices,
                                     std::map<std::pair<BoostVertex, BoostVertex>, std::string>&  edges,
                                     BoostProperties&                                             dp,
                                     BoostGraph&                                                  graph) const;
                #endif
                
                    //@}
                
                    enum   RequestMode { REQUEST, RELEASE, UNDEF };
                    RequestMode                     GetRequestMode() const                              { return requestMode_; }
                
                    void                            setlib(Xpetra::UnderlyingLib lib2)                  { lib_ = lib2; }
                    Xpetra::UnderlyingLib           lib()                                               { return lib_; }
                
                    void                            SetComm(RCP<const Teuchos::Comm<int> > const &comm) { comm_ = comm; }
                    RCP<const Teuchos::Comm<int> >  GetComm() const                                     { return comm_; }
                
                  private:
                
                    //! Copy constructor.
                    Level(const Level& source);
                
                    //! If input factory == NULL, returns the default factory. Else, return input factory.
                    //
                    //  If factory == NULL, the default factory is defined as follow:
                    // - If user data is available, it is considered as the default and the factory manager is ignored.
                    //   => The default factory is then NoFactory.
                    // - Else, the factory manager is used to get the default factory.
                    //
                    // This strategy allows to use the same factory manager on the fine and coarse level without any trouble.
                    //     Example :
                    //
                    //     FineLevel:
                    //     ----------
                    //     A          -> User provided
                    //     Nullspace  -> User provided
                    //
                    //     CoarseLevel:
                    //     ------------
                    //     A         -> RAPFactory
                    //     NullSpace -> NullspaceFactory
                    //
                    const FactoryBase* GetFactory(const std::string& varname, const FactoryBase* factory) const;
                
                    static RequestMode                  requestMode_;
                    Xpetra::UnderlyingLib               lib_;
                    RCP<const Teuchos::Comm<int> >      comm_;
                
                    typedef const FactoryBase*          Key1;
                    typedef const std::string           Key2;
                    typedef RCP<VariableContainer>      Value;
                    typedef Teuchos::map<Key2, Value>   SubMap;     //! Sub-map container (Key2 -> Value)
                    typedef Teuchos::map<Key1, SubMap>  TwoKeyMap;  //! Map of a map (Key1 -> SubMap)
                
                    int                                 levelID_;           // id number associated with level
                    RCP<const FactoryManagerBase>       factoryManager_;
                    RCP<Level>                          previousLevel_;     // linked list of Level
                    TwoKeyMap                           map_;
                
                    //! @name Utility functions
                    //@{
                
                    //! Test whether some information about (ename, factory) are stored
                    bool IsKey(const FactoryBase* factory, const std::string& ename) const {
                      TwoKeyMap::const_iterator it = map_.find(factory);
                      return (it != map_.end()) ? (it->second).count(ename) : false;
                    }
                
                    bool IsAvailableFactory(const FactoryBase* factory) const {
                      TwoKeyMap::const_iterator it = map_.find(factory);
                      if (it == map_.end())
                        return false;
                      for (SubMap::const_iterator sit = it->second.begin(); sit != it->second.end(); sit++) {
                        if (sit->second->IsAvailable())
                            return true;
                      }
                      return false;
                    }
                
                    bool IsRequested(const Value& v) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(v->NumAllRequests() == 0 && v->GetKeepFlag() == 0, Exceptions::RuntimeError,
                                                 "Internal logic error: if counter == 0, the entry in countTable_ should have been deleted");
                      return v->IsRequested();
                    }
                
                    bool IsRequestedBy(const FactoryBase* factory, const std::string& ename, const FactoryBase* requestedBy) const {
                      if (!IsKey(factory, ename))
                        return false;
                
                      return IsRequestedBy(Get(factory, ename), requestedBy);
                    }
                
                    bool IsRequestedBy(const Value& v, const FactoryBase* requestedBy) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(v->NumAllRequests() == 0 && v->GetKeepFlag() == 0, Exceptions::RuntimeError,
                                                 "Internal logic error: if counter == 0, the entry in countTable_ should have been deleted");
                      return v->IsRequested(requestedBy);
                    }
                
                    bool IsRequestedFactory(const FactoryBase* factory) const {
                      TwoKeyMap::const_iterator it = map_.find(factory);
                      if (it == map_.end())
                        return false;
                      for (SubMap::const_iterator sit = it->second.begin(); sit != it->second.end(); sit++)
                        if (IsRequested(sit->second))
                            return true;
                      return false;
                    }
                
          98 ->     const Value& Get(const FactoryBase* factory, const std::string& ename) const {
                      TwoKeyMap::const_iterator it = map_.find(factory);
                      TEUCHOS_TEST_FOR_EXCEPTION(it == map_.end(), Exceptions::RuntimeError, "Key (" << factory << ", *) does not exist.");
                
                      SubMap::const_iterator sit = it->second.find(ename);
                      TEUCHOS_TEST_FOR_EXCEPTION(sit == it->second.end(), Exceptions::RuntimeError, "Key (" << factory << ", " << ename << ") does not exist.");
                
                      return sit->second;
                    }
                
           1 ->     int NumRequests(const FactoryBase* factory, const std::string & ename) const {
                      TEUCHOS_TEST_FOR_EXCEPTION(!IsKey(factory, ename), Exceptions::RuntimeError, "\"" + ename + "\" not found. Do a request first.");
                      const Teuchos::RCP<MueLu::VariableContainer>& v = Get(factory, ename);
                      TEUCHOS_TEST_FOR_EXCEPTION(v->NumAllRequests() == 0 && v->GetKeepFlag() == 0, Exceptions::RuntimeError,
                                                 "NumRequests(): Internal logic error: if counter == 0, the entry in countTable_ should have been deleted");
                      return v->NumAllRequests();
                    }
                
                    int CountRequestedFactory(const FactoryBase* factory) const {
                      TwoKeyMap::const_iterator it = map_.find(factory);
                      if (it == map_.end())
                        return 0;
                
                      int cnt = 0;
                      for (SubMap::const_iterator sit = it->second.begin(); sit != it->second.end(); sit++)
                        cnt += sit->second->NumAllRequests();
                
                      return cnt;
                    }
                
                    //@}
                
                  }; //class Level
                
                } //namespace MueLu
                
                //TODO: Caps should not matter
                
                #endif // MUELU_LEVEL_HPP


Top 10 Lines:

     Line      Count

      457         98
      315         37
      191         25
      157          2
      467          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      163   Total number of line executions
    27.17   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_CrsMatrixWrap.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                
                // WARNING: This code is experimental. Backwards compatibility should not be expected.
                
                #ifndef XPETRA_CRSMATRIXWRAP_HPP
                #define XPETRA_CRSMATRIXWRAP_HPP
                
                #include <Kokkos_DefaultNode.hpp>
                
                #include "Xpetra_ConfigDefs.hpp"
                #include "Xpetra_Exceptions.hpp"
                
                #include "Xpetra_MultiVector.hpp"
                #include "Xpetra_CrsGraph.hpp"
                #include "Xpetra_CrsMatrix.hpp"
                #include "Xpetra_CrsMatrixFactory.hpp"
                
                #include "Xpetra_Matrix.hpp"
                
                #include <Teuchos_SerialDenseMatrix.hpp>
                #include <Teuchos_Hashtable.hpp>
                
                /** \file Xpetra_CrsMatrixWrap.hpp
                
                  Declarations for the class Xpetra::CrsMatrixWrap.
                */
                namespace Xpetra {
                
                  typedef std::string viewLabel_t;
                
                /*!
                  @class CrsMatrixWrap
                  @brief Concrete implementation of Xpetra::Matrix.
                */
                template <class Scalar = Matrix<>::scalar_type,
                          class LocalOrdinal = typename Matrix<Scalar>::local_ordinal_type,
                          class GlobalOrdinal =
                            typename Matrix<Scalar, LocalOrdinal>::global_ordinal_type,
                          class Node =
                            typename Matrix<Scalar, LocalOrdinal, GlobalOrdinal>::node_type>
                class CrsMatrixWrap :
                  public Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>
                {
                  typedef Xpetra::Map<LocalOrdinal, GlobalOrdinal, Node> Map;
                  typedef Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> CrsMatrix;
                  typedef Xpetra::Matrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> Matrix;
                  typedef Xpetra::CrsGraph<LocalOrdinal, GlobalOrdinal, Node> CrsGraph;
                #ifdef HAVE_XPETRA_TPETRA
                  typedef Xpetra::TpetraCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> TpetraCrsMatrix;
                #endif
                  typedef Xpetra::CrsMatrixFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node> CrsMatrixFactory;
                  typedef Xpetra::MatrixView<LocalOrdinal, GlobalOrdinal, Node> MatrixView;
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename CrsMatrix::local_matrix_type local_matrix_type;
                #endif
                
                public:
                  //! @name Constructor/Destructor Methods
                  //@{
                
                  //! Constructor specifying fixed number of entries for each row.
                  CrsMatrixWrap (const RCP<const Map>& rowMap,
                                 size_t maxNumEntriesPerRow,
                                 Xpetra::ProfileType pftype = Xpetra::DynamicProfile)
                    : finalDefaultView_ (false)
                  {
                    matrixData_ = CrsMatrixFactory::Build (rowMap, maxNumEntriesPerRow, pftype);
                    CreateDefaultView ();
                  }
                
                  //! Constructor specifying (possibly different) number of entries in each row.
                  CrsMatrixWrap (const RCP<const Map>& rowMap,
                                 const ArrayRCP<const size_t>& NumEntriesPerRowToAlloc,
                                 ProfileType pftype = Xpetra::DynamicProfile)
                    : finalDefaultView_ (false)
                  {
                    matrixData_ = CrsMatrixFactory::Build(rowMap, NumEntriesPerRowToAlloc, pftype);
                    CreateDefaultView ();
                  }
                
                  //! Constructor specifying fixed number of entries for each row and column map
                  CrsMatrixWrap(const RCP<const Map> &rowMap, const RCP<const Map>& colMap, size_t maxNumEntriesPerRow, Xpetra::ProfileType pftype = Xpetra::DynamicProfile)
                    : finalDefaultView_(false)
                  {
                    // Set matrix data
                    matrixData_ = CrsMatrixFactory::Build(rowMap, colMap, maxNumEntriesPerRow, pftype);
                
                    // Default view
                    CreateDefaultView();
                  }
                
                  //! Constructor specifying fixed number of entries for each row and column map
                  CrsMatrixWrap(const RCP<const Map> &rowMap, const RCP<const Map>& colMap, const ArrayRCP<const size_t> &NumEntriesPerRowToAlloc, Xpetra::ProfileType pftype = Xpetra::DynamicProfile)
                    : finalDefaultView_(false)
                  {
                    // Set matrix data
                    matrixData_ = CrsMatrixFactory::Build(rowMap, colMap, NumEntriesPerRowToAlloc, pftype);
                
                    // Default view
                    CreateDefaultView();
                  }
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                  //! Constructor specifying fixed number of entries for each row and column map
                  CrsMatrixWrap(const RCP<const Map> &rowMap, const RCP<const Map>& colMap, const local_matrix_type& lclMatrix, const Teuchos::RCP<Teuchos::ParameterList>& params = null)
                    : finalDefaultView_(false)
                  {
                    // Set matrix data
                    matrixData_ = CrsMatrixFactory::Build(rowMap, colMap, lclMatrix, params);
                
                    // Default view
                    CreateDefaultView();
                  }
                #endif
                
                  CrsMatrixWrap(RCP<CrsMatrix> matrix)
                    : finalDefaultView_(matrix->isFillComplete())
                  {
                    // Set matrix data
                    matrixData_ = matrix;
                
                    // Default view
                    CreateDefaultView();
                  }
                
                  CrsMatrixWrap(const RCP<const CrsGraph>& graph, const RCP<ParameterList>& paramList = Teuchos::null)
                    : finalDefaultView_(false)
                  {
                    // Set matrix data
                    matrixData_ = CrsMatrixFactory::Build(graph, paramList);
                
                    // Default view
                    CreateDefaultView();
                  }
                
                  //! Destructor
       ##### ->   virtual ~CrsMatrixWrap() {}
                
                  //@}
                
                
                  //! @name Insertion/Removal Methods
                  //@{
                
                  //! Insert matrix entries, using global IDs.
                  /** All index values must be in the global space.
                      \pre \c globalRow exists as an ID in the global row map
                      \pre <tt>isLocallyIndexed() == false</tt>
                      \pre <tt>isStorageOptimized() == false</tt>
                
                      \post <tt>isGloballyIndexed() == true</tt>
                
                      \note If \c globalRow does not belong to the matrix on this node, then it will be communicated to the appropriate node when globalAssemble() is called (which will, at the latest, occur during the next call to fillComplete().) Otherwise, the entries will be inserted in the local matrix.
                      \note If the matrix row already contains values at the indices corresponding to values in \c cols, then the new values will be summed with the old values; this may happen at insertion or during the next call to fillComplete().
                      \note If <tt>hasColMap() == true</tt>, only (cols[i],vals[i]) where cols[i] belongs to the column map on this node will be inserted into the matrix.
                  */
       ##### ->   void insertGlobalValues(GlobalOrdinal globalRow, const ArrayView<const GlobalOrdinal> &cols, const ArrayView<const Scalar> &vals) {
                    matrixData_->insertGlobalValues(globalRow, cols, vals);
                  }
                
                  //! Insert matrix entries, using local IDs.
                  /** All index values must be in the local space.
                      \pre \c localRow exists as an ID in the global row map
                      \pre <tt>isGloballyIndexed() == false</tt>
                      \pre <tt>isStorageOptimized() == false</tt>
                
                      \post <tt>isLocallyIndexed() == true</tt>
                  */
       ##### ->   void insertLocalValues(LocalOrdinal localRow, const ArrayView<const LocalOrdinal> &cols, const ArrayView<const Scalar> &vals) {
                    matrixData_->insertLocalValues(localRow, cols, vals);
                  }
                
                  //! \brief Replace matrix entries, using global IDs.
                  /** All index values must be in the global space.
                
                  \pre \c globalRow is a global row belonging to the matrix on this node.
                
                  \note If (globalRow,cols[i]) corresponds to an entry that is duplicated in this matrix row (likely because it was inserted more than once and fillComplete() has not been called in the interim), the behavior of this function is not defined. */
       ##### ->   void replaceGlobalValues(GlobalOrdinal globalRow,
                                           const ArrayView<const GlobalOrdinal> &cols,
                                           const ArrayView<const Scalar>        &vals) { matrixData_->replaceGlobalValues(globalRow, cols, vals); }
                
                  //! Replace matrix entries, using local IDs.
                  /** All index values must be in the local space.
                      Note that if a value is not already present for the specified location in the matrix, the input value will be ignored silently.
                  */
       ##### ->   void replaceLocalValues(LocalOrdinal localRow,
                                          const ArrayView<const LocalOrdinal> &cols,
                                          const ArrayView<const Scalar>       &vals) { matrixData_->replaceLocalValues(localRow, cols, vals); }
                
                  //! Set all matrix entries equal to scalar
       ##### ->   virtual void setAllToScalar(const Scalar &alpha) { matrixData_->setAllToScalar(alpha); }
                
                  //! Scale the current values of a matrix, this = alpha*this.
       ##### ->   void scale(const Scalar &alpha) {
                    matrixData_->scale(alpha);
                  }
                
                  //@}
                
                  //! @name Transformational Methods
                  //@{
                
                  /*! Resume fill operations.
                    After calling fillComplete(), resumeFill() must be called before initiating any changes to the matrix.
                
                    resumeFill() may be called repeatedly.
                
                    \post  <tt>isFillActive() == true<tt>
                    \post  <tt>isFillComplete() == false<tt>
                  */
       ##### ->   void resumeFill(const RCP< ParameterList > &params=null) {
                    matrixData_->resumeFill(params);
                  }
                
                  /*! \brief Signal that data entry is complete, specifying domain and range maps.
                
                  Off-node indices are distributed (via globalAssemble()), indices are sorted, redundant indices are eliminated, and global indices are transformed to local indices.
                
                  \pre  <tt>isFillActive() == true<tt>
                  \pre <tt>isFillComplete()() == false<tt>
                
                  \post <tt>isFillActive() == false<tt>
                  \post <tt>isFillComplete() == true<tt>
                  \post if <tt>os == DoOptimizeStorage<tt>, then <tt>isStorageOptimized() == true</tt>
                  */
       ##### ->   void fillComplete(const RCP<const Map> &domainMap, const RCP<const Map> &rangeMap, const RCP<Teuchos::ParameterList> &params = null) {
                    matrixData_->fillComplete(domainMap, rangeMap, params);
                
                    // Update default view with the colMap because colMap can be <tt>null</tt> until fillComplete() is called.
                    updateDefaultView();
                  }
                
                  /*! \brief Signal that data entry is complete.
                
                  Off-node entries are distributed (via globalAssemble()), repeated entries are summed, and global indices are transformed to local indices.
                
                  \note This method calls fillComplete( getRowMap(), getRowMap(), os ).
                
                  \pre  <tt>isFillActive() == true<tt>
                  \pre <tt>isFillComplete()() == false<tt>
                
                  \post <tt>isFillActive() == false<tt>
                  \post <tt>isFillComplete() == true<tt>
                  \post if <tt>os == DoOptimizeStorage<tt>, then <tt>isStorageOptimized() == true</tt>
                  */
                  //TODO : Get ride of "Tpetra"::OptimizeOption
       ##### ->   void fillComplete(const RCP<ParameterList> &params = null) {
                    matrixData_->fillComplete(params);
                
                    // Update default view with the colMap because colMap can be <tt>null</tt> until fillComplete() is called.
                    updateDefaultView();
                  }
                
                  //@}
                
                  //! Returns the number of global rows in this matrix.
                  /** Undefined if isFillActive().
                   */
       ##### ->   global_size_t getGlobalNumRows() const {
                    return matrixData_->getGlobalNumRows();
                  }
                
                  //! \brief Returns the number of global columns in the matrix.
                  /** Undefined if isFillActive().
                   */
       ##### ->   global_size_t getGlobalNumCols() const {
                    return matrixData_->getGlobalNumCols();
                  }
                
                  //! Returns the number of matrix rows owned on the calling node.
       ##### ->   size_t getNodeNumRows() const {
                    return matrixData_->getNodeNumRows();
                  }
                
                  //! Returns the global number of entries in this matrix.
           6 ->   global_size_t getGlobalNumEntries() const {
                    return matrixData_->getGlobalNumEntries();
                  }
                
                  //! Returns the local number of entries in this matrix.
       ##### ->   size_t getNodeNumEntries() const {
                    return matrixData_->getNodeNumEntries();
                  }
                
                  //! Returns the current number of entries on this node in the specified local row.
                  /*! Returns OrdinalTraits<size_t>::invalid() if the specified local row is not valid for this matrix. */
       ##### ->   size_t getNumEntriesInLocalRow(LocalOrdinal localRow) const {
                    return matrixData_->getNumEntriesInLocalRow(localRow);
                  }
                
                  //! \brief Returns the number of global diagonal entries, based on global row/column index comparisons.
                  /** Undefined if isFillActive().
                   */
       ##### ->   global_size_t getGlobalNumDiags() const {
                    return matrixData_->getGlobalNumDiags();
                  }
                
                  //! \brief Returns the number of local diagonal entries, based on global row/column index comparisons.
                  /** Undefined if isFillActive().
                   */
       ##### ->   size_t getNodeNumDiags() const {
                    return matrixData_->getNodeNumDiags();
                  }
                
                  //! \brief Returns the maximum number of entries across all rows/columns on all nodes.
                  /** Undefined if isFillActive().
                   */
       ##### ->   size_t getGlobalMaxNumRowEntries() const {
                    return matrixData_->getGlobalMaxNumRowEntries();
                  }
                
                  //! \brief Returns the maximum number of entries across all rows/columns on this node.
                  /** Undefined if isFillActive().
                   */
       ##### ->   size_t getNodeMaxNumRowEntries() const {
                    return matrixData_->getNodeMaxNumRowEntries();
                  }
                
                  //! \brief If matrix indices are in the local range, this function returns true. Otherwise, this function returns false. */
       ##### ->   bool isLocallyIndexed() const {
                    return matrixData_->isLocallyIndexed();
                  }
                
                  //! \brief If matrix indices are in the global range, this function returns true. Otherwise, this function returns false. */
       ##### ->   bool isGloballyIndexed() const {
                    return matrixData_->isGloballyIndexed();
                  }
                
                  //! Returns \c true if fillComplete() has been called and the matrix is in compute mode.
           1 ->   bool isFillComplete() const {
                    return matrixData_->isFillComplete();
                  }
                
                  //! Extract a list of entries in a specified local row of the matrix. Put into storage allocated by calling routine.
                  /*!
                    \param LocalRow - (In) Local row number for which indices are desired.
                    \param Indices - (Out) Local column indices corresponding to values.
                    \param Values - (Out) Matrix values.
                    \param NumIndices - (Out) Number of indices.
                
                    Note: A std::runtime_error exception is thrown if either \c Indices or \c Values is not large enough to hold the data associated
                    with row \c LocalRow. If \c LocalRow is not valid for this node, then \c Indices and \c Values are unchanged and \c NumIndices is
                    returned as OrdinalTraits<size_t>::invalid().
                
                    \pre <tt>isLocallyIndexed()==true</tt> or <tt>hasColMap() == true</tt>
                  */
       ##### ->   void getLocalRowCopy(LocalOrdinal LocalRow,
                                       const ArrayView<LocalOrdinal> &Indices,
                                       const ArrayView<Scalar> &Values,
                                       size_t &NumEntries
                                       ) const {
                    matrixData_->getLocalRowCopy(LocalRow, Indices, Values, NumEntries);
                  }
                
                  //! Extract a const, non-persisting view of global indices in a specified row of the matrix.
                  /*!
                    \param GlobalRow - (In) Global row number for which indices are desired.
                    \param Indices   - (Out) Global column indices corresponding to values.
                    \param Values    - (Out) Row values
                    \pre <tt>isLocallyIndexed() == false</tt>
                    \post <tt>indices.size() == getNumEntriesInGlobalRow(GlobalRow)</tt>
                
                    Note: If \c GlobalRow does not belong to this node, then \c indices is set to null.
                  */
       ##### ->   void getGlobalRowView(GlobalOrdinal GlobalRow, ArrayView<const GlobalOrdinal> &indices, ArrayView<const Scalar> &values) const {
                     matrixData_->getGlobalRowView(GlobalRow, indices, values);
                  }
                
                  //! Extract a const, non-persisting view of local indices in a specified row of the matrix.
                  /*!
                    \param LocalRow - (In) Local row number for which indices are desired.
                    \param Indices  - (Out) Global column indices corresponding to values.
                    \param Values   - (Out) Row values
                    \pre <tt>isGloballyIndexed() == false</tt>
                    \post <tt>indices.size() == getNumEntriesInLocalRow(LocalRow)</tt>
                
                    Note: If \c LocalRow does not belong to this node, then \c indices is set to null.
                  */
       ##### ->   void getLocalRowView(LocalOrdinal LocalRow, ArrayView<const LocalOrdinal> &indices, ArrayView<const Scalar> &values) const {
                     matrixData_->getLocalRowView(LocalRow, indices, values);
                  }
                
                  //! \brief Get a copy of the diagonal entries owned by this node, with local row idices.
                  /*! Returns a distributed Vector object partitioned according to this matrix's row map, containing the
                    the zero and non-zero diagonals owned by this node. */
       ##### ->   void getLocalDiagCopy(Xpetra::Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &diag) const {
                    matrixData_->getLocalDiagCopy(diag);
                  }
                
                  //! Get offsets of the diagonal entries in the matrix.
                  void getLocalDiagOffsets(Teuchos::ArrayRCP<size_t> &offsets) const {
                    matrixData_->getLocalDiagOffsets(offsets);
                  }
                
                  //! Get a copy of the diagonal entries owned by this node, with local row indices, using row offsets.
                  void getLocalDiagCopy(Xpetra::Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag, const Teuchos::ArrayView<const size_t> &offsets) const {
                    matrixData_->getLocalDiagCopy(diag,offsets);
                  }
                
                  //! Get Frobenius norm of the matrix
       ##### ->   typename ScalarTraits<Scalar>::magnitudeType getFrobeniusNorm() const {
                    return matrixData_->getFrobeniusNorm();
                  }
                
                  //! Left scale matrix using the given vector entries
       ##### ->   void leftScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) {
                    matrixData_->leftScale(x);
                  }
                
                  //! Right scale matrix using the given vector entries
       ##### ->   void rightScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) {
                    matrixData_->rightScale(x);
                  }
                
                  //@}
                
                  //! @name Advanced Matrix-vector multiplication and solve methods
                  //@{
                
                  //! Multiplies this matrix by a MultiVector.
                  /*! \c X is required to be post-imported, i.e., described by the column map of the matrix. \c Y is required to be pre-exported, i.e., described by the row map of the matrix.
                
                  Both are required to have constant stride, and they are not permitted to ocupy overlapping space. No runtime checking will be performed in a non-debug build.
                
                  This method is templated on the scalar type of MultiVector objects, allowing this method to be applied to MultiVector objects of arbitrary type. However, it is recommended that multiply() not be called directly; instead, use the CrsMatrixMultiplyOp, as it will handle the import/exprt operations required to apply a matrix with non-trivial communication needs.
                
                  If \c beta is equal to zero, the operation will enjoy overwrite semantics (\c Y will be overwritten with the result of the multiplication). Otherwise, the result of the multiplication
                  will be accumulated into \c Y.
                  */
                  //TODO virtual=0 // TODO: Add default parameters ?
                //   void multiply(const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> & X, MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &Y, Teuchos::ETransp trans, Scalar alpha, Scalar beta) const {
                //      matrixData_->multiply(X, Y, trans, alpha, beta);
                //   }
                
                  //@}
                
                  //! @name Methods implementing Matrix
                  //@{
                
                  //! \brief Computes the sparse matrix-multivector multiplication.
                  /*! Performs \f$Y = \alpha A^{\textrm{mode}} X + \beta Y\f$, with one special exceptions:
                    - if <tt>beta == 0</tt>, apply() overwrites \c Y, so that any values in \c Y (including NaNs) are ignored.
                  */
       ##### ->   void apply(const Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& X,
                                   Xpetra::MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>& Y,
                                   Teuchos::ETransp mode = Teuchos::NO_TRANS,
                                   Scalar alpha = ScalarTraits<Scalar>::one(),
                                   Scalar beta = ScalarTraits<Scalar>::zero()) const {
                
                    matrixData_->apply(X,Y,mode,alpha,beta);
                  }
                
                  //! \brief Returns the Map associated with the domain of this operator.
                  //! This will be <tt>null</tt> until fillComplete() is called.
          14 ->   RCP<const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > getDomainMap() const {
                    return matrixData_->getDomainMap();
                  }
                
                  //! Returns the Map associated with the domain of this operator.
                  //! This will be <tt>null</tt> until fillComplete() is called.
           1 ->   RCP<const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > getRangeMap() const {
                    return matrixData_->getRangeMap();
                  }
                
                  //! \brief Returns the Map that describes the column distribution in this matrix.
                  //! This might be <tt>null</tt> until fillComplete() is called.
       ##### ->   const RCP<const Map> & getColMap() const { return getColMap(Matrix::GetCurrentViewLabel()); }
                
                  //! \brief Returns the Map that describes the column distribution in this matrix.
       ##### ->   const RCP<const Map> & getColMap(viewLabel_t viewLabel) const {
                    TEUCHOS_TEST_FOR_EXCEPTION(Matrix::operatorViewTable_.containsKey(viewLabel) == false, Xpetra::Exceptions::RuntimeError, "Xpetra::Matrix.GetColMap(): view '" + viewLabel + "' does not exist.");
                    updateDefaultView(); // If CrsMatrix::fillComplete() have been used instead of CrsMatrixWrap::fillComplete(), the default view is updated.
                    return Matrix::operatorViewTable_.get(viewLabel)->GetColMap();
                  }
                
       ##### ->   void removeEmptyProcessesInPlace(const Teuchos::RCP<const Map>& newMap) {
                    matrixData_->removeEmptyProcessesInPlace(newMap);
                    this->operatorViewTable_.get(this->GetCurrentViewLabel())->SetRowMap(matrixData_->getRowMap());
                    this->operatorViewTable_.get(this->GetCurrentViewLabel())->SetColMap(matrixData_->getColMap());
                  }
                
                  //@}
                
                  //! Implements DistObject interface
                  //{@
                
                  //! Access function for the Tpetra::Map this DistObject was constructed with.
       ##### ->   const Teuchos::RCP< const Xpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const {
                    return matrixData_->getMap();
                  }
                
                  //! Import.
       ##### ->   void doImport(const Matrix &source,
                                const Xpetra::Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) {
                    const CrsMatrixWrap & sourceWrp = dynamic_cast<const CrsMatrixWrap &>(source);
                    matrixData_->doImport(*sourceWrp.getCrsMatrix(), importer, CM);
                  }
                
                  //! Export.
       ##### ->   void doExport(const Matrix &dest,
                                const Xpetra::Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) {
                    const CrsMatrixWrap & destWrp = dynamic_cast<const CrsMatrixWrap &>(dest);
                    matrixData_->doExport(*destWrp.getCrsMatrix(), importer, CM);
                  }
                
                  //! Import (using an Exporter).
       ##### ->   void doImport(const Matrix &source,
                                const Xpetra::Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {
                    const CrsMatrixWrap & sourceWrp = dynamic_cast<const CrsMatrixWrap &>(source);
                    matrixData_->doImport(*sourceWrp.getCrsMatrix(), exporter, CM);
                  }
                
                  //! Export (using an Importer).
       ##### ->   void doExport(const Matrix &dest,
                                const Xpetra::Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {
                    const CrsMatrixWrap & destWrp = dynamic_cast<const CrsMatrixWrap &>(dest);
                    matrixData_->doExport(*destWrp.getCrsMatrix(), exporter, CM);
                  }
                
                  // @}
                
                  //! @name Overridden from Teuchos::Describable
                  //@{
                
                  /** \brief Return a simple one-line description of this object. */
       ##### ->   std::string description() const {
                    return "Xpetra::CrsMatrixWrap";
                  }
                
                  /** \brief Print the object with some verbosity level to an FancyOStream object. */
       ##### ->   void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const {
                    //     Teuchos::EVerbosityLevel vl = verbLevel;
                    //     if (vl == VERB_DEFAULT) vl = VERB_LOW;
                    //     RCP<const Comm<int> > comm = this->getComm();
                    //     const int myImageID = comm->getRank(),
                    //       numImages = comm->getSize();
                
                    //     if (myImageID == 0) out << this->description() << std::endl;
                
                    matrixData_->describe(out,verbLevel);
                
                    // Teuchos::OSTab tab(out);
                  }
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                  /// \brief Access the underlying local Kokkos::CrsMatrix object
                  local_matrix_type getLocalMatrix () const {
                    return matrixData_->getLocalMatrix();
                  }
                #endif
                
                  // JG: Added:
                
                  //! Returns the CrsGraph associated with this matrix.
       ##### ->   RCP<const CrsGraph> getCrsGraph() const { return matrixData_->getCrsGraph(); }
                
                  RCP<CrsMatrix> getCrsMatrix() const {  return matrixData_; }
                
                  //@}
                
                  template<class Node2>
                  RCP<Xpetra::Matrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> > clone(const RCP<Node2> &node2) const {
                #ifdef HAVE_XPETRA_TPETRA
                    RCP<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> > tMatrix =
                        Teuchos::rcp_dynamic_cast<const Xpetra::TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >(matrixData_);
                    if (tMatrix == Teuchos::null)
                      throw Xpetra::Exceptions::RuntimeError("clone() functionality is only available for Tpetra");
                
                    return RCP<CrsMatrixWrap<Scalar,LocalOrdinal,GlobalOrdinal,Node2> >(new CrsMatrixWrap<Scalar,LocalOrdinal,GlobalOrdinal,Node2>(tMatrix->clone(node2)));
                    // TODO: inherit strided maps/views ?
                #else
                    return Teuchos::null;
                #endif
                  }
                
                private:
                
                  // Default view is created after fillComplete()
                  // Because ColMap might not be available before fillComplete().
                  void CreateDefaultView() {
                
                    // Create default view
                    this->defaultViewLabel_ = "point";
                    this->CreateView(this->GetDefaultViewLabel(), matrixData_->getRowMap(), matrixData_->getColMap());
                
                    // Set current view
                    this->currentViewLabel_ = this->GetDefaultViewLabel();
                  }
                
                private:
                
                  // The colMap can be <tt>null</tt> until fillComplete() is called. The default view of the Matrix have to be updated when fillComplete() is called.
                  // If CrsMatrix::fillComplete() have been used instead of CrsMatrixWrap::fillComplete(), the default view is updated when getColMap() is called.
                  void updateDefaultView() const {
                    if ((finalDefaultView_ == false) &&  matrixData_->isFillComplete() ) {
                      // Update default view with the colMap
                      Matrix::operatorViewTable_.get(Matrix::GetDefaultViewLabel())->SetColMap(matrixData_->getColMap());
                      finalDefaultView_ = true;
                    }
                  }
                  // The boolean finalDefaultView_ keep track of the status of the default view (= already updated or not)
                  // See also CrsMatrixWrap::updateDefaultView()
                  mutable bool finalDefaultView_;
                
                
                  RCP<CrsMatrix> matrixData_;
                
                }; //class Matrix
                
                } //namespace Xpetra
                
                #define XPETRA_CRSMATRIXWRAP_SHORT
                #endif //XPETRA_CRSMATRIXWRAP_DECL_HPP
                
                //NOTE: if CrsMatrix and VbrMatrix share a common interface for fillComplete() etc, I can move some stuff in Xpetra_Matrix.hpp
                //TODO: getUnderlyingMatrix() method


Top 10 Lines:

     Line      Count

      500         14
      321          6
      375          1
      506          1

Execution Summary:

       44   Executable lines in this file
       44   Lines executed
   100.00   Percent of the file executed

       22   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosBiCGStabIter.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_BICGSTAB_ITER_HPP
                #define BELOS_BICGSTAB_ITER_HPP
                
                /*! \file BelosBiCGStabIter.hpp
                    \brief Belos concrete class for performing the pseudo-block BiCGStab iteration.
                */
                
                #include "BelosConfigDefs.hpp"
                #include "BelosTypes.hpp"
                #include "BelosCGIteration.hpp"
                
                #include "BelosLinearProblem.hpp"
                #include "BelosMatOrthoManager.hpp"
                #include "BelosOutputManager.hpp"
                #include "BelosStatusTest.hpp"
                #include "BelosOperatorTraits.hpp"
                #include "BelosMultiVecTraits.hpp"
                
                #include "Teuchos_BLAS.hpp"
                #include "Teuchos_SerialDenseMatrix.hpp"
                #include "Teuchos_SerialDenseVector.hpp"
                #include "Teuchos_ScalarTraits.hpp"
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_TimeMonitor.hpp"
                
                   #include <chrono>
                   #include <ctime>
                
                /*!
                  \class Belos::BiCGStabIter
                
                  \brief This class implements the pseudo-block BiCGStab iteration, where the basic BiCGStab
                  algorithm is performed on all of the linear systems simultaneously.
                
                  \ingroup belos_solver_framework
                
                  \author Alicia Klinvex
                */
                
                namespace Belos {
                
                  //! @name BiCGStabIteration Structures
                  //@{
                
                  /** \brief Structure to contain pointers to BiCGStabIteration state variables.
                   *
                   * This struct is utilized by BiCGStabIteration::initialize() and BiCGStabIteration::getState().
                   */
                  template <class ScalarType, class MV>
       ##### ->   struct BiCGStabIterationState {
                
                    /*! \brief The current residual. */
                    Teuchos::RCP<const MV> R;
                
                    /*! \brief The initial residual. */
                    Teuchos::RCP<const MV> Rhat;
                
                    /*! \brief The first decent direction vector */
                    Teuchos::RCP<const MV> P;
                
                    /*! \brief A * M * the first decent direction vector */
                    Teuchos::RCP<const MV> V;
                
                    std::vector<ScalarType> rho_old, alpha, omega;
                
                    BiCGStabIterationState() : R(Teuchos::null), Rhat(Teuchos::null),
                                    P(Teuchos::null), V(Teuchos::null)
                    {
                      rho_old.clear();
                      alpha.clear();
                      omega.clear();
                    }
                  };
                
                  template<class ScalarType, class MV, class OP>
                  class BiCGStabIter : virtual public Iteration<ScalarType,MV,OP> {
                
                  public:
                
                    //
                    // Convenience typedefs
                    //
                    typedef MultiVecTraits<ScalarType,MV> MVT;
                    typedef OperatorTraits<ScalarType,MV,OP> OPT;
                    typedef Teuchos::ScalarTraits<ScalarType> SCT;
                    typedef typename SCT::magnitudeType MagnitudeType;
                
                    //! @name Constructors/Destructor
                    //@{
                
                    /*! \brief %BiCGStabIter constructor with linear problem, solver utilities, and parameter list of solver options.
                     *
                     * This constructor takes pointers required by the linear solver, in addition
                     * to a parameter list of options for the linear solver.
                     */
                    BiCGStabIter( const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > &problem,
                                          const Teuchos::RCP<OutputManager<ScalarType> > &printer,
                                          const Teuchos::RCP<StatusTest<ScalarType,MV,OP> > &tester,
                                          Teuchos::ParameterList &params );
                
                    //! Destructor.
       ##### ->     virtual ~BiCGStabIter() {};
                    //@}
                
                
                    //! @name Solver methods
                    //@{
                
                    /*! \brief This method performs BiCGStab iterations on each linear system until the status
                     * test indicates the need to stop or an error occurs (in which case, an
                     * std::exception is thrown).
                     *
                     * iterate() will first determine whether the solver is initialized; if
                     * not, it will call initialize() using default arguments. After
                     * initialization, the solver performs BiCGStab iterations until the
                     * status test evaluates as ::Passed, at which point the method returns to
                     * the caller.
                     *
                     * The status test is queried at the beginning of the iteration.
                     *
                     */
                    void iterate();
                
                    /*! \brief Initialize the solver to an iterate, providing a complete state.
                     *
                     * The %BiCGStabIter contains a certain amount of state, consisting of the current
                     * direction vectors and residuals.
                     *
                     * initialize() gives the user the opportunity to manually set these,
                     * although this must be done with caution, abiding by the rules given
                     * below.
                     *
                     * \post
                     * <li>isInitialized() == \c true (see post-conditions of isInitialize())
                     *
                     * The user has the option of specifying any component of the state using
                     * initialize(). However, these arguments are assumed to match the
                     * post-conditions specified under isInitialized(). Any necessary component of the
                     * state not given to initialize() will be generated.
                     *
                     * \note For any pointer in \c newstate which directly points to the multivectors in
                     * the solver, the data is not copied.
                     */
                    void initializeBiCGStab(BiCGStabIterationState<ScalarType,MV>& newstate);
                
                    /*! \brief Initialize the solver with the initial vectors from the linear problem
                     *  or random data.
                     */
       ##### ->     void initialize()
                    {
                      BiCGStabIterationState<ScalarType,MV> empty;
                      initializeBiCGStab(empty);
                    }
                
                    /*! \brief Get the current state of the linear solver.
                     *
                     * The data is only valid if isInitialized() == \c true.
                     *
                     * \returns A BiCGStabIterationState object containing const pointers to the current
                     * solver state.
                     */
                    BiCGStabIterationState<ScalarType,MV> getState() const {
                      BiCGStabIterationState<ScalarType,MV> state;
                      state.R = R_;
                      state.Rhat = Rhat_;
                      state.P = P_;
                      state.V = V_;
                      state.rho_old = rho_old_;
                      state.alpha = alpha_;
                      state.omega = omega_;
                      return state;
                    }
                
                    //@}
                
                
                    //! @name Status methods
                    //@{
                
                    //! \brief Get the current iteration count.
           4 ->     int getNumIters() const { return iter_; }
                
                    //! \brief Reset the iteration count.
       ##### ->     void resetNumIters( int iter = 0 ) { iter_ = iter; }
                
                    //! Get the norms of the residuals native to the solver.
                    //! \return A std::vector of length blockSize containing the native residuals.
                    // amk TODO: are the residuals actually being set?  What is a native residual?
           4 ->     Teuchos::RCP<const MV> getNativeResiduals( std::vector<MagnitudeType> *norms ) const { return R_; }
                
                    //! Get the current update to the linear system.
                    /*! \note This method returns a null pointer because the linear problem is current.
                    */
                    // amk TODO: what is this supposed to be doing?
       ##### ->     Teuchos::RCP<MV> getCurrentUpdate() const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Accessor methods
                    //@{
                
                    //! Get a constant reference to the linear problem.
           9 ->     const LinearProblem<ScalarType,MV,OP>& getProblem() const { return *lp_; }
                
                    //! Get the blocksize to be used by the iterative solver in solving this linear problem.
           1 ->     int getBlockSize() const { return 1; }
                
                    //! \brief Set the blocksize.
       ##### ->     void setBlockSize(int blockSize) {
                      TEUCHOS_TEST_FOR_EXCEPTION(blockSize!=1,std::invalid_argument,
                                         "Belos::BiCGStabIter::setBlockSize(): Cannot use a block size that is not one.");
                    }
                
                    //! States whether the solver has been initialized or not.
       ##### ->     bool isInitialized() { return initialized_; }
                
                    //@}
                
                  private:
                
                    void axpy(const ScalarType alpha, const MV & A,
                              const std::vector<ScalarType> beta, const MV& B, MV& mv, bool minus=false);
                
                    //
                    // Classes inputed through constructor that define the linear problem to be solved.
                    //
                    const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> >    lp_;
                    const Teuchos::RCP<OutputManager<ScalarType> >          om_;
                    const Teuchos::RCP<StatusTest<ScalarType,MV,OP> >       stest_;
                
                    //
                    // Algorithmic parameters
                    //
                    // numRHS_ is the current number of linear systems being solved.
                    int numRHS_;
                
                    //
                    // Current solver state
                    //
                    // initialized_ specifies that the basis vectors have been initialized and the iterate() routine
                    // is capable of running; _initialize is controlled  by the initialize() member method
                    // For the implications of the state of initialized_, please see documentation for initialize()
                    bool initialized_;
                
                    // Current number of iterations performed.
                    int iter_;
                
                    //
                    // State Storage
                    //
                    // Initial residual
                    Teuchos::RCP<MV> Rhat_;
                    //
                    // Residual
                    Teuchos::RCP<MV> R_;
                    //
                    // Direction vector 1
                    Teuchos::RCP<MV> P_;
                    //
                    // Operator applied to preconditioned direction vector 1
                    Teuchos::RCP<MV> V_;
                    //
                    std::vector<ScalarType> rho_old_, alpha_, omega_;
                  };
                
                  //////////////////////////////////////////////////////////////////////////////////////////////////
                  // Constructor.
                  template<class ScalarType, class MV, class OP>
                  BiCGStabIter<ScalarType,MV,OP>::BiCGStabIter(const Teuchos::RCP<LinearProblem<ScalarType,MV,OP> > &problem,
                                                                               const Teuchos::RCP<OutputManager<ScalarType> > &printer,
                                                                               const Teuchos::RCP<StatusTest<ScalarType,MV,OP> > &tester,
                                                                               Teuchos::ParameterList &params ):
                    lp_(problem),
                    om_(printer),
                    stest_(tester),
                    numRHS_(0),
                    initialized_(false),
                    iter_(0)
                  {
                  }
                
                
                  //////////////////////////////////////////////////////////////////////////////////////////////////
                  // Initialize this iteration object
                  template <class ScalarType, class MV, class OP>
           1 ->   void BiCGStabIter<ScalarType,MV,OP>::initializeBiCGStab(BiCGStabIterationState<ScalarType,MV>& newstate)
                  {
                    // Check if there is any multivector to clone from.
                    Teuchos::RCP<const MV> lhsMV = lp_->getCurrLHSVec();
                    Teuchos::RCP<const MV> rhsMV = lp_->getCurrRHSVec();
                    TEUCHOS_TEST_FOR_EXCEPTION((lhsMV==Teuchos::null && rhsMV==Teuchos::null),std::invalid_argument,
                                       "Belos::BiCGStabIter::initialize(): Cannot initialize state storage!");
                
                    // Get the multivector that is not null.
                    Teuchos::RCP<const MV> tmp = ( (rhsMV!=Teuchos::null)? rhsMV: lhsMV );
                
                    // Get the number of right-hand sides we're solving for now.
                    int numRHS = MVT::GetNumberVecs(*tmp);
                    numRHS_ = numRHS;
                
                    // Initialize the state storage
                    // If the subspace has not be initialized before or has changed sizes, generate it using the LHS or RHS from lp_.
                    if (Teuchos::is_null(R_) || MVT::GetNumberVecs(*R_)!=numRHS_) {
                      R_ = MVT::Clone( *tmp, numRHS_ );
                      Rhat_ = MVT::Clone( *tmp, numRHS_ );
                      P_ = MVT::Clone( *tmp, numRHS_ );
                      V_ = MVT::Clone( *tmp, numRHS_ );
                
                      rho_old_.resize(numRHS_);
                      alpha_.resize(numRHS_);
                      omega_.resize(numRHS_);
                    }
                
                    // NOTE:  In BiCGStabIter R_, the initial residual, is required!!!
                    //
                    std::string errstr("Belos::BlockPseudoCGIter::initialize(): Specified multivectors must have a consistent length and width.");
                
                    // Create convenience variable for one.
                    const ScalarType one = Teuchos::ScalarTraits<ScalarType>::one();
                
                    if (!Teuchos::is_null(newstate.R)) {
                
                      TEUCHOS_TEST_FOR_EXCEPTION( MVT::GetGlobalLength(*newstate.R) != MVT::GetGlobalLength(*R_),
                                          std::invalid_argument, errstr );
                      TEUCHOS_TEST_FOR_EXCEPTION( MVT::GetNumberVecs(*newstate.R) != numRHS_,
                                          std::invalid_argument, errstr );
                
                      // Copy residual vectors from newstate into R
                      if (newstate.R != R_) {
                        // Assigned by the new state
                        MVT::Assign(*newstate.R, *R_);
                      }
                      else {
                        // Computed
                        lp_->computeCurrResVec(R_.get());
                      }
                
                      // Set Rhat
                      if (!Teuchos::is_null(newstate.Rhat) && newstate.Rhat != Rhat_) {
                        // Assigned by the new state
                        MVT::Assign(*newstate.Rhat, *Rhat_);
                      }
                      else {
                        // Set to be the initial residual
                        MVT::Assign(*lp_->getInitResVec(), *Rhat_);
                      }
                
                      // Set V
                      if (!Teuchos::is_null(newstate.V) && newstate.V != V_) {
                        // Assigned by the new state
                        MVT::Assign(*newstate.V, *V_);
                      }
                      else {
                        // Initial V = 0
                        MVT::MvInit(*V_);
                      }
                
                      // Set P
                      if (!Teuchos::is_null(newstate.P) && newstate.P != P_) {
                        // Assigned by the new state
                        MVT::Assign(*newstate.P, *P_);
                      }
                      else {
                        // Initial P = 0
                        MVT::MvInit(*P_);
                      }
                
                      // Set rho_old
                      if (newstate.rho_old.size () == static_cast<size_t> (numRHS_)) {
                        // Assigned by the new state
                        rho_old_ = newstate.rho_old;
                      }
                      else {
                        // Initial rho = 1
                        rho_old_.assign(numRHS_,one);
                      }
                
                      // Set alpha
                      if (newstate.alpha.size() == static_cast<size_t> (numRHS_)) {
                        // Assigned by the new state
                        alpha_ = newstate.alpha;
                      }
                      else {
                        // Initial rho = 1
                        alpha_.assign(numRHS_,one);
                      }
                
                      // Set omega
                      if (newstate.omega.size() == static_cast<size_t> (numRHS_)) {
                        // Assigned by the new state
                        omega_ = newstate.omega;
                      }
                      else {
                        // Initial rho = 1
                        omega_.assign(numRHS_,one);
                      }
                
                    }
                    else {
                
                      TEUCHOS_TEST_FOR_EXCEPTION(Teuchos::is_null(newstate.R),std::invalid_argument,
                                         "Belos::BiCGStabIter::initialize(): BiCGStabStateIterState does not have initial residual.");
                    }
                
                    // The solver is initialized
                    initialized_ = true;
                  }
                
                
                  //////////////////////////////////////////////////////////////////////////////////////////////////
                  // Iterate until the status test informs us we should stop.
                  template <class ScalarType, class MV, class OP>
           1 ->   void BiCGStabIter<ScalarType,MV,OP>::iterate()
                  {
                    using Teuchos::RCP;
                
                    //
                    // Allocate/initialize data structures
                    //
                    if (initialized_ == false) {
                      initialize();
                    }
                
                    // Allocate memory for scalars.
                    int i=0;
                    std::vector<ScalarType> rho_new( numRHS_ ), beta( numRHS_ );
                    std::vector<ScalarType> rhatV( numRHS_ ), tT( numRHS_ ), tS( numRHS_ );
                
                    // Create convenience variable for one.
                    const ScalarType one = Teuchos::ScalarTraits<ScalarType>::one();
                
                    // TODO: We may currently be using more space than is required
                    RCP<MV> leftPrecVec, leftPrecVec2;
                
                    RCP<MV> Y, Z, S, T;
                    S = MVT::Clone( *R_, numRHS_ );
                    T = MVT::Clone( *R_, numRHS_ );
                    if (lp_->isLeftPrec() || lp_->isRightPrec()) {
                      Y = MVT::Clone( *R_, numRHS_ );
                      Z = MVT::Clone( *R_, numRHS_ );
                    }
                    else {
                      Y = P_;
                      Z = S;
                    }
                
                    // Get the current solution std::vector.
                    Teuchos::RCP<MV> X = lp_->getCurrLHSVec();
                
                //    const int myRank_ = X-> getComm() ->getRank ();
                //    std::cout << myRank_ << std::endl; 
                
                    ////////////////////////////////////////////////////////////////
                    // Iterate until the status test tells us to stop.
                    //
                
                    std::clock_t c_start0 = std::clock();
                    while (stest_->checkStatus(this) != Passed) {
                //      std::cout << std::endl;
                
                      // std::vector<ScalarType> tempResids(numRHS_);
                      // MVT::MvNorm(*R_,tempResids);
                //      for(i=0; i<numRHS_; i++)
                //        std::cout << "r[" << i << "] = " << tempResids[i] << std::endl;
                
                      // Increment the iteration
                      iter_++;
                
                      // rho_new = <R_, Rhat_>
                      
                      std::clock_t c_start1 = std::clock();
                      MVT::MvDot(*R_,*Rhat_,rho_new);
                    std::clock_t c_start2 = std::clock();
                    
                    std::cout << "Belos_rho_i " << 1000*(c_start2 - c_start1)/(double)CLOCKS_PER_SEC << std::endl; 
                //      for(i=0; i<numRHS_; i++) {
                //        std::cout << "rho[" << i << "] = " << rho_new[i] << std::endl;
                //      }
                
                      // beta = ( rho_new / rho_old ) (alpha / omega )
                      // TODO: None of these loops are currently threaded
                      for(i=0; i<numRHS_; i++) {
                        beta[i] = (rho_new[i] / rho_old_[i]) * (alpha_[i] / omega_[i]);
                //        std::cout << "beta[" << i << "] = " << beta[i] << std::endl;
                      }
                    std::clock_t c_start3 = std::clock();
                    std::cout << "Belos_beta " << 1000*(c_start3 - c_start2)/(double)CLOCKS_PER_SEC << std::endl;
                
                      // p = r + beta (p - omega v)
                      // TODO: Is it safe to call MvAddMv with A or B = mv?
                      // TODO: Not all of these things have to be part of the state
                
                      axpy(one, *P_, omega_, *V_, *P_, true); // p = p - omega v
                      axpy(one, *R_, beta, *P_, *P_); // p = r + beta (p - omega v)
                    std::clock_t c_start4 = std::clock();
                    std::cout << "Belos_p_i " << 1000*(c_start4 - c_start3)/(double)CLOCKS_PER_SEC << std::endl; 
                
                      // y = K\p, unless K does not exist
                      // TODO: There may be a more efficient way to apply the preconditioners
                      if(lp_->isLeftPrec()) {
                        if(lp_->isRightPrec()) {
                          if(leftPrecVec == Teuchos::null) {
                            leftPrecVec = MVT::Clone( *R_, numRHS_ );
                          }
                          lp_->applyLeftPrec(*P_,*leftPrecVec);
                          lp_->applyRightPrec(*leftPrecVec,*Y);
                        }
                        else {
                          lp_->applyLeftPrec(*P_,*Y);
                        }
                      }
                      else if(lp_->isRightPrec()) {
                        lp_->applyRightPrec(*P_,*Y);
                      }
                
                      // v = Ay
                      lp_->applyOp(*Y,*V_);
                    std::clock_t c_start5 = std::clock();
                    std::cout << "Belos_v_i " << 1000*(c_start5 - c_start4)/(double)CLOCKS_PER_SEC << std::endl; 
                
                      // alpha = rho_new / <Rhat, V>
                      MVT::MvDot(*V_,*Rhat_,rhatV);
                      for(i=0; i<numRHS_; i++) {
                        alpha_[i] = rho_new[i] / rhatV[i];
                      }
                     std::clock_t c_start6 = std::clock();
                     std::cout << "Belos_alpha " << 1000*(c_start6 - c_start5)/(double)CLOCKS_PER_SEC << std::endl;
                
                //      for(i=0; i<numRHS_; i++) {
                //        std::cout << "alpha[" << i << "] = " << alpha_[i] << std::endl;
                //      }
                
                      // s = r - alpha v
                      axpy(one, *R_, alpha_, *V_, *S, true);
                     std::clock_t c_start7 = std::clock();
                     std::cout << "Belos_s " << 1000*(c_start7 - c_start6)/(double)CLOCKS_PER_SEC << std::endl;
                
                      // z = K\s, unless K does not exist
                      if(lp_->isLeftPrec()) {
                        if(lp_->isRightPrec()) {
                          if(leftPrecVec == Teuchos::null) {
                            leftPrecVec = MVT::Clone( *R_, numRHS_ );
                          }
                          lp_->applyLeftPrec(*S,*leftPrecVec);
                          lp_->applyRightPrec(*leftPrecVec,*Z);
                        }
                        else {
                          lp_->applyLeftPrec(*S,*Z);
                        }
                      }
                      else if(lp_->isRightPrec()) {
                        lp_->applyRightPrec(*S,*Z);
                      }
                
                      // t = Az
                      lp_->applyOp(*Z,*T);
                     std::clock_t c_start8 = std::clock();
                     std::cout << "Belos_t" << 1000*(c_start8 - c_start7)/(double)CLOCKS_PER_SEC << std::endl;
                
                //      std::cout << "T:\n";
                //      T->Print(std::cout);
                
                      // omega = <K1\t,K1\s> / <K1\t,K1\t>
                      if(lp_->isLeftPrec()) {
                        if(leftPrecVec == Teuchos::null) {
                          leftPrecVec = MVT::Clone( *R_, numRHS_ );
                        }
                        if(leftPrecVec2 == Teuchos::null) {
                          leftPrecVec2 = MVT::Clone( *R_, numRHS_ );
                        }
                        lp_->applyLeftPrec(*T,*leftPrecVec2);
                        MVT::MvDot(*leftPrecVec2,*leftPrecVec2,tT);
                        MVT::MvDot(*leftPrecVec,*leftPrecVec2,tS);
                      }
                      else {
                        MVT::MvDot(*T,*T,tT);
                        MVT::MvDot(*T,*S,tS);
                      }
                      for(i=0; i<numRHS_; i++) {
                        omega_[i] = tS[i] / tT[i];
                      }
                
                      std::clock_t c_start9 = std::clock();
                      std::cout << "Belos_omega_i " << 1000*(c_start9 - c_start8)/(double)CLOCKS_PER_SEC << std::endl;
                //      for(i=0; i<numRHS_; i++) {
                //        std::cout << "omega[" << i << "] = " << omega_[i] << " = " << tS[i] << " / " << tT[i] << std::endl;
                //      }
                
                      // x = x + alpha y + omega z
                      axpy(one, *X, alpha_, *Y, *X); // x = x + alpha y
                      axpy(one, *X, omega_, *Z, *X); // x = x + alpha y + omega z
                
                      std::clock_t c_start10 = std::clock();
                      std::cout << "Belos_x_i " << 1000*(c_start10 - c_start9)/(double)CLOCKS_PER_SEC << std::endl;
                      // r = s - omega t
                      axpy(one, *S, omega_, *T, *R_, true);
                      std::clock_t c_start11 = std::clock();
                      std::cout << "Belos_ r_i " << 1000*(c_start11 - c_start10)/(double)CLOCKS_PER_SEC << std::endl;
                
                      // Update rho_old
                      rho_old_ = rho_new;
                    } // end while (sTest_->checkStatus(this) != Passed)
                    std::clock_t c_start12 = std::clock();
                    std::cout << " Belos total iter loop " << 1000*(c_start12 - c_start0)/(double) CLOCKS_PER_SEC << std::endl;   
                  }
                
                
                  //////////////////////////////////////////////////////////////////////////////////////////////////
                  // Iterate until the status test informs us we should stop.
                  template <class ScalarType, class MV, class OP>
                  void BiCGStabIter<ScalarType,MV,OP>::axpy(const ScalarType alpha, const MV & A,
                                                            const std::vector<ScalarType> beta, const MV& B, MV& mv, bool minus)
                  {
                    Teuchos::RCP<const MV> A1, B1;
                    Teuchos::RCP<MV> mv1;
                    std::vector<int> index(1);
                
                    for(int i=0; i<numRHS_; i++) {
                      index[0] = i;
                      A1 = MVT::CloneView(A,index);
                      B1 = MVT::CloneView(B,index);
                      mv1 = MVT::CloneViewNonConst(mv,index);
                      if(minus) {
                        MVT::MvAddMv(alpha,*A1,-beta[i],*B1,*mv1);
                      }
                      else {
                        MVT::MvAddMv(alpha,*A1,beta[i],*B1,*mv1);
                      }
                    }
                  }
                
                } // end Belos namespace
                
                #endif /* BELOS_BICGSTAB_ITER_HPP */


Top 10 Lines:

     Line      Count

      244          9
      222          4
      230          4
      247          1
      327          1
      454          1

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

       20   Total number of line executions
     1.54   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosLinearProblem.hpp:
                
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_LINEAR_PROBLEM_HPP
                #define BELOS_LINEAR_PROBLEM_HPP
                
                /// \file BelosLinearProblem.hpp 
                /// \brief Class which describes the linear problem to be solved by
                ///   the iterative solver.
                #include "BelosMultiVecTraits.hpp"
                #include "BelosOperatorTraits.hpp"
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_TimeMonitor.hpp"
                
                namespace Belos {
                
                  //! @name LinearProblem Exceptions
                  //@{
                  
                  /// \class LinearProblemError
                  /// \brief Exception thrown to signal error with the Belos::LinearProblem object.
                  class LinearProblemError : public BelosError {
                  public: 
                    LinearProblemError (const std::string& what_arg) : 
                      BelosError(what_arg) {}
                  };
                  
                  //@}
                
                  /// \class LinearProblem  
                  /// \brief A linear system to solve, and its associated information.
                  ///
                  /// This class encapsulates the general information needed for
                  /// solving a linear system of equations using an iterative method.
                  ///
                  /// \tparam ScalarType The type of the entries in the matrix and
                  ///   vectors.
                  /// \tparam MV The (multi)vector type.
                  /// \tparam OP The operator type.  (Operators are functions that
                  ///   take a multivector as input and compute a multivector as
                  ///   output.)
                  template <class ScalarType, class MV, class OP>
                  class LinearProblem {
                  public:
                    
                    //! @name Constructors/Destructor
                    //@{ 
                
                    /// \brief Default constructor.
                    ///
                    /// Creates an empty Belos::LinearProblem instance.  The operator
                    /// A, left-hand-side X and right-hand-side B must be set using
                    /// the \c setOperator(), \c setLHS(), and \c setRHS() methods
                    /// respectively.
                    LinearProblem (void);
                    
                    /// \brief Unpreconditioned linear system constructor.
                    ///
                    /// Creates an unpreconditioned LinearProblem instance with the
                    /// operator (\c A), initial guess (\c X), and right hand side (\c
                    /// B).  Preconditioners can be set using the \c setLeftPrec() and
                    /// \c setRightPrec() methods, and scaling can also be set using
                    /// the \c setLeftScale() and \c setRightScale() methods.
                    LinearProblem (const Teuchos::RCP<const OP> &A, 
                		   const Teuchos::RCP<MV> &X, 
                		   const Teuchos::RCP<const MV> &B);
                    
                    /// \brief Copy constructor.
                    ///
                    /// Makes a copy of an existing LinearProblem instance.
                    LinearProblem (const LinearProblem<ScalarType,MV,OP>& Problem);
                    
                    //! Destructor (declared virtual for memory safety of derived classes).
                    virtual ~LinearProblem (void);
                
                    //@}
                    
                    //! @name Set methods
                    //@{ 
                    
                    /// \brief Set the operator A of the linear problem \f$AX = B\f$.
                    /// 
                    /// The operator is set by pointer; no copy of the operator is made.
                    void setOperator (const Teuchos::RCP<const OP> &A) { 
                      A_ = A; 
                      isSet_=false; 
                    }
                    
                    /// \brief Set left-hand-side X of linear problem \f$AX = B\f$.
                    ///
                    /// Setting the "left-hand side" sets the starting vector (also
                    /// called "initial guess") of an iterative method.  The
                    /// multivector is set by pointer; no copy of the object is made.
                    /// Belos' solvers will modify this multivector in place.
                    void setLHS (const Teuchos::RCP<MV> &X) { 
                      X_ = X; 
                      isSet_=false; 
                    }
                    
                    /// \brief Set right-hand-side B of linear problem \f$AX = B\f$.
                    ///
                    /// The multivector is set by pointer; no copy of the object is
                    /// made.
                    void setRHS (const Teuchos::RCP<const MV> &B) { 
                      B_ = B; 
                      isSet_=false; 
                    }
                
                    /// \brief Set the user-defined residual of linear problem \f$AX = B\f$.
                    ///
                    /// The multivector is set by pointer; no copy of the object is made.
                    void setInitResVec(const Teuchos::RCP<const MV> &R0) {
                      R0_user_ = R0;
                      isSet_=false;
                    }
                
                    /// \brief Set the user-defined preconditioned residual of linear problem \f$AX = B\f$.
                    ///
                    /// The multivector is set by pointer; no copy of the object is made.
                    void setInitPrecResVec(const Teuchos::RCP<const MV> &PR0) {
                      PR0_user_ = PR0;
                      isSet_=false;
                    }
                    
                    /// \brief Set left preconditioner (\c LP) of linear problem \f$AX = B\f$.
                    ///
                    /// The operator is set by pointer; no copy of the operator is made.
                    void setLeftPrec(const Teuchos::RCP<const OP> &LP) {  LP_ = LP; }
                
                    /// \brief Set right preconditioner (\c RP) of linear problem \f$AX = B\f$.
                    ///
                    /// The operator is set by pointer; no copy of the operator is made.
                    void setRightPrec(const Teuchos::RCP<const OP> &RP) { RP_ = RP; }
                
                    /// Tell the linear problem that the solver is finished with the current linear system.
                    ///
                    /// \note This method is <b>only</b> to be used by the solver to
                    ///   inform the linear problem that it is finished with the
                    ///   current block of linear systems.  The next time that
                    ///   Curr{RHS, LHS}Vec() is called, the next linear system will
                    ///   be returned.  Computing the next linear system isn't done in
                    ///   this method in case the block size is changed.
                    void setCurrLS ();
                
                    /// \brief Tell the linear problem which linear system(s) need to be solved next.
                    ///
                    /// Any calls to get the current RHS/LHS vectors after this method
                    /// is called will return the new linear system(s) indicated by \c
                    /// index.  The length of \c index is assumed to be the blocksize.
                    /// Entries of \c index must be between 0 and the number of
                    /// vectors in the RHS/LHS multivector.  An entry of \c index may
                    /// also be -1, which means this column of the linear system is
                    /// augmented using a random vector.
                    void setLSIndex (const std::vector<int>& index); 
                    
                    /// \brief Tell the linear problem that the (preconditioned) operator is Hermitian.
                    ///
                    /// This knowledge may allow the operator to take advantage of the
                    /// linear problem's symmetry.  However, this method should not be
                    /// called if the preconditioned operator is not Hermitian (or
                    /// symmetric in real arithmetic).
                    ///
                    /// We make no attempt to detect the symmetry of the operators, so
                    /// we cannot check whether this method has been called
                    /// incorrectly.
                    void setHermitian( bool isSym = true ) { isHermitian_ = isSym; }
                   
                    /// \brief Set the label prefix used by the timers in this object.  
                    ///
                    /// The default label prefix is "Belos".  The timers are created
                    /// during the call to \c setProblem().  If they have already been
                    /// created and this label is different than the current one, then
                    /// this method will generate a new timer.
                    void setLabel (const std::string& label);
                
                    /// \brief Compute the new solution to the linear system using the
                    ///   given update vector.
                    ///
                    /// Let \f$\delta\f$ be the update vector, \f$\alpha\f$ the scale
                    /// factor, and \f$x\f$ the current solution.  If there is a right
                    /// preconditioner \f$M_R^{-1}\f$, then we compute the new
                    /// solution as \f$x + \alpha M_R^{-1} \delta\f$.  Otherwise, if
                    /// there is no right preconditioner, we compute the new solution
                    /// as \f$x + \alpha \delta\f$.
                    ///
                    /// This method always returns the new solution.  If updateLP is
                    /// false, it computes the new solution as a deep copy, without
                    /// modifying the internally stored current solution.  If updateLP
                    /// is true, it computes the new solution in place, and returns a
                    /// pointer to the internally stored solution.
                    ///
                    /// \param update [in/out] The solution update vector.  If null,
                    ///   this method returns a pointer to the new solution.
                    ///
                    /// \param updateLP [in] This is ignored if the update vector is
                    ///   null.  Otherwise, if updateLP is true, the following things
                    ///   happen: (a) this LinearProblem's stored solution is updated
                    ///   in place, and (b) the next time \c GetCurrResVecs() is
                    ///   called, a new residual will be computed.  If updateLP is
                    ///   false, then the new solution is computed and returned as a
                    ///   copy, without modifying this LinearProblem's stored current
                    ///   solution.
                    ///
                    /// \param scale [in] The factor \f$\alpha\f$ by which to multiply
                    ///   the solution update vector when computing the update.  This
                    ///   is ignored if the update vector is null.
                    ///
                    /// \return A pointer to the new solution.  This is freshly
                    ///   allocated if updateLP is false, otherwise it is a view of
                    ///   the LinearProblem's stored current solution.
                    ///
                    Teuchos::RCP<MV> 
                    updateSolution (const Teuchos::RCP<MV>& update = Teuchos::null,
                		    bool updateLP = false,
                		    ScalarType scale = Teuchos::ScalarTraits<ScalarType>::one());    
                
                    /// \brief Compute the new solution to the linear system using the
                    ///   given update vector.
                    ///
                    /// This method does the same thing as calling the three-argument
                    /// version of updateSolution() with updateLP = false.  It does
                    /// not update the linear problem or change the linear problem's
                    /// state in any way.
                    ///
                    /// \param update [in/out] The solution update vector.  If null,
                    ///   this method returns a pointer to the new solution.
                    ///
                    /// \param scale [in] The factor \f$\alpha\f$ by which to multiply
                    ///   the solution update vector when computing the update.  This
                    ///   is ignored if the update vector is null.
                    ///
                    /// \return A pointer to the new solution. 
                    ///
                    Teuchos::RCP<MV> updateSolution( const Teuchos::RCP<MV>& update = Teuchos::null,
                                                    ScalarType scale = Teuchos::ScalarTraits<ScalarType>::one() ) const
                    { return const_cast<LinearProblem<ScalarType,MV,OP> *>(this)->updateSolution( update, false, scale ); }
                
                    //@}
                    
                    //! @name Set / Reset method
                    //@{ 
                    
                    /// \brief Set up the linear problem manager.
                    ///
                    /// Call this method if you want to solve the linear system with a
                    /// different left- or right-hand side, or if you want to prepare
                    /// the linear problem to solve the linear system that was already
                    /// passed in.  (In the latter case, call this method with the
                    /// default arguments.)  The internal flags will be set as if the
                    /// linear system manager was just initialized, and the initial
                    /// residual will be computed.
                    ///
                    /// Many of Belos' solvers require that this method has been
                    /// called on the linear problem, before they can solve it.
                    ///
                    /// \param newX [in/out] If you want to solve the linear system
                    ///   with a different left-hand side, pass it in here.
                    ///   Otherwise, set this to null (the default value).
                    ///
                    /// \param newB [in] If you want to solve the linear system with a
                    ///   different right-hand side, pass it in here.  Otherwise, set
                    ///   this to null (the default value).
                    ///
                    /// \return Whether the linear problem was successfully set up.
                    ///   Successful setup requires at least that the matrix operator
                    ///   A, the left-hand side X, and the right-hand side B all be
                    ///   non-null.
                    bool 
                    setProblem (const Teuchos::RCP<MV> &newX = Teuchos::null, 
                		const Teuchos::RCP<const MV> &newB = Teuchos::null);
                
                    //@}
                    
                    //! @name Accessor methods
                    //@{ 
                    
                    //! A pointer to the (unpreconditioned) operator A.
                    Teuchos::RCP<const OP> getOperator() const { return(A_); }
                    
                    //! A pointer to the left-hand side X.
                    Teuchos::RCP<MV> getLHS() const { return(X_); }
                    
                    //! A pointer to the right-hand side B.
                    Teuchos::RCP<const MV> getRHS() const { return(B_); }
                    
                    //! A pointer to the initial unpreconditioned residual vector.
                    Teuchos::RCP<const MV> getInitResVec() const;
                    
                    /// \brief A pointer to the preconditioned initial residual vector.
                    ///
                    /// \note This is the preconditioned residual if the linear system
                    ///   is left preconditioned.
                    Teuchos::RCP<const MV> getInitPrecResVec() const;
                    
                    /// \brief Get a pointer to the current left-hand side (solution) of the linear system.
                    ///
                    /// This method is called by the solver or any method that is
                    /// interested in the current linear system being solved.
                    ///   - If the solution has been updated by the solver, then this
                    ///     vector is current ( see \c isSolutionUpdated() ).
                    ///   - If there is no linear system to solve, this method returns
                    ///     a null pointer.
                    ///
                    /// This method is <i>not</i> the same thing as \c getLHS().  The
                    /// \c getLHS() method just returns a pointer to the original
                    /// left-hand side vector.  This method only returns a valid
                    /// vector if the current subset of right-hand side(s) to solve
                    /// has been set (via the \c setLSIndex() method).
                    Teuchos::RCP<MV> getCurrLHSVec();
                    
                    /// \brief Get a pointer to the current right-hand side of the linear system.
                    ///
                    /// This method is called by the solver or any method that is
                    /// interested in the current linear system being solved.
                    ///   - If the solution has been updated by the solver, then this
                    ///     vector is current ( see \c isSolutionUpdated() ).
                    ///   - If there is no linear system to solve, this method returns
                    ///     a null pointer.
                    ///
                    /// This method is <i>not</i> the same thing as \c getRHS().  The
                    /// \c getRHS() method just returns a pointer to the original
                    /// right-hand side vector.  This method only returns a valid
                    /// vector if the current subset of right-hand side(s) to solve
                    /// has been set (via the \c setLSIndex() method).
                    Teuchos::RCP<const MV> getCurrRHSVec();
                    
                    //! Get a pointer to the left preconditioner.
                    Teuchos::RCP<const OP> getLeftPrec() const { return(LP_); };
                    
                    //! Get a pointer to the right preconditioner.
                    Teuchos::RCP<const OP> getRightPrec() const { return(RP_); };
                    
                    /// \brief (Zero-based) indices of the linear system(s) currently being solved.
                    ///
                    /// Since the block size is independent of the number of
                    /// right-hand sides for some solvers (GMRES, CG, etc.), it is
                    /// important to know which linear systems are being solved.  That
                    /// may mean you need to update the information about the norms of
                    /// your initial residual vector for weighting purposes.  This
                    /// information can help you avoid querying the solver for
                    /// information that rarely changes.
                    ///
                    /// \note The length of the returned index vector is the number of
                    ///   right-hand sides currently being solved.  If an entry of the
                    ///   index vector is -1, then the corresponding linear system is
                    ///   an augmented linear system and doesn't need to be considered
                    ///   for convergence.
                    /// 
                    /// \note The index vector returned from this method can only be
                    ///   nonempty if \c setLSIndex() has been called with a nonempty
                    ///   index vector argument, or if this linear problem was
                    ///   constructed via the copy constructor of a linear problem
                    ///   with a nonempty index vector.
                    const std::vector<int> getLSIndex() const { return(rhsIndex_); }
                
                    /// \brief The number of linear systems that have been set.
                    ///
                    /// This can be used by status test classes to determine if the
                    /// solver manager has advanced and is solving another linear
                    /// system.  This is incremented by one every time that \c
                    /// setLSIndex() completes successfully.
                    int getLSNumber() const { return(lsNum_); }
                
                    /*! \brief The timers for this object.
                     *
                     * The timers are ordered as follows:
                     *   - time spent applying operator
                     *   - time spent applying preconditioner
                     */
                    Teuchos::Array<Teuchos::RCP<Teuchos::Time> > getTimers() const {
                      return Teuchos::tuple(timerOp_,timerPrec_);
                    }
                
                
                    //@}
                    
                    //! @name State methods
                    //@{ 
                    
                    /// \brief Has the current approximate solution been updated?
                    ///
                    /// This only means that the current linear system for which the
                    /// solver is solving (as obtained by getCurr{LHS, RHS}Vec()) has
                    /// been updated by the solver.  This will be true every iteration
                    /// for solvers like CG, but not true for solvers like GMRES until
                    /// the solver restarts.
                    bool isSolutionUpdated() const { return(solutionUpdated_); }
                
                    //! Whether the problem has been set.
                    bool isProblemSet() const { return(isSet_); }
                
                    /// \brief Whether the (preconditioned) operator is Hermitian.
                    ///
                    /// If preconditioner(s) are defined and this method returns true,
                    /// then the entire preconditioned operator is Hermitian (or
                    /// symmetric in real arithmetic).
                    bool isHermitian() const { return(isHermitian_); }
                    
                    //! Whether the linear system is being preconditioned on the left.
                    bool isLeftPrec() const { return(LP_!=Teuchos::null); }
                
                    //! Whether the linear system is being preconditioned on the right.
                    bool isRightPrec() const { return(RP_!=Teuchos::null); }
                 
                    //@}
                    
                    //! @name Apply / Compute methods
                    //@{ 
                    
                    //! Apply the composite operator of this linear problem to \c x, returning \c y.
                    /*! This application is the composition of the left/right preconditioner and operator.
                      Most Krylov methods will use this application method within their code.
                      
                      Precondition:<ul>
                      <li><tt>getOperator().get()!=NULL</tt>
                      </ul>
                    */
                    void apply( const MV& x, MV& y ) const;
                    
                    /// \brief Apply ONLY the operator to \c x, returning \c y.
                    ///
                    /// This method only applies the linear problem's operator,
                    /// without any preconditioners that may have been defined.
                    /// Flexible variants of Krylov methods will use this method.  If
                    /// no operator has been defined, this method just copies x into
                    /// y.
                    void applyOp( const MV& x, MV& y ) const;
                    
                    /// \brief Apply ONLY the left preconditioner to \c x, returning \c y.
                    ///
                    /// This method only applies the left preconditioner.  This may be
                    /// required for flexible variants of Krylov methods.  If no left
                    /// preconditioner has been defined, this method just copies x
                    /// into y.
                    void applyLeftPrec( const MV& x, MV& y ) const;
                
                    /// \brief Apply ONLY the right preconditioner to \c x, returning \c y.
                    ///
                    /// This method only applies the right preconditioner.  This may
                    /// be required for flexible variants of Krylov methods.  If no
                    /// right preconditioner has been defined, this method just copies
                    /// x into y.
                    void applyRightPrec( const MV& x, MV& y ) const;
                    
                    //! Compute a residual \c R for this operator given a solution \c X, and right-hand side \c B.
                    /*! This method will compute the residual for the current linear system if \c X and \c B are null pointers.
                      The result will be returned into R.  Otherwise <tt>R = OP(A)X - B</tt> will be computed and returned.
                      \note This residual will not be preconditioned if the system has a left preconditioner.
                    */
                    void computeCurrResVec( MV* R , const MV* X = 0, const MV* B = 0 ) const;
                
                    //! Compute a residual \c R for this operator given a solution \c X, and right-hand side \c B.
                    /*! This method will compute the residual for the current linear system if \c X and \c B are null pointers.
                      The result will be returned into R.  Otherwise <tt>R = OP(A)X - B</tt> will be computed and returned.
                      \note This residual will be preconditioned if the system has a left preconditioner.
                    */
                    void computeCurrPrecResVec( MV* R, const MV* X = 0, const MV* B = 0 ) const;
                    
                    //@}
                    
                  private:
                    
                    //! Operator of linear system. 
                    Teuchos::RCP<const OP> A_;
                    
                    //! Solution vector of linear system.
                    Teuchos::RCP<MV> X_;
                    
                    //! Current solution vector of the linear system.
                    Teuchos::RCP<MV> curX_;
                    
                    //! Right-hand side of linear system.
                    Teuchos::RCP<const MV> B_;
                    
                    //! Current right-hand side of the linear system.
                    Teuchos::RCP<const MV> curB_;
                    
                    //! Initial residual of the linear system.
                    Teuchos::RCP<MV> R0_;
                   
                    //! Preconditioned initial residual of the linear system.
                    Teuchos::RCP<MV> PR0_;
                
                    //! User-defined initial residual of the linear system
                    Teuchos::RCP<const MV> R0_user_;
                
                    //! User-defined preconditioned initial residual of the linear system
                    Teuchos::RCP<const MV> PR0_user_;
                 
                    //! Left preconditioning operator of linear system
                    Teuchos::RCP<const OP> LP_;  
                    
                    //! Right preconditioning operator of linear system
                    Teuchos::RCP<const OP> RP_;
                    
                    //! Timers
                    mutable Teuchos::RCP<Teuchos::Time> timerOp_, timerPrec_;
                
                    //! Current block size of linear system.
                    int blocksize_;
                
                    //! Number of linear systems that are currently being solver for ( <= blocksize_ )
                    int num2Solve_;
                    
                    //! Indices of current linear systems being solver for.
                    std::vector<int> rhsIndex_;    
                
                    //! Number of linear systems that have been loaded in this linear problem object.
                    int lsNum_;
                
                    //! @name Booleans to keep track of linear problem attributes and status.
                    //@{ 
                
                    //! Is there a left scaling?
                    bool Left_Scale_;
                
                    //! Is there a right scaling?
                    bool Right_Scale_;
                
                    //! Has the linear problem to solve been set?
                    bool isSet_;
                
                    /// Whether the operator A is symmetric (in real arithmetic, or
                    /// Hermitian in complex arithmetic).
                    bool isHermitian_;
                
                    //! Has the current approximate solution been updated?
                    bool solutionUpdated_;    
                
                    //@}
                   
                    //! Linear problem label that prefixes the timer labels.
                    std::string label_;
                 
                    typedef MultiVecTraits<ScalarType,MV>  MVT;
                    typedef OperatorTraits<ScalarType,MV,OP>  OPT;
                  };
                  
                  //--------------------------------------------
                  //  Constructor Implementations
                  //--------------------------------------------
                  
                  template <class ScalarType, class MV, class OP>
                  LinearProblem<ScalarType,MV,OP>::LinearProblem(void) : 
                    blocksize_(0),
                    num2Solve_(0),
                    rhsIndex_(0),
                    lsNum_(0),
                    Left_Scale_(false),
                    Right_Scale_(false),
                    isSet_(false),
                    isHermitian_(false),
                    solutionUpdated_(false),
                    label_("Belos")
                  {
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  LinearProblem<ScalarType,MV,OP>::LinearProblem(const Teuchos::RCP<const OP> &A, 
                						 const Teuchos::RCP<MV> &X, 
                						 const Teuchos::RCP<const MV> &B
                						 ) :
                    A_(A),
                    X_(X),
                    B_(B),
                    blocksize_(0),
                    num2Solve_(0),
                    rhsIndex_(0),
                    lsNum_(0),
                    Left_Scale_(false),
                    Right_Scale_(false),
                    isSet_(false),
                    isHermitian_(false),
                    solutionUpdated_(false),
                    label_("Belos")
                  {
                  }
                  
                  template <class ScalarType, class MV, class OP>
           4 ->   LinearProblem<ScalarType,MV,OP>::LinearProblem(const LinearProblem<ScalarType,MV,OP>& Problem) :
                    A_(Problem.A_),
                    X_(Problem.X_),
                    curX_(Problem.curX_),
                    B_(Problem.B_),
                    curB_(Problem.curB_),
                    R0_(Problem.R0_),
                    PR0_(Problem.PR0_),
                    R0_user_(Problem.R0_user_),
                    PR0_user_(Problem.PR0_user_),
                    LP_(Problem.LP_),
                    RP_(Problem.RP_),
                    timerOp_(Problem.timerOp_),
                    timerPrec_(Problem.timerPrec_),
                    blocksize_(Problem.blocksize_),
                    num2Solve_(Problem.num2Solve_),
                    rhsIndex_(Problem.rhsIndex_),
                    lsNum_(Problem.lsNum_),
                    Left_Scale_(Problem.Left_Scale_),
                    Right_Scale_(Problem.Right_Scale_),
                    isSet_(Problem.isSet_),
                    isHermitian_(Problem.isHermitian_),
                    solutionUpdated_(Problem.solutionUpdated_),
                    label_(Problem.label_)
                  {
                  }
                  
                  template <class ScalarType, class MV, class OP>
       ##### ->   LinearProblem<ScalarType,MV,OP>::~LinearProblem(void)
                  {}
                  
                  template <class ScalarType, class MV, class OP>
           1 ->   void LinearProblem<ScalarType,MV,OP>::setLSIndex(const std::vector<int>& index)
                  {
                    // Set new linear systems using the indices in index.
                    rhsIndex_ = index;
                    
                    // Compute the new block linear system.
                    // ( first clean up old linear system )
                    curB_ = Teuchos::null;
                    curX_ = Teuchos::null;
                   
                    // Create indices for the new linear system.
                    int validIdx = 0, ivalidIdx = 0;
                    blocksize_ = rhsIndex_.size();
                    std::vector<int> vldIndex( blocksize_ );
                    std::vector<int> newIndex( blocksize_ );
                    std::vector<int> iIndex( blocksize_ );
                    for (int i=0; i<blocksize_; ++i) {
                      if (rhsIndex_[i] > -1) {
                        vldIndex[validIdx] = rhsIndex_[i];
                        newIndex[validIdx] = i;
                        validIdx++;
                      }
                      else {
                        iIndex[ivalidIdx] = i;
                        ivalidIdx++;
                      }
                    }
                    vldIndex.resize(validIdx);
                    newIndex.resize(validIdx);   
                    iIndex.resize(ivalidIdx);
                    num2Solve_ = validIdx;
                
                    // Create the new linear system using index
                    if (num2Solve_ != blocksize_) {
                      newIndex.resize(num2Solve_);
                      vldIndex.resize(num2Solve_);
                      //
                      // First create multivectors of blocksize.
                      // Fill the RHS with random vectors LHS with zero vectors.
                      curX_ = MVT::Clone( *X_, blocksize_ );
                      MVT::MvInit(*curX_);
                      Teuchos::RCP<MV> tmpCurB = MVT::Clone( *B_, blocksize_ );
                      MVT::MvRandom(*tmpCurB);
                      //
                      // Now put in the part of B into curB 
                      Teuchos::RCP<const MV> tptr = MVT::CloneView( *B_, vldIndex );
                      MVT::SetBlock( *tptr, newIndex, *tmpCurB );
                      curB_ = tmpCurB;
                      //
                      // Now put in the part of X into curX
                      tptr = MVT::CloneView( *X_, vldIndex );
                      MVT::SetBlock( *tptr, newIndex, *curX_ );
                      //
                      solutionUpdated_ = false;
                    }
                    else {
                      curX_ = MVT::CloneViewNonConst( *X_, rhsIndex_ );
                      curB_ = MVT::CloneView( *B_, rhsIndex_ );
                    }
                    //
                    // Increment the number of linear systems that have been loaded into this object.
                    //
                    lsNum_++;
                  }
                
                
                  template <class ScalarType, class MV, class OP>
           1 ->   void LinearProblem<ScalarType,MV,OP>::setCurrLS() 
                  { 
                    //
                    // We only need to copy the solutions back if the linear systems of
                    // interest are less than the block size.
                    //
                    if (num2Solve_ < blocksize_) {
                      //
                      // Get a view of the current solutions and correction std::vector.
                      //
                      int validIdx = 0;
                      std::vector<int> newIndex( num2Solve_ );
                      std::vector<int> vldIndex( num2Solve_ );
                      for (int i=0; i<blocksize_; ++i) {
                        if ( rhsIndex_[i] > -1 ) { 
                          vldIndex[validIdx] = rhsIndex_[i];
                	  newIndex[validIdx] = i;
                          validIdx++;
                        }	
                      }
                      Teuchos::RCP<MV> tptr = MVT::CloneViewNonConst( *curX_, newIndex );
                      MVT::SetBlock( *tptr, vldIndex, *X_ );
                    }
                    //
                    // Clear the current vectors of this linear system so that any future calls
                    // to get the vectors for this system return null pointers.
                    //
                    curX_ = Teuchos::null;
                    curB_ = Teuchos::null;
                    rhsIndex_.resize(0);
                  }
                  
                
                  template <class ScalarType, class MV, class OP>
                  Teuchos::RCP<MV> 
                  LinearProblem<ScalarType,MV,OP>::
                  updateSolution (const Teuchos::RCP<MV>& update, 
                		  bool updateLP,
                		  ScalarType scale)
                  { 
                    using Teuchos::RCP;
                    using Teuchos::null;
                
                    RCP<MV> newSoln;
                    if (update.is_null())
                      { // The caller didn't supply an update vector, so we assume
                	// that the current solution curX_ is unchanged, and return a
                	// pointer to it.
                	newSoln = curX_;
                      }
                    else // the update vector is NOT null.
                      { 
                	if (updateLP) // The caller wants us to update the linear problem.
                	  { 
                	    if (RP_.is_null()) 
                	      { // There is no right preconditioner.
                		// curX_ := curX_ + scale * update.
                		MVT::MvAddMv( 1.0, *curX_, scale, *update, *curX_ ); 
                	      }
                	    else 
                	      { // There is indeed a right preconditioner, so apply it
                		// before computing the new solution.
                		RCP<MV> rightPrecUpdate = 
                		  MVT::Clone (*update, MVT::GetNumberVecs (*update));
                		{
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                		  Teuchos::TimeMonitor PrecTimer (*timerPrec_);
                #endif
                		  OPT::Apply( *RP_, *update, *rightPrecUpdate ); 
                		}
                		// curX_ := curX_ + scale * rightPrecUpdate.
                		MVT::MvAddMv( 1.0, *curX_, scale, *rightPrecUpdate, *curX_ ); 
                	      } 
                	    solutionUpdated_ = true; 
                	    newSoln = curX_;
                	  }
                	else 
                	  { // Rather than updating our stored current solution curX_,
                	    // we make a copy and compute the new solution in the
                	    // copy, without modifying curX_.
                	    newSoln = MVT::Clone (*update, MVT::GetNumberVecs (*update));
                	    if (RP_.is_null())
                	      { // There is no right preconditioner.
                		// newSoln := curX_ + scale * update.
                		MVT::MvAddMv( 1.0, *curX_, scale, *update, *newSoln ); 
                	      }
                	    else 
                	      { // There is indeed a right preconditioner, so apply it
                		// before computing the new solution.
                		RCP<MV> rightPrecUpdate = 
                		  MVT::Clone (*update, MVT::GetNumberVecs (*update));
                		{
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                		  Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                		  OPT::Apply( *RP_, *update, *rightPrecUpdate ); 
                		}
                		// newSoln := curX_ + scale * rightPrecUpdate.
                		MVT::MvAddMv( 1.0, *curX_, scale, *rightPrecUpdate, *newSoln ); 
                	      } 
                	  }
                      }
                    return newSoln;
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  void LinearProblem<ScalarType,MV,OP>::setLabel(const std::string& label)
                  {
                    if (label != label_) {
                      label_ = label;
                      // Create new timers if they have already been created.
                      if (timerOp_ != Teuchos::null) {
                        std::string opLabel = label_ + ": Operation Op*x";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                        timerOp_ = Teuchos::TimeMonitor::getNewCounter( opLabel );
                #endif
                      }
                      if (timerPrec_ != Teuchos::null) {
                        std::string precLabel = label_ + ": Operation Prec*x";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                        timerPrec_ = Teuchos::TimeMonitor::getNewCounter( precLabel );
                #endif
                      }
                    }
                  }
                
                  template <class ScalarType, class MV, class OP>
                  bool 
       ##### ->   LinearProblem<ScalarType,MV,OP>::
                  setProblem (const Teuchos::RCP<MV> &newX, 
                	      const Teuchos::RCP<const MV> &newB)
                  {
                    // Create timers if the haven't been created yet.
                    if (timerOp_ == Teuchos::null) {
                      std::string opLabel = label_ + ": Operation Op*x";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      timerOp_ = Teuchos::TimeMonitor::getNewCounter( opLabel );
                #endif
                    }
                    if (timerPrec_ == Teuchos::null) {
                      std::string precLabel = label_ + ": Operation Prec*x";
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      timerPrec_ = Teuchos::TimeMonitor::getNewCounter( precLabel );
                #endif
                    }
                
                    // Set the linear system using the arguments newX and newB
                    if (newX != Teuchos::null)
                      X_ = newX;
                    if (newB != Teuchos::null)
                      B_ = newB;
                
                    // Invalidate the current linear system indices and multivectors.
                    rhsIndex_.resize(0);
                    curX_ = Teuchos::null;
                    curB_ = Teuchos::null;
                
                    // If we didn't set a matrix A, a left-hand side X, or a
                    // right-hand side B, then we didn't set the problem.
                    if (A_ == Teuchos::null || X_ == Teuchos::null || B_ == Teuchos::null) {
                      isSet_ = false;
                      return isSet_;
                    }
                
                    // Reset whether the solution has been updated.  (We're just
                    // setting the problem now, so of course we haven't updated the
                    // solution yet.)
                    solutionUpdated_ = false;
                    
                    // Compute the initial residuals.
                    if(Teuchos::is_null(R0_user_)) {
                      if (R0_==Teuchos::null || MVT::GetNumberVecs( *R0_ )!=MVT::GetNumberVecs( *B_ )) {
                        R0_ = MVT::Clone( *B_, MVT::GetNumberVecs( *B_ ) );
                      }
                      computeCurrResVec( &*R0_, &*X_, &*B_ );
                
                      if (LP_!=Teuchos::null) {
                        if (PR0_==Teuchos::null || (PR0_==R0_) || (MVT::GetNumberVecs(*PR0_)!=MVT::GetNumberVecs(*B_))) {
                          PR0_ = MVT::Clone( *B_, MVT::GetNumberVecs( *B_ ) );
                        }
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                          OPT::Apply( *LP_, *R0_, *PR0_ );
                        }
                      } 
                      else {
                        PR0_ = R0_;
                      }
                    }
                    else { // User specified the residuals
                      if (MVT::GetNumberVecs( *R0_user_ )!=MVT::GetNumberVecs( *B_ )) {
                        Teuchos::RCP<MV> helper = MVT::Clone( *B_, MVT::GetNumberVecs( *B_ ) );
                        computeCurrResVec( &*helper, &*X_, &*B_ );
                        R0_user_ = helper;
                      }
                
                      if (LP_!=Teuchos::null) {
                        if (PR0_user_==Teuchos::null || (PR0_user_==R0_) || (MVT::GetNumberVecs(*PR0_user_)!=MVT::GetNumberVecs(*B_))) {
                          Teuchos::RCP<MV> helper = MVT::Clone( *B_, MVT::GetNumberVecs( *B_ ) );
                          {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                            Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                            OPT::Apply( *LP_, *R0_user_, *helper );
                          }
                          PR0_user_ = helper;
                        }
                      }
                      else {
                        PR0_user_ = R0_user_;
                      }
                    }
                
                    // The problem has been set and is ready for use.
                    isSet_ = true;
                    
                    // Return isSet.
                    return isSet_;
                  }
                
                  template <class ScalarType, class MV, class OP>
           1 ->   Teuchos::RCP<const MV> LinearProblem<ScalarType,MV,OP>::getInitResVec() const 
                  {
                    if(Teuchos::nonnull(R0_user_)) {
                      return R0_user_;
                    }
                    return(R0_); 
                  }
                
                  template <class ScalarType, class MV, class OP>
       ##### ->   Teuchos::RCP<const MV> LinearProblem<ScalarType,MV,OP>::getInitPrecResVec() const 
                  { 
                    if(Teuchos::nonnull(PR0_user_)) {
                      return PR0_user_;
                    }
                    return(PR0_); 
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  Teuchos::RCP<MV> LinearProblem<ScalarType,MV,OP>::getCurrLHSVec()
                  {
                    if (isSet_) {
                      return curX_;
                    }
                    else {
                      return Teuchos::null;
                    }
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  Teuchos::RCP<const MV> LinearProblem<ScalarType,MV,OP>::getCurrRHSVec()
                  {
                    if (isSet_) {
                      return curB_;
                    }
                    else {
                      return Teuchos::null;
                    }
                  }
                  
                  template <class ScalarType, class MV, class OP>
       ##### ->   void LinearProblem<ScalarType,MV,OP>::apply( const MV& x, MV& y ) const
                  {
                    using Teuchos::null;
                    using Teuchos::RCP;
                
                    const bool leftPrec = LP_ != null;
                    const bool rightPrec = RP_ != null;
                
                    // We only need a temporary vector for intermediate results if
                    // there is a left or right preconditioner.  We really should just
                    // keep this temporary vector around instead of allocating it each
                    // time.
                    RCP<MV> ytemp = (leftPrec || rightPrec) ? MVT::Clone (y, MVT::GetNumberVecs (y)) : null;
                
                    //
                    // No preconditioning.
                    // 
                    if (!leftPrec && !rightPrec){ 
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                      OPT::Apply( *A_, x, y );
                    }
                    //
                    // Preconditioning is being done on both sides
                    //
                    else if( leftPrec && rightPrec ) 
                      {
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	  OPT::Apply( *RP_, x, y );   
                        }
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	  OPT::Apply( *A_, y, *ytemp );
                        }
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	  OPT::Apply( *LP_, *ytemp, y );
                        }
                      }
                    //
                    // Preconditioning is only being done on the left side
                    //
                    else if( leftPrec ) 
                      {
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	  OPT::Apply( *A_, x, *ytemp );
                        }
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	  OPT::Apply( *LP_, *ytemp, y );
                        }
                      }
                    //
                    // Preconditioning is only being done on the right side
                    //
                    else 
                      {
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	  OPT::Apply( *RP_, x, *ytemp );
                        }
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                      	  OPT::Apply( *A_, *ytemp, y );
                        }
                      }  
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  void LinearProblem<ScalarType,MV,OP>::applyOp( const MV& x, MV& y ) const {
                    if (A_.get()) {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                      OPT::Apply( *A_,x, y);   
                    }
                    else {
                      MVT::MvAddMv( Teuchos::ScalarTraits<ScalarType>::one(), x, 
                		    Teuchos::ScalarTraits<ScalarType>::zero(), x, y );
                    }
                  }
                  
                  template <class ScalarType, class MV, class OP>
       ##### ->   void LinearProblem<ScalarType,MV,OP>::applyLeftPrec( const MV& x, MV& y ) const {
                    if (LP_!=Teuchos::null) {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                      return ( OPT::Apply( *LP_,x, y) );
                    }
                    else {
                      MVT::MvAddMv( Teuchos::ScalarTraits<ScalarType>::one(), x, 
                		    Teuchos::ScalarTraits<ScalarType>::zero(), x, y );
                    }
                  }
                  
                  template <class ScalarType, class MV, class OP>
           6 ->   void LinearProblem<ScalarType,MV,OP>::applyRightPrec( const MV& x, MV& y ) const {
                    if (RP_!=Teuchos::null) {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                      Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                      return ( OPT::Apply( *RP_,x, y) );
                    }
                    else {
                      MVT::MvAddMv( Teuchos::ScalarTraits<ScalarType>::one(), x, 
                		    Teuchos::ScalarTraits<ScalarType>::zero(), x, y );
                    }
                  }
                  
                  template <class ScalarType, class MV, class OP>
                  void LinearProblem<ScalarType,MV,OP>::computeCurrPrecResVec( MV* R, const MV* X, const MV* B ) const {
                
                    if (R) {
                      if (X && B) // The entries are specified, so compute the residual of Op(A)X = B
                	{
                	  if (LP_!=Teuchos::null)
                	    {
                	      Teuchos::RCP<MV> R_temp = MVT::Clone( *B, MVT::GetNumberVecs( *B ) );
                              {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                                Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	        OPT::Apply( *A_, *X, *R_temp );
                              }
                	      MVT::MvAddMv( -1.0, *R_temp, 1.0, *B, *R_temp );
                              {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                                Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	        OPT::Apply( *LP_, *R_temp, *R );
                              }
                	    }
                	  else 
                	    {
                              {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                                Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	        OPT::Apply( *A_, *X, *R );
                              }
                	      MVT::MvAddMv( -1.0, *R, 1.0, *B, *R );
                	    }
                	}
                      else { 
                	// The solution and right-hand side may not be specified, check and use which ones exist.
                	Teuchos::RCP<const MV> localB, localX;
                	if (B)
                	  localB = Teuchos::rcp( B, false );
                	else
                	  localB = curB_;
                	
                	if (X)
                	  localX = Teuchos::rcp( X, false );
                	else
                	  localX = curX_;
                	
                	if (LP_!=Teuchos::null)
                	  {
                	    Teuchos::RCP<MV> R_temp = MVT::Clone( *localB, MVT::GetNumberVecs( *localB ) );
                            {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                              Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	      OPT::Apply( *A_, *localX, *R_temp );
                            }
                	    MVT::MvAddMv( -1.0, *R_temp, 1.0, *localB, *R_temp );
                            {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                              Teuchos::TimeMonitor PrecTimer(*timerPrec_);
                #endif
                	      OPT::Apply( *LP_, *R_temp, *R );
                            }
                	  }
                	else 
                	  {
                            {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                              Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                  	      OPT::Apply( *A_, *localX, *R );
                            }
                	    MVT::MvAddMv( -1.0, *R, 1.0, *localB, *R );
                	  }
                      }    
                    } 
                  }
                  
                  
                  template <class ScalarType, class MV, class OP>
           1 ->   void LinearProblem<ScalarType,MV,OP>::computeCurrResVec( MV* R, const MV* X, const MV* B ) const {
                
                    if (R) {
                      if (X && B) // The entries are specified, so compute the residual of Op(A)X = B
                	{
                          {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                            Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	    OPT::Apply( *A_, *X, *R );
                          }
                	  MVT::MvAddMv( -1.0, *R, 1.0, *B, *R );
                	}
                      else { 
                	// The solution and right-hand side may not be specified, check and use which ones exist.
                	Teuchos::RCP<const MV> localB, localX;
                	if (B)
                	  localB = Teuchos::rcp( B, false );
                	else
                	  localB = curB_;
                	
                	if (X)
                	  localX = Teuchos::rcp( X, false );
                	else
                	  localX = curX_;
                	  
                        {
                #ifdef BELOS_TEUCHOS_TIME_MONITOR
                          Teuchos::TimeMonitor OpTimer(*timerOp_);
                #endif
                	  OPT::Apply( *A_, *localX, *R );
                        }
                	MVT::MvAddMv( -1.0, *R, 1.0, *localB, *R );
                      }    
                    }
                  }
                  
                } // end Belos namespace
                
                #endif /* BELOS_LINEAR_PROBLEM_HPP */
                
                


Top 10 Lines:

     Line      Count

     1095          6
      619          4
      651          1
      718          1
      941          1
     1188          1

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

       14   Total number of line executions
     1.27   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_RCP.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_RCP_HPP
                #define TEUCHOS_RCP_HPP
                
                
                /*! \file Teuchos_RCP.hpp
                    \brief Reference-counted pointer class and non-member templated function implementations.
                */
                
                /** \example example/RefCountPtr/cxx_main.cpp
                    This is an example of how to use the <tt>Teuchos::RCP</tt> class.
                */
                
                /** \example test/MemoryManagement/RCP_test.cpp
                    This is a more detailed testing program that uses all of the <tt>Teuchos::RCP</tt> class.
                */
                
                #include "Teuchos_RCPDecl.hpp"
                #include "Teuchos_Ptr.hpp"
                #include "Teuchos_Assert.hpp"
                #include "Teuchos_Exceptions.hpp"
                #include "Teuchos_dyn_cast.hpp"
                #include "Teuchos_map.hpp"
                #include "Teuchos_TypeNameTraits.hpp"
                
                
                namespace Teuchos {
                
                
                // very bad public functions
                
                
                template<class T>
                inline
                RCPNode* RCP_createNewRCPNodeRawPtrNonowned( T* p )
                {
                  return new RCPNodeTmpl<T,DeallocNull<T> >(p, DeallocNull<T>(), false);
                }
                
                
                template<class T>
                inline
                RCPNode* RCP_createNewRCPNodeRawPtrNonownedUndefined( T* p )
                {
                  return new RCPNodeTmpl<T,DeallocNull<T> >(p, DeallocNull<T>(), false, null);
                }
                
                
                template<class T>
                inline
                RCPNode* RCP_createNewRCPNodeRawPtr( T* p, bool has_ownership_in )
                {
                  return new RCPNodeTmpl<T,DeallocDelete<T> >(p, DeallocDelete<T>(), has_ownership_in);
                }
                
                
                template<class T, class Dealloc_T>
                inline
                RCPNode* RCP_createNewDeallocRCPNodeRawPtr(
                  T* p, Dealloc_T dealloc, bool has_ownership_in
                  )
                {
                  return new RCPNodeTmpl<T,Dealloc_T>(p, dealloc, has_ownership_in);
                }
                
                
                template<class T, class Dealloc_T>
                inline
                RCPNode* RCP_createNewDeallocRCPNodeRawPtrUndefined(
                  T* p, Dealloc_T dealloc, bool has_ownership_in
                  )
                {
                  return new RCPNodeTmpl<T,Dealloc_T>(p, dealloc, has_ownership_in, null);
                }
                
                
                template<class T>
                inline
                RCP<T>::RCP( T* p, const RCPNodeHandle& node)
                  : ptr_(p), node_(node)
                {}
                
                
                template<class T>
                inline
                T* RCP<T>::access_private_ptr() const
                {  return ptr_; }
                
                
                template<class T>
                inline
                RCPNodeHandle& RCP<T>::nonconst_access_private_node()
                {  return node_; }
                
                
                template<class T>
                inline
                const RCPNodeHandle& RCP<T>::access_private_node() const
                {  return node_; }
                
                
                
                
                // Constructors/destructors/initializers
                
                
                template<class T>
                inline
                RCP<T>::RCP( ENull )
                  : ptr_(NULL)
                {}
                
                
                template<class T>
                inline
                RCP<T>::RCP( T* p, ERCPWeakNoDealloc )
                  : ptr_(p)
                #ifndef TEUCHOS_DEBUG
                  , node_(RCP_createNewRCPNodeRawPtrNonowned(p))
                #endif // TEUCHOS_DEBUG
                {
                #ifdef TEUCHOS_DEBUG
                  if (p) {
                    RCPNode* existing_RCPNode = RCPNodeTracer::getExistingRCPNode(p);
                    if (existing_RCPNode) {
                      // Will not call add_new_RCPNode(...)
                      node_ = RCPNodeHandle(existing_RCPNode, RCP_WEAK, false);
                    }
                    else {
                      // Will call add_new_RCPNode(...)
                      node_ = RCPNodeHandle(
                        RCP_createNewRCPNodeRawPtrNonowned(p),
                        p, typeName(*p), concreteTypeName(*p),
                        false
                        );
                    }
                  }
                #endif // TEUCHOS_DEBUG
                }
                
                
                template<class T>
                inline
                RCP<T>::RCP( T* p, ERCPUndefinedWeakNoDealloc )
                  : ptr_(p),
                    node_(RCP_createNewRCPNodeRawPtrNonownedUndefined(p))
                {}
                
                
                template<class T>
                inline
       ##### -> RCP<T>::RCP( T* p, bool has_ownership_in )
                  : ptr_(p)
                #ifndef TEUCHOS_DEBUG
                  , node_(RCP_createNewRCPNodeRawPtr(p, has_ownership_in))
                #endif // TEUCHOS_DEBUG
                {
                #ifdef TEUCHOS_DEBUG
                  if (p) {
                    RCPNode* existing_RCPNode = 0;
                    if (!has_ownership_in) {
                      existing_RCPNode = RCPNodeTracer::getExistingRCPNode(p);
                    }
                    if (existing_RCPNode) {
                      // Will not call add_new_RCPNode(...)
                      node_ = RCPNodeHandle(existing_RCPNode, RCP_WEAK, false);
                    }
                    else {
                      // Will call add_new_RCPNode(...)
                      RCPNodeThrowDeleter nodeDeleter(RCP_createNewRCPNodeRawPtr(p, has_ownership_in));
                      node_ = RCPNodeHandle(
                        nodeDeleter.get(),
                        p, typeName(*p), concreteTypeName(*p),
                        has_ownership_in
                        );
                      nodeDeleter.release();
                    }
                  }
                #endif // TEUCHOS_DEBUG
                }
                
                
                template<class T>
                template<class Dealloc_T>
                inline
                RCP<T>::RCP( T* p, Dealloc_T dealloc, bool has_ownership_in )
                  : ptr_(p)
                #ifndef TEUCHOS_DEBUG
                  , node_(RCP_createNewDeallocRCPNodeRawPtr(p, dealloc, has_ownership_in))
                #endif // TEUCHOS_DEBUG
                {
                #ifdef TEUCHOS_DEBUG
                  if (p) {
                    // Here we are assuming that if the user passed in a custom deallocator
                    // then they will want to have ownership (otherwise it will throw if it is
                    // the same object).
                    RCPNodeThrowDeleter nodeDeleter(RCP_createNewDeallocRCPNodeRawPtr(p, dealloc, has_ownership_in));
                    node_ = RCPNodeHandle(
                      nodeDeleter.get(),
                      p, typeName(*p), concreteTypeName(*p),
                      has_ownership_in
                      );
                    nodeDeleter.release();
                  }
                #endif // TEUCHOS_DEBUG
                }
                
                
                template<class T>
                template<class Dealloc_T>
                inline
                RCP<T>::RCP( T* p, Dealloc_T dealloc, ERCPUndefinedWithDealloc, bool has_ownership_in )
                  : ptr_(p)
                #ifndef TEUCHOS_DEBUG
                  , node_(RCP_createNewDeallocRCPNodeRawPtrUndefined(p, dealloc, has_ownership_in))
                #endif // TEUCHOS_DEBUG
                {
                #ifdef TEUCHOS_DEBUG
                  if (p) {
                    // Here we are assuming that if the user passed in a custom deallocator
                    // then they will want to have ownership (otherwise it will throw if it is
                    // the same object).
                    // Use auto_ptr to ensure we don't leak if a throw occurs
                    RCPNodeThrowDeleter nodeDeleter(RCP_createNewDeallocRCPNodeRawPtrUndefined(
                      p, dealloc, has_ownership_in));
                    node_ = RCPNodeHandle(
                      nodeDeleter.get(),
                      p, typeName(*p), concreteTypeName(*p),
                      has_ownership_in
                      );
                    nodeDeleter.release();
                  }
                #endif // TEUCHOS_DEBUG
                }
                
                
                template<class T>
                inline
                RCP<T>::RCP(const RCP<T>& r_ptr)
                  : ptr_(r_ptr.ptr_), node_(r_ptr.node_)
                {}
                
                
                template<class T>
                template<class T2>
                inline
                RCP<T>::RCP(const RCP<T2>& r_ptr)
                  : ptr_(r_ptr.get()), // will not compile if T is not base class of T2
                    node_(r_ptr.access_private_node())
                {}
                
                
                template<class T>
                inline
       ##### -> RCP<T>::~RCP()
                {}
                
                
                template<class T>
                inline
          65 -> RCP<T>& RCP<T>::operator=(const RCP<T>& r_ptr)
                {
                #ifdef TEUCHOS_DEBUG
                  if (this == &r_ptr)
                    return *this;
                  reset(); // Force delete first in debug mode!
                #endif
                  RCP<T>(r_ptr).swap(*this);
                  return *this;
                }
                
                
                template<class T>
                inline
                RCP<T>& RCP<T>::operator=(ENull)
                {
                  reset();
                  return *this;
                }
                
                
                template<class T>
                inline
                void RCP<T>::swap(RCP<T> &r_ptr)
                {
                  std::swap(r_ptr.ptr_, ptr_);
                  node_.swap(r_ptr.node_);
                }
                
                
                // Object query and access functions
                
                
                template<class T>
                inline
                bool RCP<T>::is_null() const
                {
                  return ptr_ == 0;
                }
                
                
                template<class T>
                inline
                T* RCP<T>::operator->() const
                {
                  debug_assert_not_null();
                  debug_assert_valid_ptr();
                  return ptr_;
                }
                
                
                template<class T>
                inline
                T& RCP<T>::operator*() const
                {
                  debug_assert_not_null();
                  debug_assert_valid_ptr();
                  return *ptr_;
                }
                
                template<class T>
                inline
                T* RCP<T>::get() const
                {
                  debug_assert_valid_ptr();
                  return ptr_;
                }
                
                
                template<class T>
                inline
                T* RCP<T>::getRawPtr() const
                {
                  return this->get();
                }
                
                
                template<class T>
                inline
                Ptr<T> RCP<T>::ptr() const
                {
                #ifdef TEUCHOS_DEBUG
                  return Ptr<T>(this->create_weak());
                #else
                  return Ptr<T>(getRawPtr());
                #endif
                }
                
                
                template<class T>
                inline
                Ptr<T> RCP<T>::operator()() const
                {
                  return ptr();
                }
                
                
                template<class T>
                inline
                RCP<const T> RCP<T>::getConst() const
                {
                  return rcp_implicit_cast<const T>(*this);
                }
                
                
                // Reference counting
                
                
                template<class T>
                inline
                ERCPStrength RCP<T>::strength() const
                {
                  return node_.strength();
                }
                
                
                template<class T>
                inline
                bool RCP<T>::is_valid_ptr() const
                {
                  if (ptr_)
                    return node_.is_valid_ptr();
                  return true;
                }
                
                
                template<class T>
                inline
                int RCP<T>::strong_count() const
                {
                  return node_.strong_count();
                }
                
                
                template<class T>
                inline
                int RCP<T>::weak_count() const
                {
                  return node_.weak_count();
                }
                
                
                template<class T>
                inline
                int RCP<T>::total_count() const
                {
                  return node_.total_count();
                }
                
                
                template<class T>
                inline
                void RCP<T>::set_has_ownership()
                {
                  node_.has_ownership(true);
                }
                
                
                template<class T>
                inline
                bool RCP<T>::has_ownership() const
                {
                  return node_.has_ownership();
                }
                
                
                template<class T>
                inline
                Ptr<T> RCP<T>::release()
                {
                  debug_assert_valid_ptr();
                  node_.has_ownership(false);
                  return Ptr<T>(ptr_);
                }
                
                
                template<class T>
                inline
                RCP<T> RCP<T>::create_weak() const
                {
                  debug_assert_valid_ptr();
                  return RCP<T>(ptr_, node_.create_weak());
                }
                
                
                template<class T>
                inline
                RCP<T> RCP<T>::create_strong() const
                {
                  debug_assert_valid_ptr();
                  return RCP<T>(ptr_, node_.create_strong());
                }
                
                
                template<class T>
                template <class T2>
                inline
                bool RCP<T>::shares_resource(const RCP<T2>& r_ptr) const
                {
                  return node_.same_node(r_ptr.access_private_node());
                  // Note: above, r_ptr is *not* the same class type as *this so we can not
                  // access its node_ member directly!  This is an interesting detail to the
                  // C++ protected/private protection mechanism!
                }
                
                
                // Assertions
                
                
                template<class T>
                inline
                const RCP<T>& RCP<T>::assert_not_null() const
                {
                  if (!ptr_)
                    throw_null_ptr_error(typeName(*this));
                  return *this;
                }
                
                
                template<class T>
                inline
                const RCP<T>& RCP<T>::assert_valid_ptr() const
                {
                  if (ptr_)
                    node_.assert_valid_ptr(*this);
                  return *this;
                }
                
                
                // boost::shared_ptr compatiblity funtions
                
                
                template<class T>
                inline
                void RCP<T>::reset()
                {
                #ifdef TEUCHOS_DEBUG
                  node_ = RCPNodeHandle();
                #else
                  RCPNodeHandle().swap(node_);
                #endif
                  ptr_ = 0;
                }
                
                
                template<class T>
                template<class T2>
                inline
                void RCP<T>::reset(T2* p, bool has_ownership_in)
                {
                  *this = rcp(p, has_ownership_in);
                }
                
                
                template<class T>
                inline
                int RCP<T>::count() const
                {
                  return node_.count();
                }
                
                }  // end namespace Teuchos
                
                
                // /////////////////////////////////////////////////////////////////////////////////
                // Inline non-member functions for RCP
                
                
                template<class T>
                inline
                Teuchos::RCP<T>
                Teuchos::rcp( T* p, bool owns_mem )
                {
                  return RCP<T>(p, owns_mem);
                }
                
                
                template<class T, class Dealloc_T>
                inline
                Teuchos::RCP<T>
                Teuchos::rcpWithDealloc( T* p, Dealloc_T dealloc, bool owns_mem )
                {
                  return RCP<T>(p, dealloc, owns_mem);
                }
                
                
                template<class T, class Dealloc_T>
                inline
                Teuchos::RCP<T>
                Teuchos::rcpWithDeallocUndef( T* p, Dealloc_T dealloc, bool owns_mem )
                {
                  return RCP<T>(p, dealloc, RCP_UNDEFINED_WITH_DEALLOC, owns_mem);
                }
                
                
                template<class T>
                Teuchos::RCP<T>
                Teuchos::rcpFromRef( T& r )
                {
                  return RCP<T>(&r, RCP_WEAK_NO_DEALLOC);
                }
                
                
                template<class T>
                Teuchos::RCP<T>
                Teuchos::rcpFromUndefRef( T& r )
                {
                  return RCP<T>(&r, RCP_UNDEFINED_WEAK_NO_DEALLOC);
                }
                
                
                template<class T, class Embedded>
                Teuchos::RCP<T>
                Teuchos::rcpWithEmbeddedObjPreDestroy(
                  T* p, const Embedded &embedded, bool owns_mem
                  )
                {
                  return rcpWithDealloc(
                    p, embeddedObjDeallocDelete<T>(embedded,PRE_DESTROY), owns_mem
                    );
                }
                
                
                template<class T, class Embedded>
                Teuchos::RCP<T>
                Teuchos::rcpWithEmbeddedObjPostDestroy(
                  T* p, const Embedded &embedded, bool owns_mem
                  )
                {
                  return rcpWithDealloc( p, embeddedObjDeallocDelete<T>(embedded,POST_DESTROY), owns_mem );
                }
                
                
                template<class T, class Embedded>
                Teuchos::RCP<T>
                Teuchos::rcpWithEmbeddedObj( T* p, const Embedded &embedded, bool owns_mem )
                {
                  return rcpWithEmbeddedObjPostDestroy<T,Embedded>(p,embedded,owns_mem);
                }
                
                
                template<class T, class ParentT>
                Teuchos::RCP<T>
                Teuchos::rcpWithInvertedObjOwnership(const RCP<T> &child,
                  const RCP<ParentT> &parent)
                {
                  using std::make_pair;
                  return rcpWithEmbeddedObj(child.getRawPtr(), make_pair(child, parent), false);
                }
                
                
                template<class T>
                Teuchos::RCP<T>
                Teuchos::rcpCloneNode(const RCP<T> &p)
                {
                  if (is_null(p)) {
                    return p;
                  }
                  return rcpWithEmbeddedObj(&*p, p, false);
                }
                
                
                template<class T>
                inline
                bool Teuchos::is_null( const RCP<T> &p )
                {
                  return p.is_null();
                }
                
                
                template<class T>
                inline
                bool Teuchos::nonnull( const RCP<T> &p )
                {
                  return !p.is_null();
                }
                
                
                template<class T>
                inline
                bool Teuchos::operator==( const RCP<T> &p, ENull )
                {
                  return p.get() == NULL;
                }
                
                
                template<class T>
                inline
                bool Teuchos::operator!=( const RCP<T> &p, ENull )
                {
                  return p.get() != NULL;
                }
                
                
                template<class T1, class T2>
                inline
                bool Teuchos::operator==( const RCP<T1> &p1, const RCP<T2> &p2 )
                {
                  return p1.access_private_node().same_node(p2.access_private_node());
                }
                
                
                template<class T1, class T2>
                inline
                bool Teuchos::operator!=( const RCP<T1> &p1, const RCP<T2> &p2 )
                {
                  return !p1.access_private_node().same_node(p2.access_private_node());
                }
                
                
                template<class T2, class T1>
                inline
                Teuchos::RCP<T2>
                Teuchos::rcp_implicit_cast(const RCP<T1>& p1)
                {
                  // Make the compiler check if the conversion is legal
                  T2 *check = p1.get();
                  return RCP<T2>(check, p1.access_private_node());
                }
                
                
                template<class T2, class T1>
                inline
                Teuchos::RCP<T2>
                Teuchos::rcp_static_cast(const RCP<T1>& p1)
                {
                  // Make the compiler check if the conversion is legal
                  T2 *check = static_cast<T2*>(p1.get());
                  return RCP<T2>(check, p1.access_private_node());
                }
                
                
                template<class T2, class T1>
                inline
                Teuchos::RCP<T2>
                Teuchos::rcp_const_cast(const RCP<T1>& p1)
                {
                  // Make the compiler check if the conversion is legal
                  T2 *check = const_cast<T2*>(p1.get());
                  return RCP<T2>(check, p1.access_private_node());
                }
                
                
                template<class T2, class T1>
                inline
                Teuchos::RCP<T2>
                Teuchos::rcp_dynamic_cast(const RCP<T1>& p1, bool throw_on_fail)
                {
                  if (!is_null(p1)) {
                    T2 *p = NULL;
                    if (throw_on_fail) {
                      p = &dyn_cast<T2>(*p1);
                    }
                    else {
                      // Make the compiler check if the conversion is legal
                      p = dynamic_cast<T2*>(p1.get());
                    }
                    if (p) {
                      return RCP<T2>(p, p1.access_private_node());
                    }
                  }
                  return null;
                }
                
                
                template<class T1, class T2>
                inline
                void Teuchos::set_extra_data( const T1 &extra_data, const std::string& name,
                  const Ptr<RCP<T2> > &p, EPrePostDestruction destroy_when, bool force_unique )
                {
                  p->assert_not_null();
                  p->nonconst_access_private_node().set_extra_data(
                    any(extra_data), name, destroy_when,
                    force_unique );
                }
                
                
                template<class T1, class T2>
                inline
                const T1& Teuchos::get_extra_data( const RCP<T2>& p, const std::string& name )
                {
                  p.assert_not_null();
                  return any_cast<T1>(
                    p.access_private_node().get_extra_data(
                      TypeNameTraits<T1>::name(), name
                      )
                    );
                }
                
                
                template<class T1, class T2>
                inline
                T1& Teuchos::get_nonconst_extra_data( RCP<T2>& p, const std::string& name )
                {
                  p.assert_not_null();
                  return any_cast<T1>(
                    p.nonconst_access_private_node().get_extra_data(
                      TypeNameTraits<T1>::name(), name
                      )
                    );
                }
                
                
                template<class T1, class T2>
                inline
                Teuchos::Ptr<const T1>
                Teuchos::get_optional_extra_data( const RCP<T2>& p, const std::string& name )
                {
                  p.assert_not_null();
                  const any *extra_data = p.access_private_node().get_optional_extra_data(
                    TypeNameTraits<T1>::name(), name);
                  if (extra_data)
                    return Ptr<const T1>(&any_cast<T1>(*extra_data));
                  return null;
                }
                
                
                template<class T1, class T2>
                inline
                Teuchos::Ptr<T1>
                Teuchos::get_optional_nonconst_extra_data( RCP<T2>& p, const std::string& name )
                {
                  p.assert_not_null();
                  any *extra_data = p.nonconst_access_private_node().get_optional_extra_data(
                    TypeNameTraits<T1>::name(), name);
                  if (extra_data)
                    return Ptr<T1>(&any_cast<T1>(*extra_data));
                  return null;
                }
                
                
                template<class Dealloc_T, class T>
                inline
                const Dealloc_T& Teuchos::get_dealloc( const RCP<T>& p )
                {
                  return get_nonconst_dealloc<Dealloc_T>(const_cast<RCP<T>&>(p));
                }
                
                
                template<class Dealloc_T, class T>
                inline
                Dealloc_T& Teuchos::get_nonconst_dealloc( const RCP<T>& p )
                {
                  typedef RCPNodeTmpl<typename Dealloc_T::ptr_t,Dealloc_T>  requested_type;
                  p.assert_not_null();
                  RCPNodeTmpl<typename Dealloc_T::ptr_t,Dealloc_T>
                    *dnode = dynamic_cast<RCPNodeTmpl<typename Dealloc_T::ptr_t,Dealloc_T>*>(
                      p.access_private_node().node_ptr());
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    dnode==NULL, NullReferenceError
                    ,"get_dealloc<" << TypeNameTraits<Dealloc_T>::name()
                    << "," << TypeNameTraits<T>::name() << ">(p): "
                    << "Error, requested type \'" << TypeNameTraits<requested_type>::name()
                    << "\' does not match actual type of the node \'"
                    << typeName(*p.access_private_node().node_ptr()) << "!"
                    );
                  return dnode->get_nonconst_dealloc();
                }
                
                
                template<class Dealloc_T, class T>
                inline
                Teuchos::Ptr<Dealloc_T>
                Teuchos::get_optional_nonconst_dealloc( const RCP<T>& p )
                {
                  p.assert_not_null();
                  typedef RCPNodeTmpl<typename Dealloc_T::ptr_t,Dealloc_T> RCPNT;
                  RCPNT *dnode = dynamic_cast<RCPNT*>(p.access_private_node().node_ptr());
                  if(dnode)
                    return ptr(&dnode->get_nonconst_dealloc());
                  return null;
                }
                
                
                template<class Dealloc_T, class T>
                inline
                Teuchos::Ptr<const Dealloc_T>
                Teuchos::get_optional_dealloc( const RCP<T>& p )
                {
                  return get_optional_nonconst_dealloc<Dealloc_T>(const_cast<RCP<T>&>(p));
                }
                
                
                template<class TOrig, class Embedded, class T>
                const Embedded& Teuchos::getEmbeddedObj( const RCP<T>& p )
                {
                  typedef EmbeddedObjDealloc<TOrig,Embedded,DeallocDelete<TOrig> > Dealloc_t;
                  return get_dealloc<Dealloc_t>(p).getObj();
                }
                
                
                template<class TOrig, class Embedded, class T>
                Embedded& Teuchos::getNonconstEmbeddedObj( const RCP<T>& p )
                {
                  typedef EmbeddedObjDealloc<TOrig,Embedded,DeallocDelete<TOrig> > Dealloc_t;
                  return get_nonconst_dealloc<Dealloc_t>(p).getNonconstObj();
                }
                
                
                template<class TOrig, class Embedded, class T>
                Teuchos::Ptr<const Embedded>
                Teuchos::getOptionalEmbeddedObj( const RCP<T>& p )
                {
                  typedef EmbeddedObjDealloc<TOrig,Embedded,DeallocDelete<TOrig> > Dealloc_t;
                  const Ptr<const Dealloc_t> dealloc = get_optional_dealloc<Dealloc_t>(p);
                  if (!is_null(dealloc)) {
                    return ptr(&dealloc->getObj());
                  }
                  return null;
                }
                
                
                template<class TOrig, class Embedded, class T>
                Teuchos::Ptr<Embedded>
                Teuchos::getOptionalNonconstEmbeddedObj( const RCP<T>& p )
                {
                  typedef EmbeddedObjDealloc<TOrig,Embedded,DeallocDelete<TOrig> > Dealloc_t;
                  const Ptr<Dealloc_t> dealloc = get_optional_nonconst_dealloc<Dealloc_t>(p);
                  if (!is_null(dealloc)) {
                    return ptr(&dealloc->getNonconstObj());
                  }
                  return null;
                }
                
                
                template<class ParentT, class T>
                Teuchos::RCP<ParentT>
                Teuchos::getInvertedObjOwnershipParent(const RCP<T> &invertedChild)
                {
                  typedef std::pair<RCP<T>, RCP<ParentT> > Pair_t;
                  Pair_t pair = getEmbeddedObj<T, Pair_t>(invertedChild);
                  return pair.second;
                }
                
                
                template<class T>
       ##### -> std::ostream& Teuchos::operator<<( std::ostream& out, const RCP<T>& p )
                {
                  out
                    << typeName(p) << "{"
                    << "ptr="<<(const void*)(p.get()) // I can't find any alternative to this C cast :-(
                    <<",node="<<p.access_private_node()
                    <<",strong_count="<<p.strong_count()
                    <<",weak_count="<<p.weak_count()
                    <<"}";
                  return out;
                }
                
                
                #endif // TEUCHOS_RCP_HPP


Top 10 Lines:

     Line      Count

      301         65

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       65   Total number of line executions
    16.25   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_any.hpp:
                /*
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                */
                
                #ifndef TEUCHOS_ANY_HPP
                #define TEUCHOS_ANY_HPP
                
                /*! \file Teuchos_any.hpp
                   \brief Modified boost::any class for holding a templated value
                */
                
                #include "Teuchos_Assert.hpp"
                #include "Teuchos_TypeNameTraits.hpp"
                
                //
                // This file was taken from the boost library which contained the
                // following notice:
                //
                // *************************************************************
                //
                // what:  variant type boost::any
                // who:   contributed by Kevlin Henney,
                //        with features contributed and bugs found by
                //        Ed Brey, Mark Rodgers, Peter Dimov, and James Curran
                // when:  July 2001
                // where: tested with BCC 5.5, MSVC 6.0, and g++ 2.95
                //
                // Copyright Kevlin Henney, 2000, 2001, 2002. All rights reserved.
                //
                // Permission to use, copy, modify, and distribute this software for any
                // purpose is hereby granted without fee, provided that this copyright and
                // permissions notice appear in all copies and derivatives.
                //
                // This software is provided "as is" without express or implied warranty.
                //
                // *************************************************************
                //
                // RAB modified the file for use in Teuchos.  I changed the nature of
                // the any_cast<> to be easier to use.
                //
                
                namespace Teuchos {
                
                /** \brief Modified boost::any class, which is a container for a templated
                 * value.
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT any
                {
                public:
                  //! Empty constructor
                  any()
                    : content(0)
                    {}
                
                  //! Templated constructor
                  template<typename ValueType>
                  explicit any(const ValueType & value)
                    : content(new holder<ValueType>(value))
                    {}
                
                  //! Copy constructor
                  any(const any & other)
                    : content(other.content ? other.content->clone() : 0)
                    {}
                
                  //! Destructor
                  ~any()
                    {
                      delete content;
                    }
                
                  //! Method for swapping the contents of two any classes
                  any & swap(any & rhs)
                    {
                      std::swap(content, rhs.content);
                      return *this;
                    }
                
                  //! Copy the value <tt>rhs</tt>
                  template<typename ValueType>
                  any & operator=(const ValueType & rhs)
                    {
                      any(rhs).swap(*this);
                      return *this;
                    }
                
                  //! Copy the value held in <tt>rhs</tt>
                  any & operator=(const any & rhs)
                    {
                      any(rhs).swap(*this);
                      return *this;
                    }
                
                  //! Return true if nothing is being stored
                  bool empty() const
                    {
                      return !content;
                    }
                
                  //! Return the type of value being stored
                  const std::type_info & type() const
                    {
                      return content ? content->type() : typeid(void);
                    }
                
                  //! Return the name of the type
       ##### ->   std::string typeName() const
                    {
                      return content ? content->typeName() : "NONE";
                    }
                
                  //! \brief Return if two any objects are the same or not.
                  bool same( const any &other ) const
                    {
                      if( this->empty() && other.empty() )
                        return true;
                      else if( this->empty() && !other.empty() )
                        return false;
                      else if( !this->empty() && other.empty() )
                        return false;
                      // !this->empty() && !other.empty()
                      return content->same(*other.content);
                    }
                
                  //! Print this value to the output stream <tt>os</tt>
                  void print(std::ostream& os) const
                    {
                      if (content) content->print(os);
                    }
                
                #ifndef DOXYGEN_SHOULD_SKIP_THIS
                  /** @name Private??? types */
                  //@{
                
                  /** \brief . */
                  class placeholder
                  {
                  public:
                    /** \brief . */
                    virtual ~placeholder() {}
                    /** \brief . */
                    virtual const std::type_info & type() const = 0;
                    /** \brief . */
                    virtual std::string typeName() const = 0;
                    /** \brief . */
                    virtual placeholder * clone() const = 0;
                    /** \brief . */
                    virtual bool same( const placeholder &other ) const = 0;
                    /** \brief . */
                    virtual void print(std::ostream & os) const = 0;
                  };
                
                  /** \brief . */
                  template<typename ValueType>
        1425 ->   class holder : public placeholder
                  {
                  public:
                    /** \brief . */
                    holder(const ValueType & value)
                      : held(value)
                      {}
                    /** \brief . */
        1077 ->     const std::type_info & type() const
                      { return typeid(ValueType); }
                    /** \brief . */
           8 ->     std::string typeName() const
                      { return TypeNameTraits<ValueType>::name(); }
                    /** \brief . */
        1225 ->     placeholder * clone() const
                      { return new holder(held); }
                    /** \brief . */
       ##### ->     bool same( const placeholder &other ) const
                      {
                        if( type() != other.type() ) {
                          return false;
                        }
                        // type() == other.type()
                        const ValueType
                          &other_held = dynamic_cast<const holder<ValueType>&>(other).held;
                        return held == other_held;
                      }
                    /** \brief . */
          11 ->     void print(std::ostream & os) const
                      { os << held; }
                    /** \brief . */
                    ValueType held;
                  };
                
                  //@}
                
                public:
                  // Danger: This is made public to allow any_cast to be non-friend
                  placeholder* access_content()
                    { return content; }
                  const placeholder* access_content() const
                    { return content; }
                #endif
                
                private:
                
                  // /////////////////////////
                  // Private data members
                
                  placeholder * content;
                
                };
                
                /*! \relates any
                    \brief Thrown if any_cast is attempted between two incompatable types.
                */
       ##### -> class bad_any_cast : public std::runtime_error
                {
                public:
                  bad_any_cast( const std::string msg ) : std::runtime_error(msg) {}
                };
                
                /*! \relates any
                    \brief Used to extract the templated value held in Teuchos::any to a given value type.
                
                    \note <ul>   <li> If the templated value type and templated type are not the same then a
                    bad_any_cast is thrown.
                    <li> If the dynamic cast fails, then a Teuchos::bad_any_cast std::exception is thrown.
                    </ul>
                */
                template<typename ValueType>
         114 -> ValueType& any_cast(any &operand)
                {
                  const std::string ValueTypeName = TypeNameTraits<ValueType>::name();
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    operand.type() != typeid(ValueType), bad_any_cast,
                    "any_cast<"<<ValueTypeName<<">(operand): Error, cast to type "
                    << "any::holder<"<<ValueTypeName<<"> failed since the actual underlying type is \'"
                    << typeName(*operand.access_content()) << "!"
                    );
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    !operand.access_content(), bad_any_cast
                    ,"any_cast<"<<ValueTypeName<<">(operand): Error, cast to type "
                    << "any::holder<"<<ValueTypeName<<"> failed because the content is NULL"
                    );
                  any::holder<ValueType>
                    *dyn_cast_content = dynamic_cast<any::holder<ValueType>*>(operand.access_content());
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    !dyn_cast_content, std::logic_error
                    ,"any_cast<"<<ValueTypeName <<">(operand): Error, cast to type "
                    << "any::holder<"<<ValueTypeName<<"> failed but should not have and the actual underlying type is \'"
                    << typeName(*operand.access_content()) << "!"
                    << "  The problem might be related to incompatible RTTI systems in static and shared libraries!"
                    );
                  return dyn_cast_content->held;
                }
                
                /*! \relates any
                    \brief Used to extract the const templated value held in Teuchos::any to a given
                  const value type.
                
                    \note <ul>   <li> If the templated value type and templated type are not the same then a
                    bad_any_cast is thrown.
                    <li> If the dynamic cast fails, then a logic_error is thrown.
                    </ul>
                */
                template<typename ValueType>
                const ValueType& any_cast(const any &operand)
                {
                  return any_cast<ValueType>(const_cast<any&>(operand));
                }
                
                /*! \relates any
                    \brief Converts the value in <tt>any</tt> to a std::string.
                */
                inline std::string toString(const any &rhs)
                {
                  std::ostringstream oss;
                  rhs.print(oss);
                  return oss.str();
                }
                
                /*! \relates any
                    \brief Returns true if two any objects have the same value.
                */
                inline bool operator==( const any &a, const any &b )
                {
                  return a.same(b);
                }
                
                /*! \relates any
                    \brief Returns true if two any objects <b>do not</b> have the same value.
                */
                inline bool operator!=( const any &a, const any &b )
                {
                  return !a.same(b);
                }
                
                /*! \relates any
                    \brief Writes "any" input <tt>rhs</tt> to the output stream <tt>os</tt>.
                */
                inline std::ostream & operator<<(std::ostream & os, const any &rhs)
                {
                  rhs.print(os);
                  return os;
                }
                
                } // namespace Teuchos
                
                #endif // TEUCHOS_ANY_HPP


Top 10 Lines:

     Line      Count

      194       1425
      208       1225
      202       1077
      265        114
      222         11
      205          8

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

     3860   Total number of line executions
   428.89   Average executions per line


*** File /home/vkotteda/penta_tpetra/CWrapper_tpetra.cpp:
                
                #include <Teuchos_GlobalMPISession.hpp>
                #include <Teuchos_oblackholestream.hpp>
                #include <Tpetra_DefaultPlatform.hpp>
                #include <Tpetra_Version.hpp>
                
                #include <Teuchos_TimeMonitor.hpp>
                #include <Tpetra_CrsMatrix.hpp>
                #include <iostream>
                
                #include <Tpetra_CrsMatrix.hpp>
                #include <Tpetra_Map.hpp>
                #include <Tpetra_MultiVector.hpp>
                
                #include <MueLu.hpp>
                
                #include <MueLu_Exceptions.hpp>
                #include <MueLu_Hierarchy.hpp>
                #include <MueLu_MasterList.hpp>
                #include <MueLu_MLParameterListInterpreter.hpp>
                #include <MueLu_ParameterListInterpreter.hpp>
                #include <MueLu_Utilities.hpp>
                
                #include "MueLu_FactoryManagerBase.hpp"
                #include "MueLu_Hierarchy.hpp"
                #include "MueLu_PFactory.hpp"
                #include "MueLu_SaPFactory.hpp"
                #include "MueLu_TransPFactory.hpp"
                #include "MueLu_RAPFactory.hpp"
                #include "MueLu_AmesosSmoother.hpp"
                #include "MueLu_TrilinosSmoother.hpp"
                #include "MueLu_SmootherFactory.hpp"
                #include "MueLu_CoupledAggregationFactory.hpp"
                #include "MueLu_TentativePFactory.hpp"
                #include "MueLu_AmesosSmoother.hpp"
                
                #include <MueLu_Level.hpp>
                #include <MueLu_MLParameterListInterpreter.hpp>
                #include <MueLu_ParameterListInterpreter.hpp>
                //#ifdef HAVE_MUELU_TPETRA
                #include <Tpetra_Operator.hpp>
                #include <MueLu_TpetraOperator.hpp>
                #include <Xpetra_TpetraVector.hpp>
                #include <MueLu_CreateTpetraPreconditioner.hpp>
                #include <MueLu_UseDefaultTypes.hpp>
                
                #include <BelosSolverFactory.hpp>
                #include <BelosTpetraAdapter.hpp>
                
                #include <ctime>
                
                //double* CPPWrapper(double** Ao, double* bo, double* x_vec, double** aloc, int* glob, int rows, int cols, int nn, int itmax, double tole)
                //{
                
                int main(int argc, char* argv[])
       ##### -> {
                
                  typedef Tpetra::MultiVector<>::scalar_type scalar_type;
                  typedef scalar_type ST;
                  typedef Tpetra::MultiVector<>::local_ordinal_type LO;
                  typedef Tpetra::MultiVector<>::global_ordinal_type GO;
                  //typedef Tpetra::MultiVector<>::node_type node_type;
                  
                  typedef KokkosClassic::DefaultNode::DefaultNodeType node_type;
                  
                  typedef Teuchos::ScalarTraits<scalar_type> STS;
                //  typedef STS::magnitudeType magnitude_type;
                //  typedef Teuchos::ScalarTraits<magnitude_type> STM;
                  
                  typedef Tpetra::Map<LO, GO, node_type> map_type;
                  typedef Tpetra::MultiVector<scalar_type, LO, GO, node_type> multivector_type;
                  typedef Tpetra::CrsMatrix<scalar_type, LO, GO, node_type> sparse_mat_type;
                  
                  typedef Tpetra::Vector<>::scalar_type scalar_type;
                  typedef Tpetra::Vector<>::global_ordinal_type global_ordinal_type;
                  typedef Tpetra::Vector<>::local_ordinal_type local_ordinal_type;
                  typedef MueLu::TpetraOperator<scalar_type,local_ordinal_type,global_ordinal_type,node_type> mtoperator;
                  
                  typedef Tpetra::Operator<scalar_type,local_ordinal_type,global_ordinal_type,node_type>    operator_type;
                  typedef Belos::LinearProblem<scalar_type, multivector_type, operator_type> linear_problem_type;
                  typedef Belos::SolverManager<scalar_type, multivector_type, operator_type> belos_solver_manager_type;
                  typedef Belos::BlockCGSolMgr<scalar_type, multivector_type, operator_type>    belos_blockcg_manager_type;
                  typedef Belos::PseudoBlockCGSolMgr<scalar_type, multivector_type, operator_type> belos_pseudocg_manager_type;
                  typedef Belos::BlockGmresSolMgr<scalar_type, multivector_type, operator_type> belos_gmres_manager_type;
                  typedef Belos::BiCGStabSolMgr<scalar_type, multivector_type, operator_type> belos_bicgstab_manager_type;
                  typedef Belos::TFQMRSolMgr<scalar_type, multivector_type, operator_type>      belos_tfqmr_manager_type;
                  
                  typedef Belos::LSQRSolMgr<scalar_type, multivector_type, operator_type>       belos_lsqr_manager_type;
                  typedef MueLu::TpetraOperator<scalar_type, local_ordinal_type, global_ordinal_type, node_type> muelu_tpetra_operator_type;
                  
                  using Tpetra::global_size_t;
                  using Teuchos::Array;
                  using Teuchos::ArrayView;
                  using Teuchos::ArrayRCP;
                  using Teuchos::arcp;
                  using Teuchos::RCP;
                  using Teuchos::rcp;
                  using Teuchos::tuple;
                  using std::cerr;
                  using std::cout;
                  using std::endl;
                  using Teuchos::parameterList;
                  using Teuchos::Time;
                  using Teuchos::TimeMonitor;
                
                  using Teuchos::updateParametersFromXmlFile;
                  using Teuchos::updateParametersFromXmlString; 
                  typedef Tpetra::CrsMatrix<> crs_matrix_type;
                
                
                  Teuchos::oblackholestream blackhole;
                  Teuchos::GlobalMPISession mpiSession (&argc, &argv, NULL);
                  RCP<const Teuchos::Comm<int> > comm = Teuchos::DefaultComm<int>::getComm();
                
                //  Teuchos::oblackholestream blackHole;
                //  Teuchos::GlobalMPISession mpiSession (NULL,NULL, &blackHole);
                
                  std::clock_t c_start = std::clock();
                  
                //  Teuchos::GlobalMPISession mpiSession();
                //  RCP<const Teuchos::Comm<int> > comm = Tpetra::DefaultPlatform::getDefaultPlatform ().getComm ();
                
                  const int myRank = comm->getRank ();
                  const int numProcs = comm->getSize ();
                
                  RCP<Time> insertva     = TimeMonitor::getNewCounter ("InsertValues ");
                  RCP<Time> FillTimer    = TimeMonitor::getNewCounter ("FillComplete A");
                //  RCP<Time> makevec      = TimeMonitor::getNewCounter ("Make Vecs ");
                //  RCP<Time> makeprb      = TimeMonitor::getNewCounter ("Problem setup ");
                //  RCP<Time> SolsTimer    = TimeMonitor::getNewCounter ("SolverSetupTime ");
                
                  std::ostream &out = std::cout;
                  RCP<Teuchos::FancyOStream> fos = Teuchos::fancyOStream(Teuchos::rcpFromRef(out));
                
                  const global_size_t numGlobalElements = 1000000;  // 50;
                
                  const int nrows = numGlobalElements/numProcs; 
                  size_t numMyElements = nrows ; //map->getNodeNumElements ();
                
                  if(myRank == numProcs-1) {
                  numMyElements = numGlobalElements -myRank * nrows; 
                  std::cout << " myRank"  << numMyElements << std::endl; 
                  }
                  
                //  int numMyElements =  rows; //map->getNodeNumElements ();
                  ArrayRCP<size_t> glon = arcp<size_t> (numMyElements);
                
                  const global_ordinal_type indexBase = 0;
                
                  double Values[7];
                  int   Indices[7];
                  int NumEntries;
                  int RowLess3, RowLess2, RowLess1;
                  int RowPlus1, RowPlus2, RowPlus3;
                
                  int i;
                  LO lcR;
                  int gblRow;
                
                  std::clock_t c_start1 = std::clock(); 
                
                  RCP<const map_type> map = rcp (new map_type (numGlobalElements, numMyElements, indexBase, comm));
                  std::clock_t c_start2 = std::clock();  
                
                //  std::cout << " rank" << myRank << " " << numMyElements << std::endl; 
                //  return 0; 
                
                
                /*
                  RCP<const map_type> map;
                 {
                    Array<GO>::size_type numEltsPerProc = rows;
                    Array<GO> myGlobalElements (numEltsPerProc); 
                      for(int i = 0; i < numMyElements; ++i) {
                      myGlobalElements[i] = glob[i] -1;  //myRank + k*numProcs;
                    }
                  map = rcp (new map_type (numGlobalElements, myGlobalElements, 0, comm));
                }
                */
                // map->describe(*fos,Teuchos::VERB_EXTREME);
                
                  for(i = 0; i < numMyElements; ++i) {
                      glon[i] = i + myRank*numMyElements;
                  }
                
                
                  double Ao[numMyElements][7];
                  for (int i=0; i < numMyElements; ++i ) {
                            Ao[i][0] =  -0.05;
                            Ao[i][1] =  -0.1;
                            Ao[i][2] =  -0.2;
                            Ao[i][3] =   4.0;
                            Ao[i][4] =  -0.2;
                            Ao[i][5] =  -0.1;
                            Ao[i][6] =  -0.05;
                  }
                
                  double aloc[numMyElements][6];
                  for (int i=0; i < numMyElements; ++i ) {
                            aloc[i][0] =  -100;
                            aloc[i][1] =  -20;
                            aloc[i][2] =  -1;
                            aloc[i][3] =   1;
                            aloc[i][4] =   20;
                            aloc[i][5] =   100;
                  }
                
                
                  RCP<crs_matrix_type> A (new crs_matrix_type (map, 7));
                //  std::clock_t c_start1 = std::clock();
                
                
                  {
                  TimeMonitor monitor (*insertva);
                  for(lcR = 0; lcR < static_cast<LO> (numMyElements);  ++lcR) {
                    gblRow = glon[lcR]; //map->getGlobalElement (lcR);
                    NumEntries = 0; 
                    RowLess3 = gblRow + aloc[lcR][0];
                    RowLess2 = gblRow + aloc[lcR][1];
                    RowLess1 = gblRow + aloc[lcR][2];
                    RowPlus1 = gblRow + aloc[lcR][3];
                    RowPlus2 = gblRow + aloc[lcR][4];
                    RowPlus3 = gblRow + aloc[lcR][5];
                
                
                //    if ((RowLess3 >=0 ) && abs(Ao[lcR][0])!=0){
                     if ((RowLess3 >=0 )&&  abs(aloc[lcR][0]) != 0.0 ) {
                      Values[NumEntries]  = Ao[lcR][0];
                      Indices[NumEntries] = RowLess3;
                      NumEntries          = NumEntries + 1 ;
                    }
                
                //      if (RowLess2 >=0 &&  RowLess2 !=GlobalRow) //aloc[i][1] != 0.0)
                //    if ((RowLess2 >=0 ) && abs(Ao[lcR][1])!=0) { 
                      if ((RowLess2 >=0 ) && abs(aloc[lcR][1]) != 0) {
                      Values[NumEntries]  = Ao[lcR][1];
                      Indices[NumEntries] = RowLess2;
                      NumEntries          = NumEntries + 1 ;
                    }
                
                //    if ((RowLess1 >=0 ) && abs(Ao[lcR][2])!=0)  {
                      if ((RowLess1 >=0 ) && abs(aloc[lcR][2]) != 0) {
                      Values[NumEntries]  = Ao[lcR][2];
                      Indices[NumEntries] = RowLess1;
                      NumEntries          = NumEntries + 1 ;
                    }
                
                //       if (RowPlus1 < NumGlobalElements &&  RowPlus1 !=GlobalRow) //aloc[i][3] != 0.0)
                //    if ((RowPlus1 < numGlobalElements && abs(Ao[lcR][4])!=0))   {
                       if ((RowPlus1 < numGlobalElements) &&  abs(aloc[lcR][3]) != 0) {
                      Values[NumEntries]  = Ao[lcR][4];
                      Indices[NumEntries] = RowPlus1;
                      NumEntries          = NumEntries + 1 ;
                    }
                
                      if ((RowPlus2 < numGlobalElements) &&  abs(aloc[lcR][4]) != 0) {
                //   if ((RowPlus2 < numGlobalElements) && abs(Ao[lcR][5])!=0)       {
                      Values[NumEntries]  = Ao[lcR][5];
                      Indices[NumEntries] = RowPlus2;
                      NumEntries          = NumEntries + 1 ;
                   }
                    if ((RowPlus3 < numGlobalElements) && abs(aloc[lcR][5]) != 0) {
                //   if ((RowPlus3 < numGlobalElements) && abs(Ao[lcR][6])!=0)   {
                      Values[NumEntries]  = Ao[lcR][6];
                      Indices[NumEntries] = RowPlus3;
                      NumEntries          = NumEntries + 1 ;
                      }
                
                      Values[NumEntries]  = Ao[lcR][3];
                      Indices[NumEntries] = gblRow;
                      NumEntries          = NumEntries + 1 ;
                      A->insertGlobalValues (gblRow, NumEntries, Values, Indices);
                //    std::cout << gblRow << " "  << NumEntries << " "<< Indices << std::endl; 
                    }
                  }
                
                
                  {
                    TimeMonitor monitor (*FillTimer);
                //  A->fillComplete ();
                    A->fillComplete (map,map);
                  }
                
                
                // A->describe(*fos,Teuchos::VERB_EXTREME);
                  std::clock_t c_start3 = std::clock();
                
                
                //   TimeMonitor monitor(*makevec);
                   RCP<multivector_type> x = rcp(new multivector_type(map,1));
                   RCP<multivector_type> b = rcp(new multivector_type(map,1));
                
                //  RCP<multivector_type> x(map);
                //  RCP<multivector_type> b(map);
                
                //  b.putScalar (STS::one ());
                    b->randomize();
                
                /*
                   for (LO lclRow = 0; lclRow < static_cast<LO> (numMyElements);++lclRow) {
                    const GO gblRow = map->getGlobalElement (lclRow);
                    b->sumIntoGlobalValue(gblRow, 0, bo[lclRow]);
                //   x->sumIntoGlobalValue(gblRow, 0, x_vec[lclRow]);
                   }
                */
                
                   std::clock_t c_start4 = std::clock();
                
                /*
                  Teuchos::ParameterList paramList;
                  paramList.set("verbosity", "low");
                  paramList.set("max levels", 2);
                  paramList.set("coarse: max size", 10);
                  paramList.set("multigrid algorithm", "sa");
                */
                  
                  std::string xmlFileName = "test.xml";
                  
                   std::clock_t c_start5 = std::clock();
                //   TimeMonitor monitor(*makeprb); 
                   RCP<linear_problem_type> Problem = rcp(new linear_problem_type(A, x, b));
                   Problem->setProblem();
                
                  std::clock_t c_start6 = std::clock();
                
                 //  TimeMonitor monitor(*SolsTimer) ;   
                  RCP<ParameterList> belosList = rcp(new ParameterList());
                  belosList->set("Maximum Iterations",    20);    // Maximum number of iterations allowed
                  belosList->set( "Num Blocks", 200);                // Maximum number of blocks in Krylov factorization
                  belosList->set("Convergence Tolerance", 1.0e-4);     // Relative convergence tolerance requested
                  belosList->set("Block Size",          1);
                  //  belosList->set("Verbosity",             Belos::Errors + Belos::Warnings + Belos::StatusTestDetails + Belos::TimingDetails);
                  belosList->set("Verbosity",             Belos::Errors + Belos::Warnings);
                  belosList->set("Output Frequency",      20);
                  //  belosList->set("Output Style",          Belos::None);
                  belosList->set("Output Style",          Belos::Brief);
                  //  belosList->set("Implicit Residual Scaling", "None");
                  RCP<belos_solver_manager_type> solver;
                  
                  std::string inputFile="input_param.xml";
                  std::string vname; 
                  bool prec;
                  RCP<Teuchos::ParameterList> myParams = rcp(new Teuchos::ParameterList());
                  Teuchos::updateParametersFromXmlFile(inputFile, myParams.ptr());
                  vname = myParams->get<std::string>("Solver");
                  prec  = myParams->get<bool>("Precond");
                  
                //  std::clock_t c_start4 = std::clock();
                  if(vname=="GMRES") {
                    if(prec) {
                    RCP< mtoperator > mueLuPreconditioner = MueLu::CreateTpetraPreconditioner<scalar_type,local_ordinal_type,global_ordinal_type,node_type>(RCP<operator_type>(A), xmlFileName);
                    Problem->setLeftPrec (mueLuPreconditioner);
                    }
                    solver = rcp(new belos_gmres_manager_type(Problem, belosList));
                    }
                    else if(vname=="CG")  {
                    if(prec) {
                    RCP< mtoperator > mueLuPreconditioner = MueLu::CreateTpetraPreconditioner<scalar_type,local_ordinal_type,global_ordinal_type,node_type>(RCP<operator_type>(A), xmlFileName);
                    Problem->setRightPrec (mueLuPreconditioner);
                    }
                    solver = rcp(new belos_blockcg_manager_type(Problem, belosList));
                    }
                    else if(vname=="TFQMR")     {
                     solver = rcp(new belos_tfqmr_manager_type(Problem, belosList));
                    }
                //    else if(vname=="BICG") { 
                //    solver = rcp(new belos_bicgiter_manager_type(Problem, belosList)); 
                //    }
                    else if(vname=="LSQR")     {
                     solver = rcp(new  belos_lsqr_manager_type(Problem, belosList));
                    }
                
                    else
                    {
                    if(prec) {
                    RCP< mtoperator > mueLuPreconditioner = MueLu::CreateTpetraPreconditioner<scalar_type,local_ordinal_type,global_ordinal_type,node_type>(RCP<operator_type>(A), xmlFileName);
                //    Problem->setLeftPrec (mueLuPreconditioner);
                    Problem->setRightPrec (mueLuPreconditioner);
                    }
                    solver = rcp(new belos_bicgstab_manager_type(Problem, belosList));
                  }
                 
                
                  solver->solve();
                
                  std::clock_t c_start7 = std::clock();
                
                  if(myRank == 0 ) {
                
                  std::cout << "Initializing arrays "  << 1000*(c_start1-c_start)/CLOCKS_PER_SEC   << std::endl; 
                  std::cout << "Creating Map  "        << 1000*(c_start2-c_start1)/CLOCKS_PER_SEC   << std::endl; 
                  std::cout << "Make vecs  "           << 1000*(c_start4-c_start3)/CLOCKS_PER_SEC   << std::endl; 
                  std::cout << "IntiMapFormMatVec "    << 1000*(c_start5-c_start1)/CLOCKS_PER_SEC   << std::endl;
                  std::cout << "Problem Setup  "       << 1000*(c_start6-c_start5)/CLOCKS_PER_SEC   << std::endl; 
                  std::cout << "Solver  "              << 1000*(c_start7-c_start6)/CLOCKS_PER_SEC   << std::endl; 
                  
                /*  std::cout << "before fill "   << 1000*(c_start1-c_start)/CLOCKS_PER_SEC   << std::endl; 
                  std::cout << " Fill "         << 1000*(c_start2-c_start1)/CLOCKS_PER_SEC << std::endl; 
                  std::cout << " Fill b "       << 1000*(c_start3-c_start2)/CLOCKS_PER_SEC << std::endl; 
                  std::cout << " before Solve " << 1000*(c_start4-c_start3)/CLOCKS_PER_SEC << std::endl; 
                  std::cout << "Solve "         << 1000*(c_start5-c_start4)/CLOCKS_PER_SEC << std::endl; 
                  std::cout << "total"          << 1000*(c_start5-c_start)/CLOCKS_PER_SEC << std::endl;
                */
                  int numIterations = solver->getNumIters();
                  std::cout << " number of iterations" <<  numIterations << std::endl;
                  }
                
                
                /*  ArrayRCP<ST> view;
                  int size = x->getLocalLength ();
                  Array<ST> copy1(numMyElements);
                  view = x->get1dViewNonConst();
                  x->get1dCopy(copy1(),numMyElements);
                  
                  for(int i=0; i < numMyElements; i++) {
                    x_vec[i] = copy1[i]; 
                //      std::cout << myRank  << "  " << glob[i] << " " << i <<"  " <<copy1[i] << std::endl;
                  }
                */
                
                
                  TimeMonitor::summarize();
                
                }  // end of cpp wrapper 
                
                // *fos << "LHS :" << std::endl;
                //  x->describe(*fos,Teuchos::VERB_EXTREME);
                
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_XMLParameterListHelpers.hpp"
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_config.h"
                
                #include <Teuchos_GlobalMPISession.hpp>
                #include <Teuchos_oblackholestream.hpp>
                
                extern "C" {
                
       ##### ->   void xmlstrc_(char *varname, int *varlen, char *Str1, int *len)  {
                  using Teuchos::RCP;
                  using Teuchos::rcp;
                  using Teuchos::parameterList;
                  Teuchos::oblackholestream blackHole;
                  Teuchos::GlobalMPISession mpiSession();
                
                  std::string vname;
                  vname.assign(varname, *varlen);
                
                  std::string name1;
                  name1.assign(Str1, *len);
                
                  std::string inputFile;
                  inputFile="input_param.xml";
                  RCP<Teuchos::ParameterList> myParams = rcp(new Teuchos::ParameterList());
                  Teuchos::updateParametersFromXmlFile(inputFile, myParams.ptr());
                  vname = myParams->get<std::string>(name1);
                //  std::cout << vname << name1 << std::endl;
                  strncpy(varname, vname.c_str(), *varlen);
                  varname[*varlen-1] = 0 ;
                //  std::cout << vname.c_str() << std::endl;
                 }
                }
                
                
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_XMLParameterListHelpers.hpp"
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_config.h"
                
                #include <Teuchos_GlobalMPISession.hpp>
                #include <Teuchos_oblackholestream.hpp>
                
                extern "C" {
       ##### ->   void xmlintc_(int *intvar1, char *Str1, int *len)  {
                  using Teuchos::RCP;
                  using Teuchos::rcp;
                  using Teuchos::parameterList;
                
                  Teuchos::oblackholestream blackHole;
                  Teuchos::GlobalMPISession mpiSession();
                
                  std::string name1;
                  name1.assign(Str1, *len);
                  std::string inputFile;
                  inputFile="input_param.xml";
                  RCP<Teuchos::ParameterList> myParams = rcp(new Teuchos::ParameterList());
                  Teuchos::updateParametersFromXmlFile(inputFile, myParams.ptr());
                   *intvar1 = myParams->get<int>(name1);
                  }
                }
                
                
                #include "Teuchos_ParameterList.hpp"
                #include "Teuchos_XMLParameterListHelpers.hpp"
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_config.h"
                
                #include <Teuchos_GlobalMPISession.hpp>
                #include <Teuchos_oblackholestream.hpp>
                
                extern "C" {
          18 ->   void xmlfltc_(double *intvar1, char *Str1, int *len)  {
                  using Teuchos::RCP;
                  using Teuchos::rcp;
                  using Teuchos::parameterList;
                
                  Teuchos::oblackholestream blackHole;
                  Teuchos::GlobalMPISession mpiSession();
                
                  std::string name1;
                  name1.assign(Str1, *len);
                  std::string inputFile;
                  inputFile="input_param.xml";
                  RCP<Teuchos::ParameterList> myParams = rcp(new Teuchos::ParameterList());
                  Teuchos::updateParametersFromXmlFile(inputFile, myParams.ptr());
                   *intvar1 = myParams->get<double>(name1);
                //   std::cout << *intvar1 << name1 << std::endl;
                  }
                }
                


Top 10 Lines:

     Line      Count

      502         18

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       18   Total number of line executions
     4.50   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
           2 ->     vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp = _M_allocate_and_copy(__n,
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	  && __position == end())
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                #if __cplusplus >= 201103L
                	  const auto __pos = begin() + (__position - cbegin());
                	  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	    {
                	      _Tp __x_copy = __x;
                	      _M_insert_aux(__pos, std::move(__x_copy));
                	    }
                	  else
                	    _M_insert_aux(__pos, __x);
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	}
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
           8 ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
           3 ->     vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					__n - size(), __val,
                					_M_get_Tp_allocator());
                	  this->_M_impl._M_finish += __n - size();
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, ++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  insert(end(), __first, __last);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      typename vector<_Tp, _Alloc>::iterator
                      vector<_Tp, _Alloc>::
                      emplace(const_iterator __position, _Args&&... __args)
                      {
                	const size_type __n = __position - begin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	    && __position == end())
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_insert_aux(begin() + (__position - cbegin()),
                			std::forward<_Args>(__args)...);
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			           _GLIBCXX_MOVE(*(this->_M_impl._M_finish
                				                   - 1)));
                	  ++this->_M_impl._M_finish;
                #if __cplusplus < 201103L
                	  _Tp __x_copy = __x;
                #endif
                	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                				  this->_M_impl._M_finish - 2,
                				  this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                	  *__position = __x_copy;
                #else
                	  *__position = _Tp(std::forward<_Args>(__args)...);
                #endif
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector::_M_insert_aux");
                	  const size_type __elems_before = __position - begin();
                	  pointer __new_start(this->_M_allocate(__len));
                	  pointer __new_finish(__new_start);
                	  __try
                	    {
                	      // The order of the three operations is dictated by the C++0x
                	      // case, where the moves could alter a new element belonging
                	      // to the existing vector.  This is an issue only for callers
                	      // taking the element by const lvalue ref (see 23.1/13).
                	      _Alloc_traits::construct(this->_M_impl,
                		                       __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				       std::forward<_Args>(__args)...);
                #else
                	                               __x);
                #endif
                	      __new_finish = 0;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(this->_M_impl._M_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), this->_M_impl._M_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                          __catch(...)
                	    {
                	      if (!__new_finish)
                		_Alloc_traits::destroy(this->_M_impl,
                		                       __new_start + __elems_before);
                	      else
                		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	      _M_deallocate(__new_start, __len);
                	      __throw_exception_again;
                	    }
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __new_start;
                	  this->_M_impl._M_finish = __new_finish;
                	  this->_M_impl._M_end_of_storage = __new_start + __len;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
          37 ->       vector<_Tp, _Alloc>::
                      _M_emplace_back_aux(_Args&&... __args)
                      {
                	const size_type __len =
                	  _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
                	pointer __new_start(this->_M_allocate(__len));
                	pointer __new_finish(__new_start);
                	__try
                	  {
                	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
                				     std::forward<_Args>(__args)...);
                	    __new_finish = 0;
                
                	    __new_finish
                	      = std::__uninitialized_move_if_noexcept_a
                	      (this->_M_impl._M_start, this->_M_impl._M_finish,
                	       __new_start, _M_get_Tp_allocator());
                
                	    ++__new_finish;
                	  }
                	__catch(...)
                	  {
                	    if (!__new_finish)
                	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
                	    else
                	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	    _M_deallocate(__new_start, __len);
                	    __throw_exception_again;
                	  }
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_M_deallocate(this->_M_impl._M_start,
                		      this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start);
                	this->_M_impl._M_start = __new_start;
                	this->_M_impl._M_finish = __new_finish;
                	this->_M_impl._M_end_of_storage = __new_start + __len;
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    void
           1 ->     vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      value_type __x_copy = __x;
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						__n - __elems_after,
                						__x_copy,
                						_M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n - __elems_after;
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_insert_aux above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = 0;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
           4 ->     vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                					       __n, _M_get_Tp_allocator());
                	      this->_M_impl._M_finish += __n;
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      const size_type __old_size = this->size();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, this->_M_impl._M_finish,
                		     __new_start, _M_get_Tp_allocator());
                		  std::__uninitialized_default_n_a(__new_finish, __n,
                						   _M_get_Tp_allocator());
                		  __new_finish += __n;
                		}
                	      __catch(...)
                		{
                		  std::_Destroy(__new_start, __new_finish,
                				_M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	for (; __first != __last; ++__first)
                	  {
                	    __pos = insert(__pos, *__first);
                	    ++__pos;
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
       ##### ->       vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_type* __q = this->_M_allocate(__n);
                      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
                						iterator(__q, 0));
                      this->_M_deallocate();
                      this->_M_impl._M_start = iterator(__q, 0);
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_type * __q = this->_M_allocate(__len);
                	  iterator __i = _M_copy_aligned(begin(), __position,
                					 iterator(__q, 0));
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  this->_M_impl._M_finish = std::copy(__position, end(),
                					      __i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = iterator(__q, 0);
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_type * __q = this->_M_allocate(__len);
                		iterator __i = _M_copy_aligned(begin(), __position,
                					       iterator(__q, 0));
                		__i = std::copy(__first, __last, __i);
                		this->_M_impl._M_finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = iterator(__q, 0);
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_type * __q = this->_M_allocate(__len);
                	  iterator __i = _M_copy_aligned(begin(), __position,
                					 iterator(__q, 0));
                	  *__i++ = __x;
                	  this->_M_impl._M_finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = iterator(__q, 0);
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      407         37
      167          8
      540          4
      225          3
       65          2
      449          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

       55   Total number of line executions
     7.86   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/MueLu_VariableContainer.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //        MueLu: A package for multigrid based preconditioning
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef MUELU_VARIABLECONTAINER_HPP
                #define MUELU_VARIABLECONTAINER_HPP
                
                #include <map>
                
                #include <Teuchos_TypeNameTraits.hpp>
                
                #include <Xpetra_Matrix.hpp>
                #include <Xpetra_Operator.hpp>
                
                #include "MueLu_ConfigDefs.hpp"
                #include "MueLu_BaseClass.hpp"
                
                #include "MueLu_Exceptions.hpp"
                #include "MueLu_FactoryBase_fwd.hpp"
                #include "MueLu_KeepType.hpp"
                
                namespace MueLu {
                
                  /*!
                    @class VariableContainer
                    @brief Class that stores all relevant data for a variable
                
                    Maintains all data for a variable, that is, the data itself, a boolean flag for the "Keep" status,
                    a boolean flag for the "Available" status, a reference counter for all requests and a list with
                    all requesting factories.
                  */
                  class VariableContainer : public BaseClass {
                  private:
                    // Motivated by Teuchos_any.hpp
                    class DataBase {
                    public:
                      virtual ~DataBase() {}
                      virtual const std::type_info& type() const = 0;
                      virtual std::string typeName() const = 0;
                    };
                
                    template<typename T>
           3 ->     class Data : public DataBase {
                    public:
                      Data(const T& data) : data_(data) {}
          49 ->       const std::type_info& type() const { return typeid(T); }
       ##### ->       std::string typeName() const { return Teuchos::TypeNameTraits<T>::name(); }
                      T data_;
                    };
                
                    template<typename T>
                    struct Getter {
           1 ->       static T& get(DataBase* data_, DataBase*& datah_) {
                        const std::string typeName = Teuchos::TypeNameTraits<T>::name();
                        TEUCHOS_TEST_FOR_EXCEPTION(data_ == NULL, Teuchos::bad_any_cast,
                                                   "Error, cast to type Data<" << typeName << "> failed since the content is NULL");
                        TEUCHOS_TEST_FOR_EXCEPTION(data_->type() != typeid(T), Teuchos::bad_any_cast,
                                                   "Error, cast to type Data<" << typeName << "> failed since the actual underlying type is "
                                                   "\'" << data_->typeName() << "!");
                
                        Data<T>* data = dynamic_cast<Data<T>*>(data_);
                        TEUCHOS_TEST_FOR_EXCEPTION(!data, std::logic_error,
                                                   "Error, cast to type Data<" << typeName << "> failed but should not have and the actual underlying type is "
                                                   "\'" << data_->typeName() << "! The problem might be related to incompatible RTTI systems in static and shared libraries!");
                        return data->data_;
                      }
                    };
                
                
                  public:
                    typedef std::map<const FactoryBase*,int> request_container;
                
                  private:
                    DataBase*          data_;        ///< the data itself
                    mutable
                    DataBase*          datah_;       ///< temporary data storage (need to get a reference
                                                     ///< to RCP to a base class (like Operator)
                    bool               available_;   ///< is data available?
                    KeepType           keep_;        ///< keep flag
                    int                count_;       ///< number of requests by all factories
                
                    request_container  requests_;    ///< requesting factories
                
                  public:
                    //! @name Constructors/Destructors.
                    //@{
                
                    //! Default constructor.
                    VariableContainer() : data_(NULL), datah_(NULL), available_(false), keep_(false), count_(0) { }
                    ~VariableContainer() {
                      delete data_;   data_  = NULL;
                      delete datah_;  datah_ = NULL;
                    }
                
                    //@}
                
                    //! @name Data access
                    //@{
                
                    //! Store data in container class and set the "Available" status true.
                    template<typename T>
                    void SetData(const T& entry) {
                      delete data_;
                      delete datah_;
                      data_      = new Data<T>(entry);
                      datah_     = NULL;
                      available_ = true;
                    }
                
                    //! Return const reference to data stored in container
                    //! NOTE: we do not check if data is available
                    template<typename T>
                    const T& GetData() const {
                      return Getter<T>::get(data_, datah_);
                    }
                
                    //! Return reference to data stored in container
                    //! NOTE: we do not check if data is available
                    template<typename T>
                    T& GetData() {
                      return Getter<T>::get(data_, datah_);
                    }
                
                    std::string GetTypeName() {
                      if (data_ == NULL)
                        return std::string("");
                      return data_->typeName();
                    }
                
                    //! Returns true if data is available, i.e.
                    //  if SetData has been called before
                    bool IsAvailable() const { return available_; }
                
                    //@}
                
                    //! @name Request/Release
                    //@{
                
                    //! Request data
                    void Request(const FactoryBase* reqFactory) {
                      request_container::iterator it = requests_.find(reqFactory);
                      if (it == requests_.end())
                        requests_[reqFactory] = 1;
                      else
                        (it->second)++;
                      count_++;   // increment request counter
                    }
                
                    //! Release data
                    void Release(const FactoryBase* reqFactory) {
                      request_container::iterator it = requests_.find(reqFactory);
                      TEUCHOS_TEST_FOR_EXCEPTION(it == requests_.end(), Exceptions::RuntimeError, "MueLu::VariableContainer::Release(): "
                                                 "cannot call Release if factory has not been requested before by factory " << reqFactory);
                      if (--(it->second) == 0)
                        requests_.erase(it);
                      count_--;
                    }
                
                    //! Return the number of times the data has been requested by a specific factory
                    int NumRequests(const FactoryBase* reqFactory) const {
                      request_container::const_iterator it = requests_.find(reqFactory);
                      return (it != requests_.end()) ? it->second : 0;
                    }
                
                    //! Returns the number of times the data has been requested
                    int NumAllRequests() const                                                  { return count_; }
                
                    //! Returns true, if data is requested by reqFactory
                    bool IsRequested(const FactoryBase* reqFactory) const                       { return (NumRequests(reqFactory) > 0); }
                
                    //! Returns true, if data is requested by at least one factory
                    bool IsRequested() const                                                    { return (count_ > 0); }
                
                    const request_container& Requests() const                                   { return requests_; }
                    //@}
                
                    //! @name Keep status
                    //@{
                
                    //! Returns true if at least one keep flag is set
                    bool IsKept(KeepType keep) const                                            { return keep_ & keep; }
                
                    //! Adds a keep flag to the flag combination
                    void AddKeepFlag(KeepType keep = UserData)                                  { keep_ |= keep; }
                
                    //! Removes a keep flag to the flag combination
                    void RemoveKeepFlag(KeepType keep = UserData)                               { keep_ = keep_ & (keep_ ^ keep); }
                
                    //! Returns the keep flag combination
                    KeepType GetKeepFlag() const                                                { return keep_; }
                
                    //@}
                  };
                
                
                  template<class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  struct VariableContainer::Getter<Teuchos::RCP<Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node> > > {
                    typedef Xpetra::Operator<Scalar,LocalOrdinal,GlobalOrdinal,Node> Operator;
                    typedef Xpetra::Matrix  <Scalar,LocalOrdinal,GlobalOrdinal,Node> Matrix;
                
          24 ->     static Teuchos::RCP<Operator>& get(DataBase* data_, DataBase*& datah_) {
                      typedef Teuchos::RCP<Operator> TO;
                      typedef Teuchos::RCP<Matrix>   TM;
                
                      const std::string typeTOName = Teuchos::TypeNameTraits<TO>::name();
                      const std::string typeTMName = Teuchos::TypeNameTraits<TM>::name();
                      TEUCHOS_TEST_FOR_EXCEPTION(data_ == NULL, Teuchos::bad_any_cast,
                                                 "Error, cast to type Data<" << typeTOName << "> failed since the content is NULL");
                      if (data_->type() == typeid(TO)) {
                        Data<TO>* data = dynamic_cast<Data<TO>*>(data_);
                        TEUCHOS_TEST_FOR_EXCEPTION(!data, std::logic_error,
                                                   "Error, cast to type Data<" << typeTOName << "> failed but should not have and the actual underlying type is "
                                                   "\'" << data_->typeName() << "! The problem might be related to incompatible RTTI systems in static and shared libraries!");
                        return data->data_;
                      }
                
                      TEUCHOS_TEST_FOR_EXCEPTION(data_->type() != typeid(TM), Teuchos::bad_any_cast,
                                                 "Error, cast to type Data<" << typeTMName << "> failed since the actual underlying type is "
                                                 "\'" << data_->typeName() << "!");
                      Data<TM>* data = dynamic_cast<Data<TM>*>(data_);
                      TEUCHOS_TEST_FOR_EXCEPTION(!data, std::logic_error,
                                                 "Error, cast to type Data<" << typeTMName << "> failed but should not have and the actual underlying type is "
                                                 "\'" << data_->typeName() << "! The problem might be related to incompatible RTTI systems in static and shared libraries!");
                      if (datah_ == NULL)
                        datah_ = new Data<TO>(Teuchos::rcp_dynamic_cast<Operator>(data->data_));
                      Data<TO>* datah = dynamic_cast<Data<TO>*>(datah_);
                      TEUCHOS_TEST_FOR_EXCEPTION(!datah, std::logic_error,
                                                 "Error, cast to type Data<" << typeTOName << "> failed but should not have and the actual underlying type is "
                                                 "\'" << datah_->typeName() << "! The problem might be related to incompatible RTTI systems in static and shared libraries!");
                      return datah->data_;
                    }
                  };
                
                }
                
                #endif /* MUELU_VARIABLECONTAINER_HPP */


Top 10 Lines:

     Line      Count

       87         49
      242         24
       84          3
       94          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

       77   Total number of line executions
    15.40   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosStatusTestMaxIters.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                //
                   
                #ifndef BELOS_STATUS_TEST_MAXITERS_HPP
                #define BELOS_STATUS_TEST_MAXITERS_HPP
                
                /*!
                  \file BelosStatusTestMaxIters.hpp
                  \brief Belos::StatusTest class for specifying a maximum number of iterations.
                */
                
                #include "BelosStatusTest.hpp"
                
                /*! \class Belos::StatusTestMaxIters: 
                    \brief A Belos::StatusTest class for specifying a maximum number of iterations.
                
                    This implementation of the Belos::StatusTest base class tests the number of iterations performed
                    against a maximum number allowed.
                */
                
                namespace Belos {
                
                template <class ScalarType, class MV, class OP>
                class StatusTestMaxIters: public StatusTest<ScalarType,MV,OP> {
                
                 public:
                
                   //! @name Constructor/Destructor.
                  //@{ 
                
                  //! Constructor
                  StatusTestMaxIters(int maxIters);
                
                  //! Destructor
       ##### ->   virtual ~StatusTestMaxIters() {};
                  //@}
                
                  //! @name Status methods
                  //@{ 
                
                  //! Check convergence status of the iterative solver: Unconverged, Converged, Failed.
                  /*! This method checks to see if the convergence criteria are met using the current information from the 
                    iterative solver.
                  */
                  StatusType checkStatus(Iteration<ScalarType,MV,OP> *iSolver );
                
                  //! Return the result of the most recent CheckStatus call.
       ##### ->   StatusType getStatus() const {return(status_);}
                
                  //@}
                
                  //! @name Reset methods
                  //@{ 
                
                  //! Resets the status test to the initial internal state.
                  void reset();
                
                  //! Sets the maximum number of iterations allowed.
                  void setMaxIters(int maxIters) { maxIters_ = maxIters; }
                
                  //@}
                
                  //! @name Accessor methods
                  //@{ 
                
                  //! Returns the maximum number of iterations set in the constructor.
                  int getMaxIters() const { return(maxIters_); }
                
                  //! Returns the current number of iterations from the most recent StatusTest call.
                  int getNumIters() const { return(nIters_); }
                
                  //@}
                
                  //! @name Print methods
                  //@{ 
                
                  //! Output formatted description of stopping test to output stream.
                  void print(std::ostream& os, int indent = 0) const;
                
                  //! Print message for each status specific to this stopping test.
                  void printStatus(std::ostream& os, StatusType type) const;
                
                  //@}
                 
                  /** \name Overridden from Teuchos::Describable */
                  //@{
                
                  /** \brief Method to return description of the maximum iteration status test  */
       ##### ->   std::string description() const 
                  {  
                    std::ostringstream oss; 
                    oss << "Belos::StatusTestMaxIters<>: [ " << getNumIters() << " / " << getMaxIters() << " ]"; 
                    return oss.str();
                  }
                  //@} 
                
                private:
                
                  //! @name Private data members.
                  //@{ 
                  //! Maximum number of iterations allowed
                  int maxIters_;
                
                  //! Current number of iterations
                  int nIters_;
                
                  //! Status
                  StatusType status_;
                  //@}
                
                };
                
                  template <class ScalarType, class MV, class OP> 
                  StatusTestMaxIters<ScalarType,MV,OP>::StatusTestMaxIters(int maxIters)
                  {
                    if (maxIters < 1)
                      maxIters_ = 1;
                    else
                      maxIters_ = maxIters;
                    
                    nIters_ = 0;
                    status_ = Undefined;
                  }
                  
                  template <class ScalarType, class MV, class OP>
           4 ->   StatusType StatusTestMaxIters<ScalarType,MV,OP>::checkStatus(Iteration<ScalarType,MV,OP> *iSolver )
                  {
                    status_ = Failed;
                    nIters_ = iSolver->getNumIters();
                    if (nIters_ >= maxIters_)
                      status_ = Passed;
                    return status_;
                  }
                  
                  template <class ScalarType, class MV, class OP>
           1 ->   void StatusTestMaxIters<ScalarType,MV,OP>::reset()
                  {
                    nIters_ = 0;
                    status_ = Undefined;
                  }    
                    
                  template <class ScalarType, class MV, class OP>
           1 ->   void StatusTestMaxIters<ScalarType,MV,OP>::print(std::ostream& os, int indent) const
                  {
                    for (int j = 0; j < indent; j ++)
                      os << ' ';
                    printStatus(os, status_);
                    os << "Number of Iterations = ";
                    os << nIters_;
                    os << ((nIters_ < maxIters_) ? " < " : ((nIters_ == maxIters_) ? " == " : " > "));
                    os << maxIters_;
                    os << std::endl;
                  }
                 
                  template <class ScalarType, class MV, class OP>
           1 ->   void StatusTestMaxIters<ScalarType,MV,OP>::printStatus(std::ostream& os, StatusType type) const 
                  {
                    os << std::left << std::setw(13) << std::setfill('.');
                    switch (type) {
                    case  Passed:
                      os << "Failed";
                      break;
                    case  Failed:
                      os << "OK";
                      break;
                    case  Undefined:
                    default:
                      os << "**";
                      break;
                    }
                    os << std::left << std::setfill(' ');
                    return;
                  } 
                
                } // end Belos namespace
                
                #endif /* BELOS_STATUS_TEST_MAXITERS_HPP */


Top 10 Lines:

     Line      Count

      165          4
      175          1
      182          1
      195          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

        7   Total number of line executions
     1.00   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_TpetraMultiVector.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef XPETRA_TPETRAMULTIVECTOR_HPP
                #define XPETRA_TPETRAMULTIVECTOR_HPP
                
                /* this file is automatically generated - do not edit (see script/tpetra.py) */
                
                #include "Xpetra_TpetraConfigDefs.hpp"
                
                #include "Xpetra_MultiVector.hpp"
                
                #include "Xpetra_TpetraMap.hpp" //TMP
                #include "Xpetra_Utils.hpp"
                #include "Xpetra_TpetraImport.hpp"
                #include "Xpetra_TpetraExport.hpp"
                
                #include "Tpetra_MultiVector.hpp"
                #include "Tpetra_Vector.hpp"
                
                namespace Xpetra {
                
                  // TODO: move that elsewhere
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> & toTpetra(const MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> &);
                
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> & toTpetra(MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> &);
                
                #ifndef DOXYGEN_SHOULD_SKIP_THIS
                  // forward declaration of TpetraVector, needed to prevent circular inclusions
                  template<class S, class LO, class GO, class N> class TpetraVector;
                #endif
                
                
                  // Because we aren't including the header...
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node > >       toXpetra(RCP<Tpetra::Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > vec);
                
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node > > toXpetra(RCP<const Tpetra::Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > vec);
                
                
                  template <class Scalar = MultiVector<>::scalar_type,
                            class LocalOrdinal = typename MultiVector<Scalar>::local_ordinal_type,
                            class GlobalOrdinal = typename MultiVector<Scalar, LocalOrdinal>::global_ordinal_type,
                            class Node = typename MultiVector<Scalar, LocalOrdinal, GlobalOrdinal>::node_type>
                  class TpetraMultiVector
                    : public virtual MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >
                  {
                
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraMultiVectorClass;
                
                  public:
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Basic constuctor.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, size_t NumVectors, bool zeroOut=true)
                      : vec_(Teuchos::rcp(new Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >(toTpetra(map), NumVectors, zeroOut))) {
                      // TAW 1/30/2016: even though Tpetra allows numVecs == 0, Epetra does not. Introduce exception to keep behavior of Epetra and Tpetra consistent.
                      TEUCHOS_TEST_FOR_EXCEPTION(NumVectors < 1, std::invalid_argument, "Xpetra::TpetraMultiVector(map,numVecs,zeroOut): numVecs = " << NumVectors << " < 1.");
                    }
                
                    //! Copy constructor (performs a deep copy).
                    TpetraMultiVector(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source)
                      : vec_(Teuchos::rcp(new Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >(Tpetra::createCopy(toTpetra(source))))) {  }
                
                    //! Create multivector by copying two-dimensional array of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Scalar > &A, size_t LDA, size_t NumVectors)
                      : vec_(Teuchos::rcp(new Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >(toTpetra(map), A, LDA, NumVectors))) {
                      // TAW 1/30/2016: even though Tpetra allows numVecs == 0, Epetra does not. Introduce exception to keep behavior of Epetra and Tpetra consistent.
                      TEUCHOS_TEST_FOR_EXCEPTION(NumVectors < 1, std::invalid_argument, "Xpetra::TpetraMultiVector(map,A,LDA,numVecs): numVecs = " << NumVectors << " < 1.");
                    }
                
                    //! Create multivector by copying array of views of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors)
                      : vec_(Teuchos::rcp(new Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >(toTpetra(map), ArrayOfPtrs, NumVectors))) {
                      // TAW 1/30/2016: even though Tpetra allows numVecs == 0, Epetra does not. Introduce exception to keep behavior of Epetra and Tpetra consistent.
                      TEUCHOS_TEST_FOR_EXCEPTION(NumVectors < 1, std::invalid_argument, "Xpetra::TpetraMultiVector(map,ArrayOfPtrs,numVecs): numVecs = " << NumVectors << " < 1.");
                    }
                
                
                    //! Destructor (virtual for memory safety of derived classes).
           1 ->     virtual ~TpetraMultiVector() {  }
                
                    //@}
                
                    //! @name Post-construction modification routines
                    //@{
                
                    //! Replace value, using global (row) index.
       ##### ->     void replaceGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { XPETRA_MONITOR("TpetraMultiVector::replaceGlobalValue"); vec_->replaceGlobalValue(globalRow, vectorIndex, value); }
                
                    //! Add value to existing value, using global (row) index.
       ##### ->     void sumIntoGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { XPETRA_MONITOR("TpetraMultiVector::sumIntoGlobalValue"); vec_->sumIntoGlobalValue(globalRow, vectorIndex, value); }
                
                    //! Replace value, using local (row) index.
       ##### ->     void replaceLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { XPETRA_MONITOR("TpetraMultiVector::replaceLocalValue"); vec_->replaceLocalValue(myRow, vectorIndex, value); }
                
                    //! Add value to existing value, using local (row) index.
       ##### ->     void sumIntoLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { XPETRA_MONITOR("TpetraMultiVector::sumIntoLocalValue"); vec_->sumIntoLocalValue(myRow, vectorIndex, value); }
                
                    //! Set all values in the multivector with the given value.
           1 ->     void putScalar(const Scalar &value) { XPETRA_MONITOR("TpetraMultiVector::putScalar"); vec_->putScalar(value); }
                
                    //! Sum values of a locally replicated multivector across all processes.
                    void reduce() { XPETRA_MONITOR("TpetraMultiVector::reduce"); vec_->reduce(); }
                
                    //@}
                
                    //! @name Data Copy and View get methods
                    //@{
                
                    //! Return a Vector which is a const view of column j.
       ##### ->     Teuchos::RCP< const Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVector(size_t j) const { XPETRA_MONITOR("TpetraMultiVector::getVector"); return toXpetra(vec_->getVector(j)); }
                
                    //! Return a Vector which is a nonconst view of column j.
       ##### ->     Teuchos::RCP< Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVectorNonConst(size_t j) { XPETRA_MONITOR("TpetraMultiVector::getVectorNonConst"); return toXpetra(vec_->getVectorNonConst(j)); }
                
                    //! Const view of the local values in a particular vector of this multivector.
       ##### ->     Teuchos::ArrayRCP< const Scalar > getData(size_t j) const { XPETRA_MONITOR("TpetraMultiVector::getData"); return vec_->getData(j); }
                
                    //! View of the local values in a particular vector of this multivector.
       ##### ->     Teuchos::ArrayRCP< Scalar > getDataNonConst(size_t j) { XPETRA_MONITOR("TpetraMultiVector::getDataNonConst"); return vec_->getDataNonConst(j); }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get1dCopy(Teuchos::ArrayView< Scalar > A, size_t LDA) const { XPETRA_MONITOR("TpetraMultiVector::get1dCopy"); vec_->get1dCopy(A, LDA); }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get2dCopy(Teuchos::ArrayView< const Teuchos::ArrayView< Scalar > > ArrayOfPtrs) const { XPETRA_MONITOR("TpetraMultiVector::get2dCopy"); vec_->get2dCopy(ArrayOfPtrs); }
                
                    //! Const persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< const Scalar > get1dView() const { XPETRA_MONITOR("TpetraMultiVector::get1dView"); return vec_->get1dView(); }
                
                    //! Return const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< const Scalar > > get2dView() const { XPETRA_MONITOR("TpetraMultiVector::get2dView"); return vec_->get2dView(); }
                
                    //! Nonconst persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< Scalar > get1dViewNonConst() { XPETRA_MONITOR("TpetraMultiVector::get1dViewNonConst"); return vec_->get1dViewNonConst(); }
                
                    //! Return non-const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< Scalar > > get2dViewNonConst() { XPETRA_MONITOR("TpetraMultiVector::get2dViewNonConst"); return vec_->get2dViewNonConst(); }
                
                    //@}
                
                    //! @name Mathematical methods
                    //@{
                
                    //! Compute dot product of each corresponding pair of vectors, dots[i] = this[i].dot(A[i]).
       ##### ->     void dot(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Teuchos::ArrayView< Scalar > &dots) const { XPETRA_MONITOR("TpetraMultiVector::dot"); vec_->dot(toTpetra(A), dots); }
                
                    //! Put element-wise absolute values of input Multi-vector in target: A = abs(this).
       ##### ->     void abs(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { XPETRA_MONITOR("TpetraMultiVector::abs"); vec_->abs(toTpetra(A)); }
                
                    //! Put element-wise reciprocal values of input Multi-vector in target, this(i,j) = 1/A(i,j).
       ##### ->     void reciprocal(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { XPETRA_MONITOR("TpetraMultiVector::reciprocal"); vec_->reciprocal(toTpetra(A)); }
                
                    //! Scale the current values of a multi-vector, this = alpha*this.
       ##### ->     void scale(const Scalar &alpha) { XPETRA_MONITOR("TpetraMultiVector::scale"); vec_->scale(alpha); }
                
                    //! Scale the current values of a multi-vector, this[j] = alpha[j]*this[j].
       ##### ->     void scale(Teuchos::ArrayView< const Scalar > alpha) { XPETRA_MONITOR("TpetraMultiVector::scale"); vec_->scale(alpha); }
                
                    //! Replace multi-vector values with scaled values of A, this = alpha*A.
                    void scale(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { XPETRA_MONITOR("TpetraMultiVector::scale"); vec_->scale(alpha, toTpetra(A)); }
                
                    //! Update multi-vector values with scaled values of A, this = beta*this + alpha*A.
       ##### ->     void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta) { XPETRA_MONITOR("TpetraMultiVector::update"); vec_->update(alpha, toTpetra(A), beta); }
                
                    //! Update multi-vector with scaled values of A and B, this = gamma*this + alpha*A + beta*B.
       ##### ->     void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &gamma) { XPETRA_MONITOR("TpetraMultiVector::update"); vec_->update(alpha, toTpetra(A), beta, toTpetra(B), gamma); }
                
                    //! Compute 1-norm of each vector in multi-vector.
       ##### ->     void norm1(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { XPETRA_MONITOR("TpetraMultiVector::norm1"); vec_->norm1(norms); }
                
                    //!
       ##### ->     void norm2(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { XPETRA_MONITOR("TpetraMultiVector::norm2"); vec_->norm2(norms); }
                
                    //! Compute Inf-norm of each vector in multi-vector.
       ##### ->     void normInf(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { XPETRA_MONITOR("TpetraMultiVector::normInf"); vec_->normInf(norms); }
                
                    //! Compute mean (average) value of each vector in multi-vector. The outcome of this routine is undefined for non-floating point scalar types (e.g., int).
       ##### ->     void meanValue(const Teuchos::ArrayView< Scalar > &means) const { XPETRA_MONITOR("TpetraMultiVector::meanValue"); vec_->meanValue(means); }
                
                    //! Matrix-matrix multiplication: this = beta*this + alpha*op(A)*op(B).
       ##### ->     void multiply(Teuchos::ETransp transA, Teuchos::ETransp transB, const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &beta) { XPETRA_MONITOR("TpetraMultiVector::multiply"); vec_->multiply(transA, transB, alpha, toTpetra(A), toTpetra(B), beta); }
                
                    //@}
                
                    //! @name Attribute access functions
                    //@{
                
                    //! Number of columns in the multivector.
       ##### ->     size_t getNumVectors() const { XPETRA_MONITOR("TpetraMultiVector::getNumVectors"); return vec_->getNumVectors(); }
                
                    //! Local number of rows on the calling process.
       ##### ->     size_t getLocalLength() const { XPETRA_MONITOR("TpetraMultiVector::getLocalLength"); return vec_->getLocalLength(); }
                
                    //! Global number of rows in the multivector.
       ##### ->     global_size_t getGlobalLength() const { XPETRA_MONITOR("TpetraMultiVector::getGlobalLength"); return vec_->getGlobalLength(); }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
       ##### ->     std::string description() const { XPETRA_MONITOR("TpetraMultiVector::description"); return vec_->description(); }
                
                    //! Print the object with the given verbosity level to a FancyOStream.
       ##### ->     void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { XPETRA_MONITOR("TpetraMultiVector::describe"); vec_->describe(out, verbLevel); }
                
                    //@}
                
                    //! Element-wise multiply of a Vector A with a TpetraMultiVector B.
                    void elementWiseMultiply(Scalar scalarAB, const Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &A, const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &B, Scalar scalarThis); // definition at the end of this file
                    //TODO: void elementWiseMultiply(Scalar scalarAB, const Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, Scalar scalarThis){ vec_->elementWiseMultiply(scalarAB, toTpetra(A), toTpetra(B), scalarThis); }
                
                    //! Set multi-vector values to random numbers.
       ##### ->     void randomize(bool bUseXpetraImplementation = false) {
                        XPETRA_MONITOR("TpetraMultiVector::randomize");
                
                        if(bUseXpetraImplementation)
                            MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >::Xpetra_randomize();
                        else
                            vec_->randomize();
                    }
                
                    //{@
                    // Implements DistObject interface
                
       ##### ->     Teuchos::RCP< const Map<LocalOrdinal,GlobalOrdinal,Node> > getMap() const { XPETRA_MONITOR("TpetraMultiVector::getMap"); return toXpetra(vec_->getMap()); }
                
       ##### ->     void doImport(const DistObject< Scalar, LocalOrdinal,GlobalOrdinal,Node> &source, const Import<LocalOrdinal,GlobalOrdinal,Node> &importer, CombineMode CM) {
                      XPETRA_MONITOR("TpetraMultiVector::doImport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraMultiVectorClass, source, tSource, "Xpetra::TpetraMultiVector::doImport only accept Xpetra::TpetraMultiVector as input arguments."); //TODO: remove and use toTpetra()
                      RCP< const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tSource.getTpetra_MultiVector();
                      this->getTpetra_MultiVector()->doImport(*v, toTpetra(importer), toTpetra(CM));
                    }
                
       ##### ->     void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Import<LocalOrdinal,GlobalOrdinal,Node>& importer, CombineMode CM) {
                      XPETRA_MONITOR("TpetraMultiVector::doExport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraMultiVectorClass, dest, tDest, "Xpetra::TpetraMultiVector::doImport only accept Xpetra::TpetraMultiVector as input arguments."); //TODO: remove and use toTpetra()
                      RCP< const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tDest.getTpetra_MultiVector();
                      this->getTpetra_MultiVector()->doExport(*v, toTpetra(importer), toTpetra(CM));
                
                    }
                
       ##### ->     void doImport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) {
                      XPETRA_MONITOR("TpetraMultiVector::doImport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraMultiVectorClass, source, tSource, "Xpetra::TpetraMultiVector::doImport only accept Xpetra::TpetraMultiVector as input arguments."); //TODO: remove and use toTpetra()
                      RCP< const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tSource.getTpetra_MultiVector();
                      this->getTpetra_MultiVector()->doImport(*v, toTpetra(exporter), toTpetra(CM));
                
                    }
                
       ##### ->     void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) {
                      XPETRA_MONITOR("TpetraMultiVector::doExport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraMultiVectorClass, dest, tDest, "Xpetra::TpetraMultiVector::doImport only accept Xpetra::TpetraMultiVector as input arguments."); //TODO: remove and use toTpetra()
                      RCP< const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tDest.getTpetra_MultiVector();
                      this->getTpetra_MultiVector()->doExport(*v, toTpetra(exporter), toTpetra(CM));
                
                    }
                
       ##### ->     void replaceMap(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& map) {
                      XPETRA_MONITOR("TpetraMultiVector::replaceMap");
                      this->getTpetra_MultiVector()->replaceMap(toTpetra(map));
                    }
                
                    template<class Node2>
                    RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const {
                      XPETRA_MONITOR("TpetraMultiVector::clone");
                      return RCP<MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node2> >(new TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node2>(vec_->clone(node2)));
                        //toXpetra(vec_->clone(node2));
                    }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMultiVector constructor to wrap a Tpetra::MultiVector object
                    TpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > &vec) : vec_(vec) { } //TODO removed const
                
                    //! Get the underlying Tpetra multivector
                    RCP< Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_MultiVector() const { return vec_; }
                
                    //! Set seed for Random function.
       ##### ->     void setSeed(unsigned int seed) { XPETRA_MONITOR("TpetraMultiVector::seedrandom"); Teuchos::ScalarTraits< Scalar >::seedrandom(seed); }
                
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dual_view_type dual_view_type;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::host_execution_space host_execution_space;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dev_execution_space dev_execution_space;
                
                    /// \brief Return an unmanaged non-const view of the local data on a specific device.
                    /// \tparam TargetDeviceType The Kokkos Device type whose data to return.
                    ///
                    /// \warning DO NOT USE THIS FUNCTION! There is no reason why you are working directly
                    ///          with the Xpetra::TpetraMultiVector object. To write a code which is independent
                    ///          from the underlying linear algebra package you should always use the abstract class,
                    ///          i.e. Xpetra::MultiVector!
                    ///
                    /// \warning Be aware that the view on the multivector data is non-persisting, i.e.
                    ///          only valid as long as the multivector does not run of scope!
                    template<class TargetDeviceType>
                    typename Kokkos::Impl::if_c<
                      Kokkos::Impl::is_same<
                        typename dual_view_type::t_dev_um::execution_space::memory_space,
                        typename TargetDeviceType::memory_space>::value,
                        typename dual_view_type::t_dev_um,
                        typename dual_view_type::t_host_um>::type
                    getLocalView () const {
                      return this->MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node >::template getLocalView<TargetDeviceType>();
                    }
                
                    typename dual_view_type::t_host_um getHostLocalView () const {
                      return subview(vec_->template getLocalView<typename dual_view_type::host_mirror_space> (),
                          Kokkos::ALL(), Kokkos::ALL());
                    }
                
                    typename dual_view_type::t_dev_um getDeviceLocalView() const {
                      return subview(vec_->template getLocalView<typename dual_view_type::t_dev_um::execution_space> (),
                          Kokkos::ALL(), Kokkos::ALL());
                    }
                
                #endif
                
                    //@}
                
                  protected:
                    /// \brief Implementation of the assignment operator (operator=);
                    ///   does a deep copy.
                    virtual void
       ##### ->     assign (const MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& rhs)
                    {
                      typedef TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> this_type;
                      const this_type* rhsPtr = dynamic_cast<const this_type*> (&rhs);
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        rhsPtr == NULL, std::invalid_argument, "Xpetra::MultiVector::operator=:"
                        " The left-hand side (LHS) of the assignment has a different type than "
                        "the right-hand side (RHS).  The LHS has type Xpetra::TpetraMultiVector"
                        " (which means it wraps a Tpetra::MultiVector), but the RHS has some "
                        "other type.  This probably means that the RHS wraps an "
                        "Epetra_MultiVector.  Xpetra::MultiVector does not currently implement "
                        "assignment from an Epetra object to a Tpetra object, though this could"
                        " be added with sufficient interest.");
                
                      typedef Tpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node> TMV;
                      RCP<const TMV> rhsImpl = rhsPtr->getTpetra_MultiVector ();
                      RCP<TMV> lhsImpl = this->getTpetra_MultiVector ();
                
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        rhsImpl.is_null (), std::logic_error, "Xpetra::MultiVector::operator= "
                        "(in Xpetra::TpetraMultiVector::assign): *this (the right-hand side of "
                        "the assignment) has a null RCP<Tpetra::MultiVector> inside.  Please "
                        "report this bug to the Xpetra developers.");
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        lhsImpl.is_null (), std::logic_error, "Xpetra::MultiVector::operator= "
                        "(in Xpetra::TpetraMultiVector::assign): The left-hand side of the "
                        "assignment has a null RCP<Tpetra::MultiVector> inside.  Please report "
                        "this bug to the Xpetra developers.");
                
                      Tpetra::deep_copy (*lhsImpl, *rhsImpl);
                    }
                
                  private:
                    //! The Tpetra::MultiVector which this class wraps.
                    RCP< Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > vec_;
                
                  }; // TpetraMultiVector class
                
                  // TODO: move that elsewhere
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
       ##### ->   const Tpetra::MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> & toTpetra(const MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> &x) {
                    typedef TpetraMultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > TpetraMultiVectorClass;
                      XPETRA_DYNAMIC_CAST(const TpetraMultiVectorClass, x, tX, "toTpetra");
                      return *tX.getTpetra_MultiVector();
                  }
                
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
       ##### ->   Tpetra::MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> & toTpetra(MultiVector< Scalar,LocalOrdinal, GlobalOrdinal, Node> &x) {
                    typedef TpetraMultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > TpetraMultiVectorClass;
                      XPETRA_DYNAMIC_CAST(      TpetraMultiVectorClass, x, tX, "toTpetra");
                      return *tX.getTpetra_MultiVector();
                  }
                  //
                
                
                  // Things we actually need
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node > > toXpetra(RCP<Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > vec) {
                    if (!vec.is_null())
                      return rcp(new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node >(vec));
                
                    return Teuchos::null;
                  }
                
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  RCP<const MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node > > toXpetra(RCP<const Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > vec) {
                    if (!vec.is_null())
                      return rcp(new TpetraMultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node >(vec));
                
                    return Teuchos::null;
                  }
                
                #ifdef HAVE_XPETRA_EPETRA
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                
                  // specialization for TpetraMultiVector on EpetraNode and GO=int
                  template <class Scalar>
                  class TpetraMultiVector<Scalar,int,int,EpetraNode>
                    : public virtual MultiVector< Scalar, int, int, EpetraNode >
                  {
                    typedef int LocalOrdinal;
                    typedef int GlobalOrdinal;
                    typedef EpetraNode Node;
                
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraMultiVectorClass;
                
                  public:
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Default constructor
                    TpetraMultiVector () {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Basic constuctor.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, size_t NumVectors, bool zeroOut=true) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Copy constructor (performs a deep copy).
                    TpetraMultiVector(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Create multivector by copying two-dimensional array of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Scalar > &A, size_t LDA, size_t NumVectors) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Create multivector by copying array of views of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                
                    //! Destructor (virtual for memory safety of derived classes).
                    virtual ~TpetraMultiVector() {  }
                
                    //@}
                
                    //! @name Post-construction modification routines
                    //@{
                
                    //! Replace value, using global (row) index.
                    void replaceGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Add value to existing value, using global (row) index.
                    void sumIntoGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Replace value, using local (row) index.
                    void replaceLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Add value to existing value, using local (row) index.
                    void sumIntoLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Set all values in the multivector with the given value.
                    void putScalar(const Scalar &value) { }
                
                    //! Sum values of a locally replicated multivector across all processes.
                    void reduce() { }
                
                    //@}
                
                    //! @name Data Copy and View get methods
                    //@{
                
                    //! Return a Vector which is a const view of column j.
                    Teuchos::RCP< const Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVector(size_t j) const { return Teuchos::null; }
                
                    //! Return a Vector which is a nonconst view of column j.
                    Teuchos::RCP< Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVectorNonConst(size_t j) { return Teuchos::null; }
                
                    //! Const view of the local values in a particular vector of this multivector.
                    Teuchos::ArrayRCP< const Scalar > getData(size_t j) const { return Teuchos::ArrayRCP< const Scalar >(); }
                
                    //! View of the local values in a particular vector of this multivector.
                    Teuchos::ArrayRCP< Scalar > getDataNonConst(size_t j) { return Teuchos::ArrayRCP< Scalar >(); }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get1dCopy(Teuchos::ArrayView< Scalar > A, size_t LDA) const { }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get2dCopy(Teuchos::ArrayView< const Teuchos::ArrayView< Scalar > > ArrayOfPtrs) const { }
                
                    //! Const persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< const Scalar > get1dView() const { return Teuchos::ArrayRCP< const Scalar >(); }
                
                    //! Return const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< const Scalar > > get2dView() const { return Teuchos::ArrayRCP< Teuchos::ArrayRCP< const Scalar > >(); }
                
                    //! Nonconst persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< Scalar > get1dViewNonConst() { return Teuchos::ArrayRCP< Scalar >(); }
                
                    //! Return non-const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< Scalar > > get2dViewNonConst() { return Teuchos::ArrayRCP< Teuchos::ArrayRCP< Scalar > >(); }
                
                    //@}
                
                    //! @name Mathematical methods
                    //@{
                
                    //! Compute dot product of each corresponding pair of vectors, dots[i] = this[i].dot(A[i]).
                    void dot(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Teuchos::ArrayView< Scalar > &dots) const { }
                
                    //! Put element-wise absolute values of input Multi-vector in target: A = abs(this).
                    void abs(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Put element-wise reciprocal values of input Multi-vector in target, this(i,j) = 1/A(i,j).
                    void reciprocal(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Scale the current values of a multi-vector, this = alpha*this.
                    void scale(const Scalar &alpha) { }
                
                    //! Scale the current values of a multi-vector, this[j] = alpha[j]*this[j].
                    void scale(Teuchos::ArrayView< const Scalar > alpha) { }
                
                    //! Replace multi-vector values with scaled values of A, this = alpha*A.
                    void scale(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Update multi-vector values with scaled values of A, this = beta*this + alpha*A.
                    void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta) { }
                
                    //! Update multi-vector with scaled values of A and B, this = gamma*this + alpha*A + beta*B.
                    void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &gamma) { }
                
                    //! Compute 1-norm of each vector in multi-vector.
                    void norm1(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //!
                    void norm2(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //! Compute Inf-norm of each vector in multi-vector.
                    void normInf(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //! Compute mean (average) value of each vector in multi-vector. The outcome of this routine is undefined for non-floating point scalar types (e.g., int).
                    void meanValue(const Teuchos::ArrayView< Scalar > &means) const { }
                
                    //! Matrix-matrix multiplication: this = beta*this + alpha*op(A)*op(B).
                    void multiply(Teuchos::ETransp transA, Teuchos::ETransp transB, const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &beta) { }
                
                    //@}
                
                    //! @name Attribute access functions
                    //@{
                
                    //! Number of columns in the multivector.
                    size_t getNumVectors() const { return 0; }
                
                    //! Local number of rows on the calling process.
                    size_t getLocalLength() const { return 0; }
                
                    //! Global number of rows in the multivector.
                    global_size_t getGlobalLength() const { return 0; }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print the object with the given verbosity level to a FancyOStream.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    //@}
                
                    //! Element-wise multiply of a Vector A with a TpetraMultiVector B.
                    void elementWiseMultiply(Scalar scalarAB, const Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &A, const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &B, Scalar scalarThis) {};
                
                    //! Set multi-vector values to random numbers.
                    void randomize(bool bUseXpetraImplementation = false) { }
                
                    //{@
                    // Implements DistObject interface
                
                    Teuchos::RCP< const Map<LocalOrdinal,GlobalOrdinal,Node> > getMap() const { return Teuchos::null; }
                
                    void doImport(const DistObject< Scalar, LocalOrdinal,GlobalOrdinal,Node> &source, const Import<LocalOrdinal,GlobalOrdinal,Node> &importer, CombineMode CM) { }
                
                    void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Import<LocalOrdinal,GlobalOrdinal,Node>& importer, CombineMode CM) { }
                
                    void doImport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) { }
                
                    void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) { }
                
                    void replaceMap(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& map) { }
                
                    template<class Node2>
                    RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMultiVector constructor to wrap a Tpetra::MultiVector object
                    TpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > &vec) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Get the underlying Tpetra multivector
                    RCP< Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_MultiVector() const { return Teuchos::null; }
                
                    //! Set seed for Random function.
                    void setSeed(unsigned int seed) { }
                
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dual_view_type dual_view_type;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::host_execution_space host_execution_space;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dev_execution_space dev_execution_space;
                
                    /// \brief Return an unmanaged non-const view of the local data on a specific device.
                    /// \tparam TargetDeviceType The Kokkos Device type whose data to return.
                    ///
                    /// \warning DO NOT USE THIS FUNCTION! There is no reason why you are working directly
                    ///          with the Xpetra::TpetraMultiVector object. To write a code which is independent
                    ///          from the underlying linear algebra package you should always use the abstract class,
                    ///          i.e. Xpetra::MultiVector!
                    ///
                    /// \warning Be aware that the view on the multivector data is non-persisting, i.e.
                    ///          only valid as long as the multivector does not run of scope!
                    template<class TargetDeviceType>
                    typename Kokkos::Impl::if_c<
                      Kokkos::Impl::is_same<
                        typename dual_view_type::t_dev_um::execution_space::memory_space,
                        typename TargetDeviceType::memory_space>::value,
                        typename dual_view_type::t_dev_um,
                        typename dual_view_type::t_host_um>::type
                    getLocalView () const {
                      typename Kokkos::Impl::if_c<
                            Kokkos::Impl::is_same<
                              typename dual_view_type::t_dev_um::execution_space::memory_space,
                              typename TargetDeviceType::memory_space>::value,
                              typename dual_view_type::t_dev_um,
                              typename dual_view_type::t_host_um>::type dummy;
                      return dummy;
                    }
                
                    typename dual_view_type::t_host_um getHostLocalView () const {
                      //return subview(vec_->template getLocalView<typename dual_view_type::host_mirror_space> (),
                      //    Kokkos::ALL(), Kokkos::ALL());
                      return typename dual_view_type::t_host_um();
                    }
                
                    typename dual_view_type::t_dev_um getDeviceLocalView() const {
                      //return subview(vec_->template getLocalView<typename dual_view_type::t_dev_um::execution_space> (),
                      //    Kokkos::ALL(), Kokkos::ALL());
                      return typename dual_view_type::t_dev_um();
                    }
                
                #endif
                
                    //@}
                
                  protected:
                    /// \brief Implementation of the assignment operator (operator=);
                    ///   does a deep copy.
                    virtual void
                    assign (const MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& rhs)
                    { }
                  }; // TpetraMultiVector class (specialization GO=int, NO=EpetraNode)
                #endif
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))))
                
                  // specialization for TpetraMultiVector on EpetraNode and GO=long long
                  template <class Scalar>
                  class TpetraMultiVector<Scalar,int,long long,EpetraNode>
                    : public virtual MultiVector< Scalar, int, long long, EpetraNode >
                  {
                    typedef int LocalOrdinal;
                    typedef long long GlobalOrdinal;
                    typedef EpetraNode Node;
                
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraMultiVectorClass;
                
                  public:
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Basic constuctor.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, size_t NumVectors, bool zeroOut=true) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Copy constructor (performs a deep copy).
                    TpetraMultiVector(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Create multivector by copying two-dimensional array of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Scalar > &A, size_t LDA, size_t NumVectors) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Create multivector by copying array of views of local data.
                    TpetraMultiVector(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map, const Teuchos::ArrayView< const Teuchos::ArrayView< const Scalar > > &ArrayOfPtrs, size_t NumVectors) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                
                    //! Destructor (virtual for memory safety of derived classes).
                    virtual ~TpetraMultiVector() {  }
                
                    //@}
                
                    //! @name Post-construction modification routines
                    //@{
                
                    //! Replace value, using global (row) index.
                    void replaceGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Add value to existing value, using global (row) index.
                    void sumIntoGlobalValue(GlobalOrdinal globalRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Replace value, using local (row) index.
                    void replaceLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Add value to existing value, using local (row) index.
                    void sumIntoLocalValue(LocalOrdinal myRow, size_t vectorIndex, const Scalar &value) { }
                
                    //! Set all values in the multivector with the given value.
                    void putScalar(const Scalar &value) { }
                
                    //! Sum values of a locally replicated multivector across all processes.
                    void reduce() { }
                
                    //@}
                
                    //! @name Data Copy and View get methods
                    //@{
                
                    //! Return a Vector which is a const view of column j.
                    Teuchos::RCP< const Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVector(size_t j) const { return Teuchos::null; }
                
                    //! Return a Vector which is a nonconst view of column j.
                    Teuchos::RCP< Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > > getVectorNonConst(size_t j) { return Teuchos::null; }
                
                    //! Const view of the local values in a particular vector of this multivector.
                    Teuchos::ArrayRCP< const Scalar > getData(size_t j) const { return Teuchos::ArrayRCP< const Scalar >(); }
                
                    //! View of the local values in a particular vector of this multivector.
                    Teuchos::ArrayRCP< Scalar > getDataNonConst(size_t j) { return Teuchos::ArrayRCP< Scalar >(); }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get1dCopy(Teuchos::ArrayView< Scalar > A, size_t LDA) const { }
                
                    //! Fill the given array with a copy of this multivector's local values.
                    void get2dCopy(Teuchos::ArrayView< const Teuchos::ArrayView< Scalar > > ArrayOfPtrs) const { }
                
                    //! Const persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< const Scalar > get1dView() const { return Teuchos::ArrayRCP< const Scalar >(); }
                
                    //! Return const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< const Scalar > > get2dView() const { return Teuchos::ArrayRCP< Teuchos::ArrayRCP< const Scalar > >(); }
                
                    //! Nonconst persisting (1-D) view of this multivector's local values.
                    Teuchos::ArrayRCP< Scalar > get1dViewNonConst() { return Teuchos::ArrayRCP< Scalar >(); }
                
                    //! Return non-const persisting pointers to values.
                    Teuchos::ArrayRCP< Teuchos::ArrayRCP< Scalar > > get2dViewNonConst() { return Teuchos::ArrayRCP< Teuchos::ArrayRCP< Scalar > >(); }
                
                    //@}
                
                    //! @name Mathematical methods
                    //@{
                
                    //! Compute dot product of each corresponding pair of vectors, dots[i] = this[i].dot(A[i]).
                    void dot(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Teuchos::ArrayView< Scalar > &dots) const { }
                
                    //! Put element-wise absolute values of input Multi-vector in target: A = abs(this).
                    void abs(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Put element-wise reciprocal values of input Multi-vector in target, this(i,j) = 1/A(i,j).
                    void reciprocal(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Scale the current values of a multi-vector, this = alpha*this.
                    void scale(const Scalar &alpha) { }
                
                    //! Scale the current values of a multi-vector, this[j] = alpha[j]*this[j].
                    void scale(Teuchos::ArrayView< const Scalar > alpha) { }
                
                    //! Replace multi-vector values with scaled values of A, this = alpha*A.
                    void scale(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A) { }
                
                    //! Update multi-vector values with scaled values of A, this = beta*this + alpha*A.
                    void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta) { }
                
                    //! Update multi-vector with scaled values of A and B, this = gamma*this + alpha*A + beta*B.
                    void update(const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const Scalar &beta, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &gamma) { }
                
                    //! Compute 1-norm of each vector in multi-vector.
                    void norm1(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //!
                    void norm2(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //! Compute Inf-norm of each vector in multi-vector.
                    void normInf(const Teuchos::ArrayView< typename Teuchos::ScalarTraits< Scalar >::magnitudeType > &norms) const { }
                
                    //! Compute mean (average) value of each vector in multi-vector. The outcome of this routine is undefined for non-floating point scalar types (e.g., int).
                    void meanValue(const Teuchos::ArrayView< Scalar > &means) const { }
                
                    //! Matrix-matrix multiplication: this = beta*this + alpha*op(A)*op(B).
                    void multiply(Teuchos::ETransp transA, Teuchos::ETransp transB, const Scalar &alpha, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &A, const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &B, const Scalar &beta) { }
                
                    //@}
                
                    //! @name Attribute access functions
                    //@{
                
                    //! Number of columns in the multivector.
                    size_t getNumVectors() const { return 0; }
                
                    //! Local number of rows on the calling process.
                    size_t getLocalLength() const { return 0; }
                
                    //! Global number of rows in the multivector.
                    global_size_t getGlobalLength() const { return 0; }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print the object with the given verbosity level to a FancyOStream.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    //@}
                
                    //! Element-wise multiply of a Vector A with a TpetraMultiVector B.
                    void elementWiseMultiply(Scalar scalarAB, const Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &A, const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &B, Scalar scalarThis) {};
                
                    //! Set multi-vector values to random numbers.
                    void randomize(bool bUseXpetraImplementation = false) { }
                
                    //{@
                    // Implements DistObject interface
                
                    Teuchos::RCP< const Map<LocalOrdinal,GlobalOrdinal,Node> > getMap() const { return Teuchos::null; }
                
                    void doImport(const DistObject< Scalar, LocalOrdinal,GlobalOrdinal,Node> &source, const Import<LocalOrdinal,GlobalOrdinal,Node> &importer, CombineMode CM) { }
                
                    void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Import<LocalOrdinal,GlobalOrdinal,Node>& importer, CombineMode CM) { }
                
                    void doImport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &source, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) { }
                
                    void doExport(const DistObject< Scalar, LocalOrdinal, GlobalOrdinal, Node > &dest, const Export<LocalOrdinal,GlobalOrdinal,Node>& exporter, CombineMode CM) { }
                
                    void replaceMap(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& map) { }
                
                    template<class Node2>
                    RCP<MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMultiVector constructor to wrap a Tpetra::MultiVector object
                    TpetraMultiVector(const Teuchos::RCP<Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > &vec) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Get the underlying Tpetra multivector
                    RCP< Tpetra::MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_MultiVector() const { return Teuchos::null; }
                
                    //! Set seed for Random function.
                    void setSeed(unsigned int seed) { }
                
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dual_view_type dual_view_type;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::host_execution_space host_execution_space;
                    //typedef typename Xpetra::MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>::dev_execution_space dev_execution_space;
                
                    /// \brief Return an unmanaged non-const view of the local data on a specific device.
                    /// \tparam TargetDeviceType The Kokkos Device type whose data to return.
                    ///
                    /// \warning DO NOT USE THIS FUNCTION! There is no reason why you are working directly
                    ///          with the Xpetra::TpetraMultiVector object. To write a code which is independent
                    ///          from the underlying linear algebra package you should always use the abstract class,
                    ///          i.e. Xpetra::MultiVector!
                    ///
                    /// \warning Be aware that the view on the multivector data is non-persisting, i.e.
                    ///          only valid as long as the multivector does not run of scope!
                    template<class TargetDeviceType>
                    typename Kokkos::Impl::if_c<
                      Kokkos::Impl::is_same<
                        typename dual_view_type::t_dev_um::execution_space::memory_space,
                        typename TargetDeviceType::memory_space>::value,
                        typename dual_view_type::t_dev_um,
                        typename dual_view_type::t_host_um>::type
                    getLocalView () const {
                      typename Kokkos::Impl::if_c<
                            Kokkos::Impl::is_same<
                              typename dual_view_type::t_dev_um::execution_space::memory_space,
                              typename TargetDeviceType::memory_space>::value,
                              typename dual_view_type::t_dev_um,
                              typename dual_view_type::t_host_um>::type dummy;
                      return dummy;
                    }
                
                    typename dual_view_type::t_host_um getHostLocalView () const {
                      //return subview(vec_->template getLocalView<typename dual_view_type::host_mirror_space> (),
                      //    Kokkos::ALL(), Kokkos::ALL());
                      return typename dual_view_type::t_host_um();
                    }
                
                    typename dual_view_type::t_dev_um getDeviceLocalView() const {
                      //return subview(vec_->template getLocalView<typename dual_view_type::t_dev_um::execution_space> (),
                      //    Kokkos::ALL(), Kokkos::ALL());
                      return typename dual_view_type::t_dev_um();
                    }
                
                #endif
                
                    //@}
                
                  protected:
                    /// \brief Implementation of the assignment operator (operator=);
                    ///   does a deep copy.
                    virtual void
                    assign (const MultiVector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& rhs)
                    { }
                  }; // TpetraMultiVector class (specialization GO=int, NO=EpetraNode)
                
                #endif // TpetraMultiVector class (specialization GO=long long, NO=EpetraNode)
                
                #endif // HAVE_XPETRA_EPETRA
                
                } // Xpetra namespace
                
                // Following header file inculsion is needed for the dynamic_cast to TpetraVector in elementWiseMultiply (because we cannot dynamic_cast if target is not a complete type)
                // It is included here to avoid circular dependency between Vector and MultiVector
                // TODO: there is certainly a more elegant solution...
                #include "Xpetra_TpetraVector.hpp"
                
                namespace Xpetra {
                  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
       ##### ->   void TpetraMultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>::elementWiseMultiply(Scalar scalarAB, const Vector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &A, const MultiVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> &B, Scalar scalarThis) {
                    XPETRA_MONITOR("TpetraMultiVector::elementWiseMultiply");
                
                    // XPETRA_DYNAMIC_CAST won't take TpetraVector<Scalar,LocalOrdinal,GlobalOrdinal,Node>
                    // as an argument, hence the following typedef.
                    typedef TpetraVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> tpv;
                    XPETRA_DYNAMIC_CAST(const tpv, A, tA, "Xpetra::TpetraMultiVectorMatrix->multiply() only accept Xpetra::TpetraMultiVector as input arguments.");
                    XPETRA_DYNAMIC_CAST(const TpetraMultiVector, B, tB, "Xpetra::TpetraMultiVectorMatrix->multiply() only accept Xpetra::TpetraMultiVector as input arguments.");
                    vec_->elementWiseMultiply(scalarAB, *tA.getTpetra_Vector(), *tB.getTpetra_MultiVector(), scalarThis);
                  }
                
                } // Xpetra namespace
                
                #define XPETRA_TPETRAMULTIVECTOR_SHORT
                #endif // XPETRA_TPETRAMULTIVECTOR_HPP


Top 10 Lines:

     Line      Count

      129          1
      149          1

Execution Summary:

       39   Executable lines in this file
       39   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.05   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_TpetraCrsMatrix.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef XPETRA_TPETRACRSMATRIX_HPP
                #define XPETRA_TPETRACRSMATRIX_HPP
                
                /* this file is automatically generated - do not edit (see scripts/tpetra.py) */
                
                // FIXME (mfh 03 Sep 2014) The above is probably not true anymore.
                // Furthermore, I don't think anyone maintains the scripts.
                // Feel free to correct this comment if I'm wrong.
                
                #include "Xpetra_TpetraConfigDefs.hpp"
                
                #include "Tpetra_CrsMatrix.hpp"
                
                #include "Xpetra_CrsMatrix.hpp"
                #include "Xpetra_TpetraMap.hpp"
                #include "Xpetra_TpetraMultiVector.hpp"
                #include "Xpetra_TpetraVector.hpp"
                #include "Xpetra_TpetraCrsGraph.hpp"
                //#include "Xpetra_TpetraRowMatrix.hpp"
                #include "Xpetra_Exceptions.hpp"
                
                namespace Xpetra {
                
                  // TODO: move that elsewhere
                  // template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
                  // const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> toTpetraCrsMatrix(const Xpetra::DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &);
                  //
                
                  template<class Scalar = CrsMatrix<>::scalar_type,
                           class LocalOrdinal =
                             typename CrsMatrix<Scalar>::local_ordinal_type,
                           class GlobalOrdinal =
                             typename CrsMatrix<Scalar, LocalOrdinal>::global_ordinal_type,
                           class Node =
                             typename CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal>::node_type>
                  class TpetraCrsMatrix
                    : public CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> //, public TpetraRowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>
                  {
                
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraCrsMatrixClass;
                    typedef TpetraVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraVectorClass;
                    typedef TpetraImport<LocalOrdinal,GlobalOrdinal,Node> TpetraImportClass;
                    typedef TpetraExport<LocalOrdinal,GlobalOrdinal,Node> TpetraExportClass;
                
                    // The following typedefs are used by the Kokkos interface
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>::local_matrix_type local_matrix_type;
                #endif
                
                  public:
                
                    //! @name Constructor/Destructor Methods
                    //@{
                
                    //! Constructor specifying fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null)
                      : mtx_ (Teuchos::rcp (new Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> (toTpetra(rowMap), maxNumEntriesPerRow, toTpetra(pftype), params))) {  }
                
                    //! Constructor specifying (possibly different) number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null)
                      : mtx_(Teuchos::rcp(new Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> (toTpetra(rowMap), NumEntriesPerRowToAlloc, toTpetra(pftype), params))) {  }
                
                    //! Constructor specifying column Map and fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null)
                      : mtx_(Teuchos::rcp(new Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>(toTpetra(rowMap), toTpetra(colMap), maxNumEntriesPerRow, toTpetra(pftype), params))) {  }
                
                    //! Constructor specifying column Map and number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null)
                      : mtx_(Teuchos::rcp(new Tpetra::CrsMatrix< Scalar, LocalOrdinal, GlobalOrdinal, Node >(toTpetra(rowMap), toTpetra(colMap), NumEntriesPerRowToAlloc, toTpetra(pftype), params))) {  }
                
                    //! Constructor specifying a previously constructed graph.
                    TpetraCrsMatrix(const Teuchos::RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > &graph, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null)
                      : mtx_(Teuchos::rcp(new Tpetra::CrsMatrix< Scalar, LocalOrdinal, GlobalOrdinal, Node >(toTpetra(graph), params))) {  }
                
                
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & importer,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null)
                    {
                      typedef Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> MyTpetraCrsMatrix;
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, *sourceMatrix, tSourceMatrix, "Xpetra::TpetraCrsMatrix constructor only accepts Xpetra::TpetraCrsMatrix as the input argument.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSourceMatrix.getTpetra_CrsMatrix();
                
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myDomainMap = domainMap!=Teuchos::null ? toTpetra(domainMap) : Teuchos::null;
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myRangeMap  = rangeMap!=Teuchos::null  ? toTpetra(rangeMap)  : Teuchos::null;
                      mtx_=Tpetra::importAndFillCompleteCrsMatrix<MyTpetraCrsMatrix>(tSourceMatrix.getTpetra_CrsMatrix(),toTpetra(importer),myDomainMap,myRangeMap,params);
                      bool restrictComm=false;
                      if(!params.is_null()) restrictComm = params->get("Restrict Communicator",restrictComm);
                      if(restrictComm && mtx_->getRowMap().is_null()) mtx_=Teuchos::null;
                
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & exporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null)
                    {
                      typedef Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> MyTpetraCrsMatrix;
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, *sourceMatrix, tSourceMatrix, "Xpetra::TpetraCrsMatrix constructor only accepts Xpetra::TpetraCrsMatrix as the input argument.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSourceMatrix.getTpetra_CrsMatrix();
                
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myDomainMap = domainMap!=Teuchos::null ? toTpetra(domainMap) : Teuchos::null;
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myRangeMap  = rangeMap!=Teuchos::null  ? toTpetra(rangeMap)  : Teuchos::null;
                      mtx_=Tpetra::exportAndFillCompleteCrsMatrix<MyTpetraCrsMatrix>(tSourceMatrix.getTpetra_CrsMatrix(),toTpetra(exporter),myDomainMap,myRangeMap,params);
                
                    }
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & RowImporter,
                                    const Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > DomainImporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      typedef Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> MyTpetraCrsMatrix;
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, *sourceMatrix, tSourceMatrix, "Xpetra::TpetraCrsMatrix constructor only accepts Xpetra::TpetraCrsMatrix as the input argument.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSourceMatrix.getTpetra_CrsMatrix();
                
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myDomainMap = domainMap!=Teuchos::null ? toTpetra(domainMap) : Teuchos::null;
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myRangeMap  = rangeMap!=Teuchos::null  ? toTpetra(rangeMap)  : Teuchos::null;
                
                      mtx_=Tpetra::importAndFillCompleteCrsMatrix<MyTpetraCrsMatrix>(tSourceMatrix.getTpetra_CrsMatrix(),toTpetra(RowImporter),toTpetra(*DomainImporter),myDomainMap,myRangeMap,params);
                      bool restrictComm=false;
                      if(!params.is_null()) restrictComm = params->get("Restrict Communicator",restrictComm);
                      if(restrictComm && mtx_->getRowMap().is_null()) mtx_=Teuchos::null;
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & RowExporter,
                                    const Teuchos::RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > DomainExporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      typedef Tpetra::CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> MyTpetraCrsMatrix;
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, *sourceMatrix, tSourceMatrix, "Xpetra::TpetraCrsMatrix constructor only accepts Xpetra::TpetraCrsMatrix as the input argument.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSourceMatrix.getTpetra_CrsMatrix();
                
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myDomainMap = domainMap!=Teuchos::null ? toTpetra(domainMap) : Teuchos::null;
                      RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> > myRangeMap  = rangeMap!=Teuchos::null  ? toTpetra(rangeMap)  : Teuchos::null;
                
                      mtx_=Tpetra::exportAndFillCompleteCrsMatrix<MyTpetraCrsMatrix>(tSourceMatrix.getTpetra_CrsMatrix(),toTpetra(RowExporter),toTpetra(*DomainExporter),myDomainMap,myRangeMap,params);
                    }
                
                
                    /// \brief Constructor specifying column Map and a local matrix,
                    ///   which the resulting CrsMatrix views.
                    ///
                    /// Unlike most other CrsMatrix constructors, successful
                    /// completion of this constructor will result in a fill-complete
                    /// matrix.
                    ///
                    /// \param rowMap [in] Distribution of rows of the matrix.
                    ///
                    /// \param colMap [in] Distribution of columns of the matrix.
                    ///
                    /// \param lclMatrix [in] A local CrsMatrix containing all local
                    ///    matrix values as well as a local graph.  The graph's local
                    ///    row indices must come from the specified row Map, and its
                    ///    local column indices must come from the specified column
                    ///    Map.
                    ///
                    /// \param params [in/out] Optional list of parameters.  If not
                    ///   null, any missing parameters will be filled in with their
                    ///   default values.
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    TpetraCrsMatrix (const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rowMap,
                        const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& colMap,
                        const local_matrix_type& lclMatrix,
                        const Teuchos::RCP<Teuchos::ParameterList>& params = null)
                    : mtx_(Teuchos::rcp(new Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>(toTpetra(rowMap), toTpetra(colMap), lclMatrix, params))) {  }
                #endif
                
                    //! Destructor.
       ##### ->     virtual ~TpetraCrsMatrix() {  }
                
                    //@}
                
                    //! @name Insertion/Removal Methods
                    //@{
                
                    //! Insert matrix entries, using global IDs.
       ##### ->     void insertGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) { XPETRA_MONITOR("TpetraCrsMatrix::insertGlobalValues"); mtx_->insertGlobalValues(globalRow, cols, vals); }
                
                    //! Insert matrix entries, using local IDs.
       ##### ->     void insertLocalValues(LocalOrdinal localRow, const ArrayView< const LocalOrdinal > &cols, const ArrayView< const Scalar > &vals) { XPETRA_MONITOR("TpetraCrsMatrix::insertLocalValues"); mtx_->insertLocalValues(localRow, cols, vals); }
                
                    //! Replace matrix entries, using global IDs.
       ##### ->     void replaceGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) { XPETRA_MONITOR("TpetraCrsMatrix::replaceGlobalValues"); mtx_->replaceGlobalValues(globalRow, cols, vals); }
                
                    //! Replace matrix entries, using local IDs.
                    void
       ##### ->     replaceLocalValues (LocalOrdinal localRow,
                                        const ArrayView<const LocalOrdinal> &cols,
                                        const ArrayView<const Scalar> &vals)
                    {
                      XPETRA_MONITOR("TpetraCrsMatrix::replaceLocalValues");
                      typedef typename ArrayView<const LocalOrdinal>::size_type size_type;
                      const LocalOrdinal numValid =
                        mtx_->replaceLocalValues (localRow, cols, vals);
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        static_cast<size_type> (numValid) != cols.size (), std::runtime_error,
                        "replaceLocalValues returned " << numValid << " != cols.size() = " <<
                        cols.size () << ".");
                    }
                
                    //! Set all matrix entries equal to scalarThis.
       ##### ->     void setAllToScalar(const Scalar &alpha) { XPETRA_MONITOR("TpetraCrsMatrix::setAllToScalar"); mtx_->setAllToScalar(alpha); }
                
                    //! Scale the current values of a matrix, this = alpha*this.
       ##### ->     void scale(const Scalar &alpha) { XPETRA_MONITOR("TpetraCrsMatrix::scale"); mtx_->scale(alpha); }
                
                    //! Allocates and returns ArrayRCPs of the Crs arrays --- This is an Xpetra-only routine.
                    //** \warning This is an expert-only routine and should not be called from user code. */
       ##### ->     void allocateAllValues(size_t numNonZeros,ArrayRCP<size_t> & rowptr, ArrayRCP<LocalOrdinal> & colind, ArrayRCP<Scalar> & values)
                    { XPETRA_MONITOR("TpetraCrsMatrix::allocateAllValues"); rowptr.resize(getNodeNumRows()+1); colind.resize(numNonZeros); values.resize(numNonZeros);}
                
                    //! Sets the 1D pointer arrays of the graph.
       ##### ->     void setAllValues(const ArrayRCP<size_t> & rowptr, const ArrayRCP<LocalOrdinal> & colind, const ArrayRCP<Scalar> & values)
                    { XPETRA_MONITOR("TpetraCrsMatrix::setAllValues"); mtx_->setAllValues(rowptr,colind,values); }
                
                    //! Gets the 1D pointer arrays of the graph.
       ##### ->     void getAllValues(ArrayRCP<const size_t>& rowptr, ArrayRCP<const LocalOrdinal>& colind, ArrayRCP<const Scalar>& values) const
                    { XPETRA_MONITOR("TpetraCrsMatrix::getAllValues"); mtx_->getAllValues(rowptr,colind,values); }
                
                    //@}
                
                    //! @name Transformational Methods
                    //@{
                
                    //!
       ##### ->     void resumeFill(const RCP< ParameterList > &params=null) { XPETRA_MONITOR("TpetraCrsMatrix::resumeFill"); mtx_->resumeFill(params); }
                
                    //! Signal that data entry is complete, specifying domain and range maps.
       ##### ->     void fillComplete(const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &domainMap, const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rangeMap, const RCP< ParameterList > &params=null) { XPETRA_MONITOR("TpetraCrsMatrix::fillComplete"); mtx_->fillComplete(toTpetra(domainMap), toTpetra(rangeMap), params); }
                
                    //! Signal that data entry is complete.
       ##### ->     void fillComplete(const RCP< ParameterList > &params=null) { XPETRA_MONITOR("TpetraCrsMatrix::fillComplete"); mtx_->fillComplete(params); }
                
                
                    //!  Replaces the current domainMap and importer with the user-specified objects.
       ##### ->     void replaceDomainMapAndImporter(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >& newDomainMap, Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> >  & newImporter) {
                      XPETRA_MONITOR("TpetraCrsMatrix::replaceDomainMapAndImporter");
                      XPETRA_DYNAMIC_CAST( const TpetraImportClass , *newImporter, tImporter, "Xpetra::TpetraCrsMatrix::replaceDomainMapAndImporter only accepts Xpetra::TpetraImport.");
                      RCP<const Tpetra::Import<LocalOrdinal,GlobalOrdinal,Node> > myImport = tImporter.getTpetra_Import();
                            mtx_->replaceDomainMapAndImporter( toTpetra(newDomainMap),myImport);
                    }
                
                    //! Expert static fill complete
       ##### ->     void expertStaticFillComplete(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & domainMap,
                                                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & rangeMap,
                                                  const RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > &importer=Teuchos::null,
                                                  const RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > &exporter=Teuchos::null,
                                                  const RCP<ParameterList> &params=Teuchos::null) {
                      XPETRA_MONITOR("TpetraCrsMatrix::expertStaticFillComplete");
                      RCP<const Tpetra::Import<LocalOrdinal,GlobalOrdinal,Node> > myImport;
                      RCP<const Tpetra::Export<LocalOrdinal,GlobalOrdinal,Node> > myExport;
                
                      if(importer!=Teuchos::null) {
                        XPETRA_DYNAMIC_CAST( const TpetraImportClass , *importer, tImporter, "Xpetra::TpetraCrsMatrix::expertStaticFillComplete only accepts Xpetra::TpetraImport.");
                        myImport = tImporter.getTpetra_Import();
                      }
                      if(exporter!=Teuchos::null) {
                        XPETRA_DYNAMIC_CAST( const TpetraExportClass , *exporter, tExporter, "Xpetra::TpetraCrsMatrix::expertStaticFillComplete only accepts Xpetra::TpetraExport.");
                        myExport = tExporter.getTpetra_Export();
                      }
                
                      mtx_->expertStaticFillComplete(toTpetra(domainMap),toTpetra(rangeMap),myImport,myExport,params);
                    }
                
                    //@}
                
                    //! @name Methods implementing RowMatrix
                    //@{
                
                    //! Returns the Map that describes the row distribution in this matrix.
           1 ->     const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRowMap() const { XPETRA_MONITOR("TpetraCrsMatrix::getRowMap"); return toXpetra(mtx_->getRowMap()); }
                
                    //! Returns the Map that describes the column distribution in this matrix.
           1 ->     const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getColMap() const { XPETRA_MONITOR("TpetraCrsMatrix::getColMap"); return toXpetra(mtx_->getColMap()); }
                
                    //! Returns the CrsGraph associated with this matrix.
       ##### ->     RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > getCrsGraph() const { XPETRA_MONITOR("TpetraCrsMatrix::getCrsGraph"); return toXpetra(mtx_->getCrsGraph()); }
                
                    //! Number of global elements in the row map of this matrix.
       ##### ->     global_size_t getGlobalNumRows() const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalNumRows"); return mtx_->getGlobalNumRows(); }
                
                    //! Number of global columns in the matrix.
       ##### ->     global_size_t getGlobalNumCols() const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalNumCols"); return mtx_->getGlobalNumCols(); }
                
                    //! Returns the number of matrix rows owned on the calling node.
       ##### ->     size_t getNodeNumRows() const { XPETRA_MONITOR("TpetraCrsMatrix::getNodeNumRows"); return mtx_->getNodeNumRows(); }
                
                    //! Returns the number of columns connected to the locally owned rows of this matrix.
       ##### ->     size_t getNodeNumCols() const { XPETRA_MONITOR("TpetraCrsMatrix::getNodeNumCols"); return mtx_->getNodeNumCols(); }
                
                    //! Returns the global number of entries in this matrix.
           6 ->     global_size_t getGlobalNumEntries() const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalNumEntries"); return mtx_->getGlobalNumEntries(); }
                
                    //! Returns the local number of entries in this matrix.
       ##### ->     size_t getNodeNumEntries() const { XPETRA_MONITOR("TpetraCrsMatrix::getNodeNumEntries"); return mtx_->getNodeNumEntries(); }
                
                    //! Returns the current number of entries on this node in the specified local row.
       ##### ->     size_t getNumEntriesInLocalRow(LocalOrdinal localRow) const { XPETRA_MONITOR("TpetraCrsMatrix::getNumEntriesInLocalRow"); return mtx_->getNumEntriesInLocalRow(localRow); }
                
                    //! Returns the number of global diagonal entries, based on global row/column index comparisons.
       ##### ->     global_size_t getGlobalNumDiags() const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalNumDiags"); return mtx_->getGlobalNumDiags(); }
                
                    //! Returns the number of local diagonal entries, based on global row/column index comparisons.
       ##### ->     size_t getNodeNumDiags() const { XPETRA_MONITOR("TpetraCrsMatrix::getNodeNumDiags"); return mtx_->getNodeNumDiags(); }
                
                    //! Returns the maximum number of entries across all rows/columns on all nodes.
       ##### ->     size_t getGlobalMaxNumRowEntries() const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalMaxNumRowEntries"); return mtx_->getGlobalMaxNumRowEntries(); }
                
                    //! Returns the maximum number of entries across all rows/columns on this node.
       ##### ->     size_t getNodeMaxNumRowEntries() const { XPETRA_MONITOR("TpetraCrsMatrix::getNodeMaxNumRowEntries"); return mtx_->getNodeMaxNumRowEntries(); }
                
                    //! If matrix indices are in the local range, this function returns true. Otherwise, this function returns false.
       ##### ->     bool isLocallyIndexed() const { XPETRA_MONITOR("TpetraCrsMatrix::isLocallyIndexed"); return mtx_->isLocallyIndexed(); }
                
                    //! If matrix indices are in the global range, this function returns true. Otherwise, this function returns false.
       ##### ->     bool isGloballyIndexed() const { XPETRA_MONITOR("TpetraCrsMatrix::isGloballyIndexed"); return mtx_->isGloballyIndexed(); }
                
                    //! Returns true if the matrix is in compute mode, i.e. if fillComplete() has been called.
           2 ->     bool isFillComplete() const { XPETRA_MONITOR("TpetraCrsMatrix::isFillComplete"); return mtx_->isFillComplete(); }
                
                    //! Returns true if the matrix is in edit mode.
       ##### ->     bool isFillActive() const { XPETRA_MONITOR("TpetraCrsMatrix::isFillActive"); return mtx_->isFillActive(); }
                
                    //! Returns the Frobenius norm of the matrix.
       ##### ->     typename ScalarTraits< Scalar >::magnitudeType getFrobeniusNorm() const { XPETRA_MONITOR("TpetraCrsMatrix::getFrobeniusNorm"); return mtx_->getFrobeniusNorm(); }
                
                    //! Returns true if getLocalRowView() and getGlobalRowView() are valid for this class.
       ##### ->     bool supportsRowViews() const { XPETRA_MONITOR("TpetraCrsMatrix::supportsRowViews"); return mtx_->supportsRowViews(); }
                
                    //! Extract a list of entries in a specified local row of the matrix. Put into storage allocated by calling routine.
       ##### ->     void getLocalRowCopy(LocalOrdinal LocalRow, const ArrayView< LocalOrdinal > &Indices, const ArrayView< Scalar > &Values, size_t &NumEntries) const { XPETRA_MONITOR("TpetraCrsMatrix::getLocalRowCopy"); mtx_->getLocalRowCopy(LocalRow, Indices, Values, NumEntries); }
                
                    //! Extract a const, non-persisting view of global indices in a specified row of the matrix.
       ##### ->     void getGlobalRowView(GlobalOrdinal GlobalRow, ArrayView< const GlobalOrdinal > &indices, ArrayView< const Scalar > &values) const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalRowView"); mtx_->getGlobalRowView(GlobalRow, indices, values); }
                
                    //! Extract a list of entries in a specified global row of this matrix. Put into pre-allocated storage.
       ##### ->     void getGlobalRowCopy(GlobalOrdinal GlobalRow, const ArrayView< GlobalOrdinal > &indices, const ArrayView< Scalar > &values, size_t &numEntries) const { XPETRA_MONITOR("TpetraCrsMatrix::getGlobalRowCopy"); mtx_->getGlobalRowCopy(GlobalRow, indices, values, numEntries); }
                
                    //! Extract a const, non-persisting view of local indices in a specified row of the matrix.
       ##### ->     void getLocalRowView(LocalOrdinal LocalRow, ArrayView< const LocalOrdinal > &indices, ArrayView< const Scalar > &values) const { XPETRA_MONITOR("TpetraCrsMatrix::getLocalRowView"); mtx_->getLocalRowView(LocalRow, indices, values); }
                
                    //@}
                
                    //! @name Methods implementing Operator
                    //@{
                
                    //! Computes the sparse matrix-multivector multiplication.
       ##### ->     void apply(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &X, MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, Scalar alpha=ScalarTraits< Scalar >::one(), Scalar beta=ScalarTraits< Scalar >::zero()) const { XPETRA_MONITOR("TpetraCrsMatrix::apply"); mtx_->apply(toTpetra(X), toTpetra(Y), mode, alpha, beta); }
                
                    //! Returns the Map associated with the domain of this operator. This will be null until fillComplete() is called.
          14 ->     const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getDomainMap() const { XPETRA_MONITOR("TpetraCrsMatrix::getDomainMap"); return toXpetra(mtx_->getDomainMap()); }
                
                    //!
           1 ->     const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRangeMap() const { XPETRA_MONITOR("TpetraCrsMatrix::getRangeMap"); return toXpetra(mtx_->getRangeMap()); }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
       ##### ->     std::string description() const { XPETRA_MONITOR("TpetraCrsMatrix::description"); return mtx_->description(); }
                
                    //! Print the object with some verbosity level to an FancyOStream object.
       ##### ->     void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { XPETRA_MONITOR("TpetraCrsMatrix::describe"); mtx_->describe(out, verbLevel); }
                
                    //@}
                
                    //! Deep copy constructor
                    TpetraCrsMatrix(const TpetraCrsMatrix& matrix)
                      : mtx_ (matrix.mtx_->template clone<Node> (matrix.mtx_->getNode ())) {}
                
                    //! Get a copy of the diagonal entries owned by this node, with local row idices.
       ##### ->     void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag) const {
                      XPETRA_MONITOR("TpetraCrsMatrix::getLocalDiagCopy");
                      XPETRA_DYNAMIC_CAST(TpetraVectorClass, diag, tDiag, "Xpetra::TpetraCrsMatrix.getLocalDiagCopy() only accept Xpetra::TpetraVector as input arguments.");
                      mtx_->getLocalDiagCopy(*tDiag.getTpetra_Vector());
                      // mtx_->getLocalDiagCopy(toTpetra(diag));
                    }
                
                    //! Get offsets of the diagonal entries in the matrix.
       ##### ->     void getLocalDiagOffsets(Teuchos::ArrayRCP<size_t> &offsets) const {
                      XPETRA_MONITOR("TpetraCrsMatrix::getLocalDiagOffsets");
                      mtx_->getLocalDiagOffsets(offsets);
                    }
                
                    //! Get a copy of the diagonal entries owned by this node, with local row indices.
       ##### ->     void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag, const Teuchos::ArrayView<const size_t> &offsets) const {
                      XPETRA_MONITOR("TpetraCrsMatrix::getLocalDiagCopy");
                      //XPETRA_DYNAMIC_CAST(TpetraVectorClass, diag, tDiag, "Xpetra::TpetraCrsMatrix.getLocalDiagCopy() only accept Xpetra::TpetraVector as input arguments.");
                      //mtx_->getLocalDiagCopy(*tDiag.getTpetra_Vector(), offsets);
                      mtx_->getLocalDiagCopy(*(toTpetra(diag)), offsets);
                    }
                
                    //! Left scale operator with given vector values
       ##### ->     void leftScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) {
                      XPETRA_MONITOR("TpetraCrsMatrix::leftScale");
                      mtx_->leftScale(*(toTpetra(x)));
                    }
                
                    //! Right scale operator with given vector values
       ##### ->     void rightScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) {
                      XPETRA_MONITOR("TpetraCrsMatrix::rightScale");
                      mtx_->rightScale(*(toTpetra(x)));
                    }
                
                    //! Implements DistObject interface
                    //{@
                
                    //! Access function for the Tpetra::Map this DistObject was constructed with.
       ##### ->     Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const { XPETRA_MONITOR("TpetraCrsMatrix::getMap"); return rcp( new TpetraMap< LocalOrdinal, GlobalOrdinal, Node >(mtx_->getMap()) ); }
                
                    //! Import.
       ##### ->     void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) {
                      XPETRA_MONITOR("TpetraCrsMatrix::doImport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, source, tSource, "Xpetra::TpetraCrsMatrix::doImport only accept Xpetra::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSource.getTpetra_CrsMatrix();
                      //mtx_->doImport(toTpetraCrsMatrix(source), *tImporter.getTpetra_Import(), toTpetra(CM));
                      mtx_->doImport(*v, toTpetra(importer), toTpetra(CM));
                    }
                
                    //! Export.
       ##### ->     void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) {
                      XPETRA_MONITOR("TpetraCrsMatrix::doExport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, dest, tDest, "Xpetra::TpetraCrsMatrix::doImport only accept Xpetra::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tDest.getTpetra_CrsMatrix();
                      mtx_->doExport(*v, toTpetra(importer), toTpetra(CM));
                
                    }
                
                    //! Import (using an Exporter).
       ##### ->     void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {
                      XPETRA_MONITOR("TpetraCrsMatrix::doImport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, source, tSource, "Xpetra::TpetraCrsMatrix::doImport only accept Xpetra::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tSource.getTpetra_CrsMatrix();
                      mtx_->doImport(*v, toTpetra(exporter), toTpetra(CM));
                
                    }
                
                    //! Export (using an Importer).
       ##### ->     void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {
                      XPETRA_MONITOR("TpetraCrsMatrix::doExport");
                
                      XPETRA_DYNAMIC_CAST(const TpetraCrsMatrixClass, dest, tDest, "Xpetra::TpetraCrsMatrix::doImport only accept Xpetra::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
                      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > v = tDest.getTpetra_CrsMatrix();
                      mtx_->doExport(*v, toTpetra(exporter), toTpetra(CM));
                
                    }
                
       ##### ->     void removeEmptyProcessesInPlace (const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> >& newMap) {
                      XPETRA_MONITOR("TpetraCrsMatrix::removeEmptyProcessesInPlace");
                      mtx_->removeEmptyProcessesInPlace(toTpetra(newMap));
                    }
                
                    // @}
                
                    template<class Node2>
                    RCP<CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> >
                    clone (const RCP<Node2> &node2) const
                    {
                      return RCP<CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> > (new TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> (mtx_->clone (node2)));
                    }
                
                    //! @name Xpetra specific
                    //@{
                
                    //! Does this have an underlying matrix
       ##### ->     bool hasMatrix() const {
                      return ! mtx_.is_null ();
                    }
                
                    //! TpetraCrsMatrix constructor to wrap a Tpetra::CrsMatrix object
                    TpetraCrsMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > &mtx) : mtx_(mtx) {  }
                
                    //! Get the underlying Tpetra matrix
                    RCP<const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrix() const { return mtx_; }
                
                    //! Get the underlying Tpetra matrix
                    RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrixNonConst() const { return mtx_; } //TODO: remove
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    /// \brief Access the local Kokkos::CrsMatrix data
                    local_matrix_type getLocalMatrix () const {
                      if(isFillComplete() == false)
                        throw std::runtime_error("Xpetra::EpetraCrsMatrix::getLocalMatrix: matrix must be filled and completed before you can access the data through the Kokkos interface!");
                
                      return getTpetra_CrsMatrixNonConst()->getLocalMatrix();
                    }
                #endif
                
                   //@}
                
                  private:
                    RCP< Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > mtx_;
                  }; // TpetraCrsMatrix class
                
                #ifdef HAVE_XPETRA_EPETRA
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                
                  // specialization of TpetraCrsMatrix for GO=LO=int
                  template<class Scalar>
                  class TpetraCrsMatrix<Scalar,int,int,EpetraNode>
                    : public CrsMatrix<Scalar,int,int,EpetraNode> //, public TpetraRowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>
                  {
                    typedef int LocalOrdinal;
                    typedef int GlobalOrdinal;
                    typedef EpetraNode Node;
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraCrsMatrixClass;
                    typedef TpetraVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraVectorClass;
                    typedef TpetraImport<LocalOrdinal,GlobalOrdinal,Node> TpetraImportClass;
                    typedef TpetraExport<LocalOrdinal,GlobalOrdinal,Node> TpetraExportClass;
                
                    // The following typedefs are used by the Kokkos interface
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>::local_matrix_type local_matrix_type;
                #endif
                
                  public:
                
                    //! @name Constructor/Destructor Methods
                    //@{
                
                    //! Constructor specifying fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying (possibly different) number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying column Map and fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying column Map and number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying a previously constructed graph.
                    TpetraCrsMatrix(const Teuchos::RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > &graph, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & importer,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & exporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & RowImporter,
                                    const Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > DomainImporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & RowExporter,
                                    const Teuchos::RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > DomainExporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    /// \brief Constructor specifying column Map and a local matrix,
                    ///   which the resulting CrsMatrix views.
                    ///
                    /// Unlike most other CrsMatrix constructors, successful
                    /// completion of this constructor will result in a fill-complete
                    /// matrix.
                    ///
                    /// \param rowMap [in] Distribution of rows of the matrix.
                    ///
                    /// \param colMap [in] Distribution of columns of the matrix.
                    ///
                    /// \param lclMatrix [in] A local CrsMatrix containing all local
                    ///    matrix values as well as a local graph.  The graph's local
                    ///    row indices must come from the specified row Map, and its
                    ///    local column indices must come from the specified column
                    ///    Map.
                    ///
                    /// \param params [in/out] Optional list of parameters.  If not
                    ///   null, any missing parameters will be filled in with their
                    ///   default values.
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    TpetraCrsMatrix (const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rowMap,
                        const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& colMap,
                        const local_matrix_type& lclMatrix,
                        const Teuchos::RCP<Teuchos::ParameterList>& params = null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , "TpetraCrsMatrix<int,int>", "int", typeid(EpetraNode).name() );
                    }
                #endif
                
                    //! Destructor.
                    virtual ~TpetraCrsMatrix() {  }
                
                    //@}
                
                    //! @name Insertion/Removal Methods
                    //@{
                
                    //! Insert matrix entries, using global IDs.
                    void insertGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Insert matrix entries, using local IDs.
                    void insertLocalValues(LocalOrdinal localRow, const ArrayView< const LocalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Replace matrix entries, using global IDs.
                    void replaceGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Replace matrix entries, using local IDs.
                    void
                    replaceLocalValues (LocalOrdinal localRow,
                                        const ArrayView<const LocalOrdinal> &cols,
                                        const ArrayView<const Scalar> &vals)
                    {  }
                
                    //! Set all matrix entries equal to scalarThis.
                    void setAllToScalar(const Scalar &alpha) {  }
                
                    //! Scale the current values of a matrix, this = alpha*this.
                    void scale(const Scalar &alpha) {  }
                
                    //! Allocates and returns ArrayRCPs of the Crs arrays --- This is an Xpetra-only routine.
                    //** \warning This is an expert-only routine and should not be called from user code. */
                    void allocateAllValues(size_t numNonZeros,ArrayRCP<size_t> & rowptr, ArrayRCP<LocalOrdinal> & colind, ArrayRCP<Scalar> & values) {  }
                
                    //! Sets the 1D pointer arrays of the graph.
                    void setAllValues(const ArrayRCP<size_t> & rowptr, const ArrayRCP<LocalOrdinal> & colind, const ArrayRCP<Scalar> & values) {  }
                
                    //! Gets the 1D pointer arrays of the graph.
                    void getAllValues(ArrayRCP<const size_t>& rowptr, ArrayRCP<const LocalOrdinal>& colind, ArrayRCP<const Scalar>& values) const {  }
                
                    //@}
                
                    //! @name Transformational Methods
                    //@{
                
                    //!
                    void resumeFill(const RCP< ParameterList > &params=null) {  }
                
                    //! Signal that data entry is complete, specifying domain and range maps.
                    void fillComplete(const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &domainMap, const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rangeMap, const RCP< ParameterList > &params=null) {  }
                
                    //! Signal that data entry is complete.
                    void fillComplete(const RCP< ParameterList > &params=null) {  }
                
                
                    //!  Replaces the current domainMap and importer with the user-specified objects.
                    void replaceDomainMapAndImporter(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >& newDomainMap, Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> >  & newImporter) { }
                
                    //! Expert static fill complete
                    void expertStaticFillComplete(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & domainMap,
                                                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & rangeMap,
                                                  const RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > &importer=Teuchos::null,
                                                  const RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > &exporter=Teuchos::null,
                                                  const RCP<ParameterList> &params=Teuchos::null) {  }
                
                    //@}
                
                    //! @name Methods implementing RowMatrix
                    //@{
                
                    //! Returns the Map that describes the row distribution in this matrix.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRowMap() const { return Teuchos::null; }
                
                    //! Returns the Map that describes the column distribution in this matrix.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getColMap() const { return Teuchos::null; }
                
                    //! Returns the CrsGraph associated with this matrix.
                    RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > getCrsGraph() const { return Teuchos::null; }
                
                    //! Number of global elements in the row map of this matrix.
                    global_size_t getGlobalNumRows() const { return 0; }
                
                    //! Number of global columns in the matrix.
                    global_size_t getGlobalNumCols() const { return 0; }
                
                    //! Returns the number of matrix rows owned on the calling node.
                    size_t getNodeNumRows() const { return 0; }
                
                    //! Returns the number of columns connected to the locally owned rows of this matrix.
                    size_t getNodeNumCols() const { return 0; }
                
                    //! Returns the global number of entries in this matrix.
                    global_size_t getGlobalNumEntries() const { return 0; }
                
                    //! Returns the local number of entries in this matrix.
                    size_t getNodeNumEntries() const { return 0; }
                
                    //! Returns the current number of entries on this node in the specified local row.
                    size_t getNumEntriesInLocalRow(LocalOrdinal localRow) const { return 0; }
                
                    //! Returns the number of global diagonal entries, based on global row/column index comparisons.
                    global_size_t getGlobalNumDiags() const { return 0; }
                
                    //! Returns the number of local diagonal entries, based on global row/column index comparisons.
                    size_t getNodeNumDiags() const { return 0; }
                
                    //! Returns the maximum number of entries across all rows/columns on all nodes.
                    size_t getGlobalMaxNumRowEntries() const { return 0; }
                
                    //! Returns the maximum number of entries across all rows/columns on this node.
                    size_t getNodeMaxNumRowEntries() const { return 0; }
                
                    //! If matrix indices are in the local range, this function returns true. Otherwise, this function returns false.
                    bool isLocallyIndexed() const { return false; }
                
                    //! If matrix indices are in the global range, this function returns true. Otherwise, this function returns false.
                    bool isGloballyIndexed() const { return false; }
                
                    //! Returns true if the matrix is in compute mode, i.e. if fillComplete() has been called.
                    bool isFillComplete() const { return false; }
                
                    //! Returns true if the matrix is in edit mode.
                    bool isFillActive() const { return false; }
                
                    //! Returns the Frobenius norm of the matrix.
                    typename ScalarTraits< Scalar >::magnitudeType getFrobeniusNorm() const { return ScalarTraits< Scalar >::magnitude(ScalarTraits< Scalar >::zero()); }
                
                    //! Returns true if getLocalRowView() and getGlobalRowView() are valid for this class.
                    bool supportsRowViews() const { return false; }
                
                    //! Extract a list of entries in a specified local row of the matrix. Put into storage allocated by calling routine.
                    void getLocalRowCopy(LocalOrdinal LocalRow, const ArrayView< LocalOrdinal > &Indices, const ArrayView< Scalar > &Values, size_t &NumEntries) const {  }
                
                    //! Extract a const, non-persisting view of global indices in a specified row of the matrix.
                    void getGlobalRowView(GlobalOrdinal GlobalRow, ArrayView< const GlobalOrdinal > &indices, ArrayView< const Scalar > &values) const {  }
                
                    //! Extract a list of entries in a specified global row of this matrix. Put into pre-allocated storage.
                    void getGlobalRowCopy(GlobalOrdinal GlobalRow, const ArrayView< GlobalOrdinal > &indices, const ArrayView< Scalar > &values, size_t &numEntries) const {  }
                
                    //! Extract a const, non-persisting view of local indices in a specified row of the matrix.
                    void getLocalRowView(LocalOrdinal LocalRow, ArrayView< const LocalOrdinal > &indices, ArrayView< const Scalar > &values) const {  }
                
                    //@}
                
                    //! @name Methods implementing Operator
                    //@{
                
                    //! Computes the sparse matrix-multivector multiplication.
                    void apply(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &X, MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, Scalar alpha=ScalarTraits< Scalar >::one(), Scalar beta=ScalarTraits< Scalar >::zero()) const {  }
                
                    //! Returns the Map associated with the domain of this operator. This will be null until fillComplete() is called.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getDomainMap() const { return Teuchos::null; }
                
                    //!
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRangeMap() const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print the object with some verbosity level to an FancyOStream object.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    //@}
                
                    //! Deep copy constructor
                    TpetraCrsMatrix(const TpetraCrsMatrix& matrix) {}
                
                    //! Get a copy of the diagonal entries owned by this node, with local row idices.
                    void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag) const {  }
                
                    //! Get offsets of the diagonal entries in the matrix.
                    void getLocalDiagOffsets(Teuchos::ArrayRCP<size_t> &offsets) const {  }
                
                    //! Get a copy of the diagonal entries owned by this node, with local row indices.
                    void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag, const Teuchos::ArrayView<const size_t> &offsets) const {  }
                
                    //! Left scale operator with given vector values
                    void leftScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) { }
                
                    //! Right scale operator with given vector values
                    void rightScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) { }
                
                    //! Implements DistObject interface
                    //{@
                
                    //! Access function for the Tpetra::Map this DistObject was constructed with.
                    Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const { return Teuchos::null; }
                
                    //! Import.
                    void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) {  }
                
                    //! Export.
                    void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) {  }
                
                    //! Import (using an Exporter).
                    void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {  }
                
                    //! Export (using an Importer).
                    void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {  }
                
                    void removeEmptyProcessesInPlace (const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> >& newMap) {   }
                
                    // @}
                
                    template<class Node2>
                    RCP<CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> >
                    clone (const RCP<Node2> &node2) const {  return Teuchos::null;  }
                
                    //! @name Xpetra specific
                    //@{
                
                    //! Does this have an underlying matrix
                    bool hasMatrix() const { return false; }
                
                    //! TpetraCrsMatrix constructor to wrap a Tpetra::CrsMatrix object
                    TpetraCrsMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > &mtx) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,int,int,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Get the underlying Tpetra matrix
                    RCP<const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrix() const { return Teuchos::null; }
                
                    //! Get the underlying Tpetra matrix
                    RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrixNonConst() const { return Teuchos::null; } //TODO: remove
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    /// \brief Access the local Kokkos::CrsMatrix data
                    local_matrix_type getLocalMatrix () const {
                      if(isFillComplete() == false)
                        throw std::runtime_error("Xpetra::EpetraCrsMatrix::getLocalMatrix: matrix must be filled and completed before you can access the data through the Kokkos interface!");
                      local_matrix_type ret;
                      return ret;
                    }
                #endif
                
                   //@}
                  }; // TpetraCrsMatrix class (specialization for GO=int, NO=EpetraNode)
                #endif
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))))
                
                  // specialization of TpetraCrsMatrix for GO=long long, NO=EpetraNode
                  template<class Scalar>
                  class TpetraCrsMatrix<Scalar,int,long long,EpetraNode>
                    : public CrsMatrix<Scalar,int,long long,EpetraNode> //, public TpetraRowMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node>
                  {
                    typedef int LocalOrdinal;
                    typedef long long GlobalOrdinal;
                    typedef EpetraNode Node;
                    // The following typedef are used by the XPETRA_DYNAMIC_CAST() macro.
                    typedef TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraCrsMatrixClass;
                    typedef TpetraVector<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraVectorClass;
                    typedef TpetraImport<LocalOrdinal,GlobalOrdinal,Node> TpetraImportClass;
                    typedef TpetraExport<LocalOrdinal,GlobalOrdinal,Node> TpetraExportClass;
                
                    // The following typedefs are used by the Kokkos interface
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    typedef typename Xpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node>::local_matrix_type local_matrix_type;
                #endif
                
                  public:
                
                    //! @name Constructor/Destructor Methods
                    //@{
                
                    //! Constructor specifying fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying (possibly different) number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying column Map and fixed number of entries for each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, size_t maxNumEntriesPerRow, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying column Map and number of entries in each row.
                    TpetraCrsMatrix(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rowMap, const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &colMap, const ArrayRCP< const size_t > &NumEntriesPerRowToAlloc, ProfileType pftype=DynamicProfile, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor specifying a previously constructed graph.
                    TpetraCrsMatrix(const Teuchos::RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > &graph, const Teuchos::RCP< Teuchos::ParameterList > &params=Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & importer,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & exporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap = Teuchos::null,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap = Teuchos::null,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params = Teuchos::null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused import
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Import<LocalOrdinal,GlobalOrdinal,Node> & RowImporter,
                                    const Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > DomainImporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor for a fused export
                    TpetraCrsMatrix(const Teuchos::RCP<const CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> >& sourceMatrix,
                                    const Export<LocalOrdinal,GlobalOrdinal,Node> & RowExporter,
                                    const Teuchos::RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > DomainExporter,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& domainMap,
                                    const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rangeMap,
                                    const Teuchos::RCP<Teuchos::ParameterList>& params)
                    {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    /// \brief Constructor specifying column Map and a local matrix,
                    ///   which the resulting CrsMatrix views.
                    ///
                    /// Unlike most other CrsMatrix constructors, successful
                    /// completion of this constructor will result in a fill-complete
                    /// matrix.
                    ///
                    /// \param rowMap [in] Distribution of rows of the matrix.
                    ///
                    /// \param colMap [in] Distribution of columns of the matrix.
                    ///
                    /// \param lclMatrix [in] A local CrsMatrix containing all local
                    ///    matrix values as well as a local graph.  The graph's local
                    ///    row indices must come from the specified row Map, and its
                    ///    local column indices must come from the specified column
                    ///    Map.
                    ///
                    /// \param params [in/out] Optional list of parameters.  If not
                    ///   null, any missing parameters will be filled in with their
                    ///   default values.
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    TpetraCrsMatrix (const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& rowMap,
                        const Teuchos::RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >& colMap,
                        const local_matrix_type& lclMatrix,
                        const Teuchos::RCP<Teuchos::ParameterList>& params = null) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                #endif
                
                    //! Destructor.
                    virtual ~TpetraCrsMatrix() {  }
                
                    //@}
                
                    //! @name Insertion/Removal Methods
                    //@{
                
                    //! Insert matrix entries, using global IDs.
                    void insertGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Insert matrix entries, using local IDs.
                    void insertLocalValues(LocalOrdinal localRow, const ArrayView< const LocalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Replace matrix entries, using global IDs.
                    void replaceGlobalValues(GlobalOrdinal globalRow, const ArrayView< const GlobalOrdinal > &cols, const ArrayView< const Scalar > &vals) {  }
                
                    //! Replace matrix entries, using local IDs.
                    void
                    replaceLocalValues (LocalOrdinal localRow,
                                        const ArrayView<const LocalOrdinal> &cols,
                                        const ArrayView<const Scalar> &vals)
                    {  }
                
                    //! Set all matrix entries equal to scalarThis.
                    void setAllToScalar(const Scalar &alpha) {  }
                
                    //! Scale the current values of a matrix, this = alpha*this.
                    void scale(const Scalar &alpha) {  }
                
                    //! Allocates and returns ArrayRCPs of the Crs arrays --- This is an Xpetra-only routine.
                    //** \warning This is an expert-only routine and should not be called from user code. */
                    void allocateAllValues(size_t numNonZeros,ArrayRCP<size_t> & rowptr, ArrayRCP<LocalOrdinal> & colind, ArrayRCP<Scalar> & values) {  }
                
                    //! Sets the 1D pointer arrays of the graph.
                    void setAllValues(const ArrayRCP<size_t> & rowptr, const ArrayRCP<LocalOrdinal> & colind, const ArrayRCP<Scalar> & values) {  }
                
                    //! Gets the 1D pointer arrays of the graph.
                    void getAllValues(ArrayRCP<const size_t>& rowptr, ArrayRCP<const LocalOrdinal>& colind, ArrayRCP<const Scalar>& values) const {  }
                
                    //@}
                
                    //! @name Transformational Methods
                    //@{
                
                    //!
                    void resumeFill(const RCP< ParameterList > &params=null) {  }
                
                    //! Signal that data entry is complete, specifying domain and range maps.
                    void fillComplete(const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &domainMap, const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &rangeMap, const RCP< ParameterList > &params=null) {  }
                
                    //! Signal that data entry is complete.
                    void fillComplete(const RCP< ParameterList > &params=null) {  }
                
                
                    //!  Replaces the current domainMap and importer with the user-specified objects.
                    void replaceDomainMapAndImporter(const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >& newDomainMap, Teuchos::RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> >  & newImporter) { }
                
                    //! Expert static fill complete
                    void expertStaticFillComplete(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & domainMap,
                                                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > & rangeMap,
                                                  const RCP<const Import<LocalOrdinal,GlobalOrdinal,Node> > &importer=Teuchos::null,
                                                  const RCP<const Export<LocalOrdinal,GlobalOrdinal,Node> > &exporter=Teuchos::null,
                                                  const RCP<ParameterList> &params=Teuchos::null) {  }
                
                    //@}
                
                    //! @name Methods implementing RowMatrix
                    //@{
                
                    //! Returns the Map that describes the row distribution in this matrix.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRowMap() const { return Teuchos::null; }
                
                    //! Returns the Map that describes the column distribution in this matrix.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getColMap() const { return Teuchos::null; }
                
                    //! Returns the CrsGraph associated with this matrix.
                    RCP< const CrsGraph< LocalOrdinal, GlobalOrdinal, Node > > getCrsGraph() const { return Teuchos::null; }
                
                    //! Number of global elements in the row map of this matrix.
                    global_size_t getGlobalNumRows() const { return 0; }
                
                    //! Number of global columns in the matrix.
                    global_size_t getGlobalNumCols() const { return 0; }
                
                    //! Returns the number of matrix rows owned on the calling node.
                    size_t getNodeNumRows() const { return 0; }
                
                    //! Returns the number of columns connected to the locally owned rows of this matrix.
                    size_t getNodeNumCols() const { return 0; }
                
                    //! Returns the global number of entries in this matrix.
                    global_size_t getGlobalNumEntries() const { return 0; }
                
                    //! Returns the local number of entries in this matrix.
                    size_t getNodeNumEntries() const { return 0; }
                
                    //! Returns the current number of entries on this node in the specified local row.
                    size_t getNumEntriesInLocalRow(LocalOrdinal localRow) const { return 0; }
                
                    //! Returns the number of global diagonal entries, based on global row/column index comparisons.
                    global_size_t getGlobalNumDiags() const { return 0; }
                
                    //! Returns the number of local diagonal entries, based on global row/column index comparisons.
                    size_t getNodeNumDiags() const { return 0; }
                
                    //! Returns the maximum number of entries across all rows/columns on all nodes.
                    size_t getGlobalMaxNumRowEntries() const { return 0; }
                
                    //! Returns the maximum number of entries across all rows/columns on this node.
                    size_t getNodeMaxNumRowEntries() const { return 0; }
                
                    //! If matrix indices are in the local range, this function returns true. Otherwise, this function returns false.
                    bool isLocallyIndexed() const { return false; }
                
                    //! If matrix indices are in the global range, this function returns true. Otherwise, this function returns false.
                    bool isGloballyIndexed() const { return false; }
                
                    //! Returns true if the matrix is in compute mode, i.e. if fillComplete() has been called.
                    bool isFillComplete() const { return false; }
                
                    //! Returns true if the matrix is in edit mode.
                    bool isFillActive() const { return false; }
                
                    //! Returns the Frobenius norm of the matrix.
                    typename ScalarTraits< Scalar >::magnitudeType getFrobeniusNorm() const { return ScalarTraits< Scalar >::magnitude(ScalarTraits< Scalar >::zero()); }
                
                    //! Returns true if getLocalRowView() and getGlobalRowView() are valid for this class.
                    bool supportsRowViews() const { return false; }
                
                    //! Extract a list of entries in a specified local row of the matrix. Put into storage allocated by calling routine.
                    void getLocalRowCopy(LocalOrdinal LocalRow, const ArrayView< LocalOrdinal > &Indices, const ArrayView< Scalar > &Values, size_t &NumEntries) const {  }
                
                    //! Extract a const, non-persisting view of global indices in a specified row of the matrix.
                    void getGlobalRowView(GlobalOrdinal GlobalRow, ArrayView< const GlobalOrdinal > &indices, ArrayView< const Scalar > &values) const {  }
                
                    //! Extract a list of entries in a specified global row of this matrix. Put into pre-allocated storage.
                    void getGlobalRowCopy(GlobalOrdinal GlobalRow, const ArrayView< GlobalOrdinal > &indices, const ArrayView< Scalar > &values, size_t &numEntries) const {  }
                
                    //! Extract a const, non-persisting view of local indices in a specified row of the matrix.
                    void getLocalRowView(LocalOrdinal LocalRow, ArrayView< const LocalOrdinal > &indices, ArrayView< const Scalar > &values) const {  }
                
                    //@}
                
                    //! @name Methods implementing Operator
                    //@{
                
                    //! Computes the sparse matrix-multivector multiplication.
                    void apply(const MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &X, MultiVector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, Scalar alpha=ScalarTraits< Scalar >::one(), Scalar beta=ScalarTraits< Scalar >::zero()) const {  }
                
                    //! Returns the Map associated with the domain of this operator. This will be null until fillComplete() is called.
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getDomainMap() const { return Teuchos::null; }
                
                    //!
                    const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > >  getRangeMap() const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Overridden from Teuchos::Describable
                    //@{
                
                    //! A simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print the object with some verbosity level to an FancyOStream object.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    //@}
                
                    //! Deep copy constructor
                    TpetraCrsMatrix(const TpetraCrsMatrix& matrix) {}
                
                    //! Get a copy of the diagonal entries owned by this node, with local row idices.
                    void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag) const {  }
                
                    //! Get offsets of the diagonal entries in the matrix.
                    void getLocalDiagOffsets(Teuchos::ArrayRCP<size_t> &offsets) const {  }
                
                    //! Get a copy of the diagonal entries owned by this node, with local row indices.
                    void getLocalDiagCopy(Vector< Scalar, LocalOrdinal, GlobalOrdinal, Node > &diag, const Teuchos::ArrayView<const size_t> &offsets) const {  }
                
                    //! Left scale operator with given vector values
                    void leftScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) { }
                
                    //! Right scale operator with given vector values
                    void rightScale (const Vector<Scalar, LocalOrdinal, GlobalOrdinal, Node>& x) { }
                
                    //! Implements DistObject interface
                    //{@
                
                    //! Access function for the Tpetra::Map this DistObject was constructed with.
                    Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const { return Teuchos::null; }
                
                    //! Import.
                    void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) {  }
                
                    //! Export.
                    void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) {  }
                
                    //! Import (using an Exporter).
                    void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {  }
                
                    //! Export (using an Importer).
                    void doExport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &dest,
                                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {  }
                
                    void removeEmptyProcessesInPlace (const Teuchos::RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> >& newMap) {   }
                
                    // @}
                
                    template<class Node2>
                    RCP<CrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node2> >
                    clone (const RCP<Node2> &node2) const {  return Teuchos::null;  }
                
                    //! @name Xpetra specific
                    //@{
                
                    //! Does this have an underlying matrix
                    bool hasMatrix() const { return false; }
                
                    //! TpetraCrsMatrix constructor to wrap a Tpetra::CrsMatrix object
                    TpetraCrsMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > &mtx) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Get the underlying Tpetra matrix
                    RCP<const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrix() const { return Teuchos::null; }
                
                    //! Get the underlying Tpetra matrix
                    RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node> > getTpetra_CrsMatrixNonConst() const { return Teuchos::null; } //TODO: remove
                
                #ifdef HAVE_XPETRA_KOKKOS_REFACTOR
                    /// \brief Access the local Kokkos::CrsMatrix data
                    local_matrix_type getLocalMatrix () const {
                      if(isFillComplete() == false)
                        throw std::runtime_error("Xpetra::EpetraCrsMatrix::getLocalMatrix: matrix must be filled and completed before you can access the data through the Kokkos interface!");
                      local_matrix_type ret;
                      return ret;
                    }
                #endif
                
                   //@}
                  }; // TpetraCrsMatrix class (specialization for GO=long long, NO=EpetraNode)
                #endif
                
                #endif // HAVE_XPETRA_EPETRA
                
                } // Xpetra namespace
                
                #define XPETRA_TPETRACRSMATRIX_SHORT
                #endif // XPETRA_TPETRACRSMATRIX_HPP


Top 10 Lines:

     Line      Count

      411         14
      352          6
      379          2
      331          1
      334          1
      414          1

Execution Summary:

       56   Executable lines in this file
       56   Lines executed
   100.00   Percent of the file executed

       25   Total number of line executions
     0.45   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosStatusTestGenResNorm.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_STATUS_TEST_GEN_RESNORM_H
                #define BELOS_STATUS_TEST_GEN_RESNORM_H
                
                /*!
                  \file BelosStatusTestGenResNorm.hpp
                  \brief Belos::StatusTestResNorm for specifying general residual norm stopping criteria.
                */
                
                #include "BelosStatusTestResNorm.hpp"
                #include "BelosLinearProblem.hpp"
                #include "BelosMultiVecTraits.hpp"
                
                /*!
                  \class Belos::StatusTestGenResNorm
                  \brief An implementation of StatusTestResNorm using a family of residual norms.
                
                  StatusTestGenResNorm is an implementation of StatusTestResNorm that allows a user to construct
                  one of a family of residual tests for use as a status/convergence test for Belos.
                  The form of the test is
                   \f[
                   \frac{\|r_i\|}{\sigma_i} \le \tau
                   \f]
                   where
                   <ul>
                   <li> \f$r_i\f$ is the i-th residual std::vector, implicitly or explicitly computed (determined by enum ResType),
                   <li> \f$\|r_i\|\f$ is the i-th residual norm determined by the enum NormType  (1-norm, 2-norm or inf-norm),
                   <li> \f$\sigma_i\f$ is the i-th scale factor that can be passed in as a precomputed number of the templated type,
                   or can be selected from by the enum ScaleType (norm of RHS, norm of initial residual).
                   <li> \f$\tau\f$ is the tolerance that is passed in as a number of the templated type to the constructor.
                   The value of \f$\tau\f$ can be reset using the setTolerance() method.
                   </ul>
                
                */
                
                namespace Belos {
                
                template <class ScalarType, class MV, class OP>
                class StatusTestGenResNorm: public StatusTestResNorm<ScalarType,MV,OP> {
                
                 public:
                
                  // Convenience typedefs
                  typedef Teuchos::ScalarTraits<ScalarType> SCT;
                  typedef typename SCT::magnitudeType MagnitudeType;
                  typedef MultiVecTraits<ScalarType,MV>  MVT;
                
                  //! @name Enums.
                  //@{
                
                  /*!
                    \brief Select how the residual std::vector is produced.
                  */
                  enum ResType {Implicit, /*!< Use the residual std::vector produced by the iterative solver. */
                                Explicit  /*!< Explicitly compute the residual std::vector r = b - A*x using the
                                            linear problem. */
                  };
                
                  //@}
                
                  //! @name Constructors/destructors.
                  //@{
                  //! Constructor
                  /*! The constructor takes a single argument specifying the tolerance (\f$\tau\f$).
                    If none of the form definition methods are called, we use \f$\|r\|_2/\|r^{(0)}\|_2 \le \tau\f$
                    as the stopping criterion, where \f$\|r\|_2\f$ uses the least costly form of the 2-norm of
                    residual available from the iterative method and \f$\|r^{(0)}\|_2\f$ is the corresponding norm
                    of the initial residual.  The least costly form of the 2-norm depends on the chosen iterative
                    method.  Most Krylov methods produce the preconditioned residual std::vector in a form that would be
                    exact in infinite precision arithmetic.  This std::vector may be different from the true residual
                    either because left scaling or preconditioning was used, or because round-off error has
                    introduced significant error, or both.
                
                    You can also state the number of vectors that must pass the convergence criteria before the
                    status test passes by using the \c quorum argument.
                  */
                  StatusTestGenResNorm( MagnitudeType Tolerance, int quorum = -1, bool showMaxResNormOnly = false );
                
                  //! Destructor
                  virtual ~StatusTestGenResNorm();
                  //@}
                
                  //! @name Form and parameter definition methods.
                  //@{
                
                  //! Define form of the residual, its norm and optional weighting std::vector.
                  /*! This method defines the form of \f$\|r\|\f$.  We specify:
                    <ul>
                    <li> Whether the residual std::vector should be explicitly computed, or taken from the iterative method.
                    <li> The norm to be used on the residual (this may be different than the norm used in
                    DefineScaleForm()).
                    </ul>
                  */
                  int defineResForm( ResType TypeOfResidual, NormType TypeOfNorm);
                
                  //! Define form of the scaling, its norm, its optional weighting std::vector, or, alternatively, define an explicit value.
                  /*! This method defines the form of how the residual is scaled (if at all).  It operates in two modes:
                    <ol>
                    <li> User-provided scaling value:
                    <ul>
                    <li> Set argument TypeOfScaling to UserProvided.
                    <li> Set ScaleValue to a non-zero value that the residual norm will be divided by.
                    <li> TypeOfNorm argument will be ignored.
                    <li> Sample use:  Define ScaleValue = \f$\|A\|_{\infty}\f$ where \f$ A \f$ is the matrix
                    of the linear problem.
                    </ul>
                
                    <li> Use a supported Scaling Form:
                    <ul>
                    <li> Define TypeOfScaling to be the norm of the right hand side, the initial residual std::vector,
                    or to none.
                    <li> Define norm to be used on the scaling std::vector (this may be different than the norm used
                    in DefineResForm()).
                    </ul>
                    </ol>
                  */
                  int defineScaleForm( ScaleType TypeOfScaling, NormType TypeOfNorm, MagnitudeType ScaleValue = Teuchos::ScalarTraits<MagnitudeType>::one());
                
                  //! Set the value of the tolerance
                  /*! We allow the tolerance to be reset for cases where, in the process of testing the residual,
                    we find that the initial tolerance was too tight or too lax.
                  */
       ##### ->   int setTolerance(MagnitudeType tolerance) {tolerance_ = tolerance; return(0);}
                
                  //! Sets the number of residuals that must pass the convergence test before Passed is returned.
                  //! \note If \c quorum=-1 then all residuals must pass the convergence test before Passed is returned.
       ##### ->   int setQuorum(int quorum) {quorum_ = quorum; return(0);}
                
                  //! Set whether the only maximum residual norm is displayed when the print() method is called
       ##### ->   int setShowMaxResNormOnly(bool showMaxResNormOnly) {showMaxResNormOnly_ = showMaxResNormOnly; return(0);}
                
                  //@}
                
                  //! @name Status methods
                  //@{
                  //! Check convergence status: Passed, Failed, or Undefined.
                  /*! This method checks to see if the convergence criteria are met.
                    Depending on how the residual test is constructed this method will return
                    the appropriate status type.
                
                    \return StatusType: Passed, Failed, or Undefined.
                  */
                  StatusType checkStatus(Iteration<ScalarType,MV,OP>* iSolver);
                
                  //! Return the result of the most recent CheckStatus call.
       ##### ->   StatusType getStatus() const {return(status_);};
                  //@}
                
                  //! @name Reset methods
                  //@{
                
                  //! Resets the internal configuration to the initial state.
                  void reset();
                
                  //@}
                
                  //! @name Print methods
                  //@{
                
                  //! Output formatted description of stopping test to output stream.
                  void print(std::ostream& os, int indent = 0) const;
                
                  //! Print message for each status specific to this stopping test.
                  void printStatus(std::ostream& os, StatusType type) const;
                  //@}
                
                  //! @name Methods to access data members.
                  //@{
                
                  //! Returns the current solution estimate that was computed for the most recent residual test.
                  //! \note This is useful for explicit residual tests, if this test is an implicit residual test
                  //! a null pointer will be returned.
       ##### ->   Teuchos::RCP<MV> getSolution() { if (restype_==Implicit) { return Teuchos::null; } else { return curSoln_; } }
                
                  //! Returns the number of residuals that must pass the convergence test before Passed is returned.
                  //! \note If \c quorum=-1 then all residuals must pass the convergence test before Passed is returned.
       ##### ->   int getQuorum() const { return quorum_; }
                
                  //! Returns whether the only maximum residual norm is displayed when the print() method is called
       ##### ->   bool getShowMaxResNormOnly() { return showMaxResNormOnly_; }
                
                  //! Returns the std::vector containing the indices of the residuals that passed the test.
       ##### ->   std::vector<int> convIndices() { return ind_; }
                
                  //! Returns the value of the tolerance, \f$ \tau \f$, set in the constructor.
       ##### ->   MagnitudeType getTolerance() const {return(tolerance_);};
                
                  //! Returns the test value, \f$ \frac{\|r\|}{\sigma} \f$, computed in most recent call to CheckStatus.
       ##### ->   const std::vector<MagnitudeType>* getTestValue() const {return(&testvector_);};
                
                  //! Returns the residual norm value, \f$ \|r\| \f$, computed in most recent call to CheckStatus.
                  const std::vector<MagnitudeType>* getResNormValue() const {return(&resvector_);};
                
                  //! Returns the scaled norm value, \f$ \sigma \f$.
                  const std::vector<MagnitudeType>* getScaledNormValue() const {return(&scalevector_);};
                
                  //! Returns a boolean indicating a loss of accuracy has been detected in computing the residual.
                  //! \note This status test does not check for loss of accuracy, so this method will always return false.
       ##### ->   bool getLOADetected() const { return false; }
                
                  //@}
                
                
                  /** @name Misc. */
                  //@{
                
                  /** \brief Call to setup initial scaling std::vector.
                   *
                   * After this function is called <tt>getScaledNormValue()</tt> can be called
                   * to get the scaling std::vector.
                   */
                  StatusType firstCallCheckStatusSetup(Iteration<ScalarType,MV,OP>* iSolver);
                  //@}
                
                  /** \name Overridden from Teuchos::Describable */
                  //@{
                
                  /** \brief Method to return description of the maximum iteration status test  */
       ##### ->   std::string description() const
                  {
                    std::ostringstream oss;
                    oss << "Belos::StatusTestGenResNorm<>: " << resFormStr();
                    oss << ", tol = " << tolerance_;
                    return oss.str();
                  }
                  //@}
                
                 protected:
                
                 private:
                
                  //! @name Private methods.
                  //@{
                  /** \brief Description of current residual form */
           1 ->   std::string resFormStr() const
                  {
                    std::ostringstream oss;
                    oss << "(";
                    oss << ((resnormtype_==OneNorm) ? "1-Norm" : (resnormtype_==TwoNorm) ? "2-Norm" : "Inf-Norm");
                    oss << ((restype_==Explicit) ? " Exp" : " Imp");
                    oss << " Res Vec) ";
                
                    // If there is no residual scaling, return current string.
                    if (scaletype_!=None)
                    {
                      // Insert division sign.
                      oss << "/ ";
                
                      // Determine output string for scaling, if there is any.
                      if (scaletype_==UserProvided)
                        oss << " (User Scale)";
                      else {
                        oss << "(";
                        oss << ((scalenormtype_==OneNorm) ? "1-Norm" : (resnormtype_==TwoNorm) ? "2-Norm" : "Inf-Norm");
                        if (scaletype_==NormOfInitRes || scaletype_==NormOfFullInitRes || scaletype_==NormOfFullScaledInitRes)
                          oss << " Res0";
                        else if (scaletype_==NormOfPrecInitRes || scaletype_==NormOfFullPrecInitRes || scaletype_==NormOfFullScaledPrecInitRes)
                          oss << " Prec Res0";
                        else
                          oss << " RHS ";
                        oss << ")";
                      }
                    }
                
                    return oss.str();
                  }
                
                  //@}
                
                  //! @name Private data members.
                  //@{
                
                  //! Tolerance used to determine convergence
                  MagnitudeType tolerance_;
                
                  //! Number of residuals that must pass the convergence test before Passed is returned.
                  int quorum_;
                
                  //! Determines if the entries for all of the residuals are shown or just the max.
                  bool showMaxResNormOnly_;
                
                  //! Type of residual to use (explicit or implicit)
                  ResType restype_;
                
                  //! Type of norm to use on residual (OneNorm, TwoNorm, or InfNorm).
                  NormType resnormtype_;
                
                  //! Type of scaling to use (Norm of RHS, Norm of Initial Residual, None or User provided)
                  ScaleType scaletype_;
                
                  //! Type of norm to use on the scaling (OneNorm, TwoNorm, or InfNorm)
                  NormType scalenormtype_;
                
                  //! Scaling value.
                  MagnitudeType scalevalue_;
                
                  //! Scaling std::vector.
                  std::vector<MagnitudeType> scalevector_;
                
                  //! Residual norm std::vector.
                  std::vector<MagnitudeType> resvector_;
                
                  //! Test std::vector = resvector_ / scalevector_
                  std::vector<MagnitudeType> testvector_;
                
                  //! Vector containing the indices for the vectors that passed the test.
                  std::vector<int> ind_;
                
                  //! Most recent solution vector used by this status test.
                  Teuchos::RCP<MV> curSoln_;
                
                  //! Status
                  StatusType status_;
                
                  //! The current blocksize of the linear system being solved.
                  int curBlksz_;
                
                  //! The current number of right-hand sides being solved for.
                  int curNumRHS_;
                
                  //! The indices of the current number of right-hand sides being solved for.
                  std::vector<int> curLSIdx_;
                
                  //! The current number of linear systems that have been loaded into the linear problem.
                  int curLSNum_;
                
                  //! The total number of right-hand sides being solved for.
                  int numrhs_;
                
                  //! Is this the first time CheckStatus is called?
                  bool firstcallCheckStatus_;
                
                  //! Is this the first time DefineResForm is called?
                  bool firstcallDefineResForm_;
                
                  //! Is this the first time DefineScaleForm is called?
                  bool firstcallDefineScaleForm_;
                
                  //@}
                
                };
                
                template <class ScalarType, class MV, class OP>
                StatusTestGenResNorm<ScalarType,MV,OP>::
                StatusTestGenResNorm (MagnitudeType Tolerance, int quorum, bool showMaxResNormOnly)
                  : tolerance_(Tolerance),
                    quorum_(quorum),
                    showMaxResNormOnly_(showMaxResNormOnly),
                    restype_(Implicit),
                    resnormtype_(TwoNorm),
                    scaletype_(NormOfInitRes),
                    scalenormtype_(TwoNorm),
                    scalevalue_(Teuchos::ScalarTraits<MagnitudeType>::one ()),
                    status_(Undefined),
                    curBlksz_(0),
                    curNumRHS_(0),
                    curLSNum_(0),
                    numrhs_(0),
                    firstcallCheckStatus_(true),
                    firstcallDefineResForm_(true),
                    firstcallDefineScaleForm_(true)
                {
                  // This constructor will compute the residual ||r_i||/||r0_i|| <= tolerance using the 2-norm of
                  // the implicit residual std::vector.
                }
                
                template <class ScalarType, class MV, class OP>
       ##### -> StatusTestGenResNorm<ScalarType,MV,OP>::~StatusTestGenResNorm()
                {}
                
                template <class ScalarType, class MV, class OP>
           1 -> void StatusTestGenResNorm<ScalarType,MV,OP>::reset()
                {
                  status_ = Undefined;
                  curBlksz_ = 0;
                  curLSNum_ = 0;
                  curLSIdx_.resize(0);
                  numrhs_ = 0;
                  ind_.resize(0);
                  firstcallCheckStatus_ = true;
                  curSoln_ = Teuchos::null;
                }
                
                template <class ScalarType, class MV, class OP>
       ##### -> int StatusTestGenResNorm<ScalarType,MV,OP>::defineResForm( ResType TypeOfResidual, NormType TypeOfNorm )
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(firstcallDefineResForm_==false,StatusTestError,
                        "StatusTestGenResNorm::defineResForm(): The residual form has already been defined.");
                  firstcallDefineResForm_ = false;
                
                  restype_ = TypeOfResidual;
                  resnormtype_ = TypeOfNorm;
                
                  return(0);
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> int StatusTestGenResNorm<ScalarType,MV,OP>::defineScaleForm(ScaleType TypeOfScaling, NormType TypeOfNorm,
                                                                         MagnitudeType ScaleValue )
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(firstcallDefineScaleForm_==false,StatusTestError,
                        "StatusTestGenResNorm::defineScaleForm(): The scaling type has already been defined.");
                  firstcallDefineScaleForm_ = false;
                
                  scaletype_ = TypeOfScaling;
                  scalenormtype_ = TypeOfNorm;
                  scalevalue_ = ScaleValue;
                
                  return(0);
                }
                
                template <class ScalarType, class MV, class OP>
           4 -> StatusType StatusTestGenResNorm<ScalarType,MV,OP>::checkStatus( Iteration<ScalarType,MV,OP>* iSolver )
                {
                  MagnitudeType zero = Teuchos::ScalarTraits<MagnitudeType>::zero();
                  const LinearProblem<ScalarType,MV,OP>& lp = iSolver->getProblem();
                  // Compute scaling term (done once for each block that's being solved)
                  if (firstcallCheckStatus_) {
                    StatusType status = firstCallCheckStatusSetup(iSolver);
                    if(status==Failed) {
                      status_ = Failed;
                      return(status_);
                    }
                  }
                  //
                  // This section computes the norm of the residual std::vector
                  //
                  if ( curLSNum_ != lp.getLSNumber() ) {
                    //
                    // We have moved on to the next rhs block
                    //
                    curLSNum_ = lp.getLSNumber();
                    curLSIdx_ = lp.getLSIndex();
                    curBlksz_ = (int)curLSIdx_.size();
                    int validLS = 0;
                    for (int i=0; i<curBlksz_; ++i) {
                      if (curLSIdx_[i] > -1 && curLSIdx_[i] < numrhs_)
                        validLS++;
                    }
                    curNumRHS_ = validLS;
                    curSoln_ = Teuchos::null;
                    //
                  } else {
                    //
                    // We are in the same rhs block, return if we are converged
                    //
                    if (status_==Passed) { return status_; }
                  }
                  if (restype_==Implicit) {
                    //
                    // get the native residual norms from the solver for this block of right-hand sides.
                    // If the residual is returned in multivector form, use the resnormtype to compute the residual norms.
                    // Otherwise the native residual is assumed to be stored in the resvector_.
                    //
                    std::vector<MagnitudeType> tmp_resvector( curBlksz_ );
                    Teuchos::RCP<const MV> residMV = iSolver->getNativeResiduals( &tmp_resvector );
                    if ( residMV != Teuchos::null ) {
                      tmp_resvector.resize( MVT::GetNumberVecs( *residMV ) );
                      MVT::MvNorm( *residMV, tmp_resvector, resnormtype_ );
                      typename std::vector<int>::iterator p = curLSIdx_.begin();
                      for (int i=0; p<curLSIdx_.end(); ++p, ++i) {
                        // Check if this index is valid
                        if (*p != -1)
                          resvector_[*p] = tmp_resvector[i];
                      }
                    } else {
                      typename std::vector<int>::iterator p = curLSIdx_.begin();
                      for (int i=0; p<curLSIdx_.end(); ++p, ++i) {
                        // Check if this index is valid
                        if (*p != -1)
                          resvector_[*p] = tmp_resvector[i];
                      }
                    }
                  }
                  else if (restype_==Explicit) {
                    //
                    // Request the true residual for this block of right-hand sides.
                    //
                    Teuchos::RCP<MV> cur_update = iSolver->getCurrentUpdate();
                    curSoln_ = lp.updateSolution( cur_update );
                    Teuchos::RCP<MV> cur_res = MVT::Clone( *curSoln_, MVT::GetNumberVecs( *curSoln_ ) );
                    lp.computeCurrResVec( &*cur_res, &*curSoln_ );
                    std::vector<MagnitudeType> tmp_resvector( MVT::GetNumberVecs( *cur_res ) );
                    MVT::MvNorm( *cur_res, tmp_resvector, resnormtype_ );
                    typename std::vector<int>::iterator p = curLSIdx_.begin();
                    for (int i=0; p<curLSIdx_.end(); ++p, ++i) {
                      // Check if this index is valid
                      if (*p != -1)
                        resvector_[*p] = tmp_resvector[i];
                    }
                  }
                  //
                  // Compute the new linear system residuals for testing.
                  // (if any of them don't meet the tolerance or are NaN, then we exit with that status)
                  //
                  if ( scalevector_.size() > 0 ) {
                    typename std::vector<int>::iterator p = curLSIdx_.begin();
                    for (; p<curLSIdx_.end(); ++p) {
                      // Check if this index is valid
                      if (*p != -1) {
                        // Scale the std::vector accordingly
                        if ( scalevector_[ *p ] != zero ) {
                          // Don't intentionally divide by zero.
                          testvector_[ *p ] = resvector_[ *p ] / scalevector_[ *p ] / scalevalue_;
                        } else {
                          testvector_[ *p ] = resvector_[ *p ] / scalevalue_;
                        }
                      }
                    }
                  }
                  else {
                    typename std::vector<int>::iterator p = curLSIdx_.begin();
                    for (; p<curLSIdx_.end(); ++p) {
                      // Check if this index is valid
                      if (*p != -1)
                        testvector_[ *p ] = resvector_[ *p ] / scalevalue_;
                    }
                  }
                
                  // Check status of new linear system residuals and see if we have the quorum.
                  int have = 0;
                  ind_.resize( curLSIdx_.size() );
                  typename std::vector<int>::iterator p = curLSIdx_.begin();
                  for (; p<curLSIdx_.end(); ++p) {
                    // Check if this index is valid
                    if (*p != -1) {
                      // Check if any of the residuals are larger than the tolerance.
                      if (testvector_[ *p ] > tolerance_) {
                        // do nothing.
                      } else if (testvector_[ *p ] <= tolerance_) {
                        ind_[have] = *p;
                        have++;
                      } else {
                        // Throw an std::exception if a NaN is found.
                        status_ = Failed;
                        TEUCHOS_TEST_FOR_EXCEPTION(true,StatusTestError,"StatusTestGenResNorm::checkStatus(): NaN has been detected.");
                      }
                    }
                  }
                  ind_.resize(have);
                  int need = (quorum_ == -1) ? curNumRHS_: quorum_;
                  status_ = (have >= need) ? Passed : Failed;
                
                  // Return the current status
                  return status_;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> void StatusTestGenResNorm<ScalarType,MV,OP>::print(std::ostream& os, int indent) const
                {
                  for (int j = 0; j < indent; j ++)
                    os << ' ';
                  printStatus(os, status_);
                  os << resFormStr();
                  if (status_==Undefined)
                    os << ", tol = " << tolerance_ << std::endl;
                  else {
                    os << std::endl;
                    if(showMaxResNormOnly_ && curBlksz_ > 1) {
                      const MagnitudeType maxRelRes = *std::max_element(
                        testvector_.begin()+curLSIdx_[0],testvector_.begin()+curLSIdx_[curBlksz_-1]
                        );
                      for (int j = 0; j < indent + 13; j ++)
                        os << ' ';
                      os << "max{residual["<<curLSIdx_[0]<<"..."<<curLSIdx_[curBlksz_-1]<<"]} = " << maxRelRes
                         << ( maxRelRes <= tolerance_ ? " <= " : " > " ) << tolerance_ << std::endl;
                    }
                    else {
                      for ( int i=0; i<numrhs_; i++ ) {
                        for (int j = 0; j < indent + 13; j ++)
                          os << ' ';
                        os << "residual [ " << i << " ] = " << testvector_[ i ];
                        os << ((testvector_[i]<tolerance_) ? " < " : (testvector_[i]==tolerance_) ? " == " : (testvector_[i]>tolerance_) ? " > " : " "  ) << tolerance_ << std::endl;
                      }
                    }
                  }
                  os << std::endl;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> void StatusTestGenResNorm<ScalarType,MV,OP>::printStatus(std::ostream& os, StatusType type) const
                {
                  os << std::left << std::setw(13) << std::setfill('.');
                  switch (type) {
                  case  Passed:
                    os << "Converged";
                    break;
                  case  Failed:
                    os << "Unconverged";
                    break;
                  case  Undefined:
                  default:
                    os << "**";
                    break;
                  }
                  os << std::left << std::setfill(' ');
                    return;
                }
                
                template <class ScalarType, class MV, class OP>
           1 -> StatusType StatusTestGenResNorm<ScalarType,MV,OP>::firstCallCheckStatusSetup( Iteration<ScalarType,MV,OP>* iSolver )
                {
                  int i;
                  MagnitudeType zero = Teuchos::ScalarTraits<MagnitudeType>::zero();
                  MagnitudeType one = Teuchos::ScalarTraits<MagnitudeType>::one();
                  const LinearProblem<ScalarType,MV,OP>& lp = iSolver->getProblem();
                  // Compute scaling term (done once for each block that's being solved)
                  if (firstcallCheckStatus_) {
                    //
                    // Get some current solver information.
                    //
                    firstcallCheckStatus_ = false;
                
                    if (scaletype_== NormOfRHS) {
                      Teuchos::RCP<const MV> rhs = lp.getRHS();
                      numrhs_ = MVT::GetNumberVecs( *rhs );
                      scalevector_.resize( numrhs_ );
                      MVT::MvNorm( *rhs, scalevector_, scalenormtype_ );
                    }
                    else if (scaletype_==NormOfInitRes || scaletype_==NormOfFullInitRes || scaletype_==NormOfFullScaledInitRes) {
                      Teuchos::RCP<const MV> init_res = lp.getInitResVec();
                      numrhs_ = MVT::GetNumberVecs( *init_res );
                      scalevector_.resize( numrhs_ );
                      MVT::MvNorm( *init_res, scalevector_, scalenormtype_ );
                    }
                    else if (scaletype_==NormOfPrecInitRes || scaletype_==NormOfFullPrecInitRes || scaletype_==NormOfFullScaledPrecInitRes) {
                      Teuchos::RCP<const MV> init_res = lp.getInitPrecResVec();
                      numrhs_ = MVT::GetNumberVecs( *init_res );
                      scalevector_.resize( numrhs_ );
                      MVT::MvNorm( *init_res, scalevector_, scalenormtype_ );
                    }
                    else {
                      numrhs_ = MVT::GetNumberVecs( *(lp.getRHS()) );
                    }
                
                    resvector_.resize( numrhs_ );
                    testvector_.resize( numrhs_ );
                
                    curLSNum_ = lp.getLSNumber();
                    curLSIdx_ = lp.getLSIndex();
                    curBlksz_ = (int)curLSIdx_.size();
                    int validLS = 0;
                    for (i=0; i<curBlksz_; ++i) {
                      if (curLSIdx_[i] > -1 && curLSIdx_[i] < numrhs_)
                        validLS++;
                    }
                    curNumRHS_ = validLS;
                    //
                    // Initialize the testvector.
                    for (i=0; i<numrhs_; i++) { testvector_[i] = one; }
                
                    // Return an error if the scaling is zero.
                    if (scalevalue_ == zero) {
                      return Failed;
                    }
                  }
                  return Undefined;
                }
                
                } // end namespace Belos
                
                #endif /* BELOS_STATUS_TEST_RESNORM_H */


Top 10 Lines:

     Line      Count

      453          4
      275          1
      412          1
      438          1
      589          1
      621          1
      641          1

Execution Summary:

       21   Executable lines in this file
       21   Lines executed
   100.00   Percent of the file executed

       10   Total number of line executions
     0.48   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_ParameterList.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                
                #ifndef TEUCHOS_PARAMETER_LIST_H
                #define TEUCHOS_PARAMETER_LIST_H
                
                /*! \file Teuchos_ParameterList.hpp
                    \brief Templated Parameter List class
                */  
                
                #include "Teuchos_ParameterListExceptions.hpp"
                #include "Teuchos_ParameterEntry.hpp"
                #include "Teuchos_StringIndexedOrderedValueObjectContainer.hpp"
                #include "Teuchos_Assert.hpp"
                #include "Teuchos_RCP.hpp"
                #include "Teuchos_Array.hpp"
                #include "Teuchos_map.hpp"
                
                
                /** \example ParameterList/cxx_main.cpp
                    This is an example of how to use the Teuchos::ParameterList class.
                */
                
                namespace Teuchos {
                
                /** \brief Validation used enum.
                 * \relates ParameterList
                 */
                enum EValidateUsed {
                  VALIDATE_USED_ENABLED   /*!< Validate that parameters in <tt>*this</tt> list
                                              set using the default value are present in
                                              the validation list */
                  ,VALIDATE_USED_DISABLED /*!< Do not validate that parameters in <tt>*this</tt> list
                                              set using the default value are present in
                                              the validation list */
                };
                
                /** \brief Validation defaults enum.
                 * \relates ParameterList
                 */
                enum EValidateDefaults {
                  VALIDATE_DEFAULTS_ENABLED   /*!< Validate that parameters in <tt>*this</tt> list
                                                  set using the default value are present in
                                                   the validation list */
                  ,VALIDATE_DEFAULTS_DISABLED /*!< Do not validate that parameters in <tt>*this</tt> list
                                                  set using the default value are present in
                                                  the validation list */
                };
                
                /*! \brief A list of parameters of arbitrary type.
                
                  \section Teuchos_ParameterList_Summary Summary
                
                  A ParameterList is a map from parameter name (a string) to its
                  value.  The value may have any type with value semantics (see
                  explanation and examples below).  This includes another
                  ParameterList, which allows a ParameterList to encode a hierarchy of
                  parameters.  Different entries in the same ParameterList may have
                  values of different types.
                
                  Users may add a parameter using one of the get() methods, and
                  retrieve its value (given the parameter's name) using one of the
                  set() methods.  If the compiler gets confused when you use one of
                  the templated methods, you might have to help it by specifying the
                  type explicitly, or by casting the input object (using e.g.,
                  <tt>static_cast</tt>).  There are also methods for iterating through
                  all the parameters in a list, and for validating parameters using
                  validators that you may define for each parameter.
                
                  \section Teuchos_ParameterList_ValueSemantics Value semantics
                
                  A type has <i>value semantics</i> when it can be passed around as a
                  value.  This means that it has an assignment operator and a copy
                  constructor, and that the latter creates "new objects" (rather than
                  references that modify a single object).  Types with value semantics
                  include \c double, \c float, \c int, \c std::string, and similar
                  types.
                
                  Paradoxically, pointers like <tt>double*</tt> also have value
                  semantics.  While the pointer is a reference to an object (e.g., an
                  array of <tt>double</tt>), the pointer itself is a value (an address
                  in memory).  The same holds for Teuchos' reference-counted pointer
                  and array classes (RCP resp. ArrayRCP).  While it is valid to store
                  pointers ("raw" or reference-counted) in a ParameterList, be aware
                  that this hinders serialization.  For example, a <tt>double*</tt>
                  could encode a single \c double or an array of \c double.  The
                  pointer itself does not encode the length of the array.  A
                  ParameterList serializer has no way to know what the
                  <tt>double*</tt> means.  ParameterList does not forbid you from
                  storing objects that cannot be correctly serialized, so you have to
                  know whether or not this concerns you.
                */
                class TEUCHOSPARAMETERLIST_LIB_DLL_EXPORT ParameterList {
                
                  //! Internal data-structure
                  typedef StringIndexedOrderedValueObjectContainer<ParameterEntry> params_t;
                
                  //! Parameter container iterator typedef
                  typedef params_t::Iterator Iterator;
                  
                public:
                
                  //! @name Public types 
                  //@{
                
                  //! Parameter container const iterator typedef
                  typedef params_t::ConstIterator ConstIterator;
                
                  /** \brief Utility class for setting and passing in print options. */
                  class PrintOptions {
                  public:
                    PrintOptions() : indent_(0), showTypes_(false), showFlags_(false), showDoc_(false) {}
                    PrintOptions& indent(int _indent)        { indent_ = _indent; return *this; }
                    PrintOptions& showTypes(bool _showTypes) { showTypes_ = _showTypes; return *this; }
                    PrintOptions& showFlags(bool _showFlags) { showFlags_ = _showFlags; return *this; }
                    PrintOptions& showDoc(bool _showDoc)     { showDoc_ = _showDoc; return *this; }
                    PrintOptions& incrIndent(int indents)    { indent_ += indents; return *this; }
                    int indent() const { return indent_; }
                    bool showTypes() const { return showTypes_; }
                    bool showFlags() const { return showFlags_; }
                    bool showDoc() const { return showDoc_; }
                    PrintOptions copy() const { return PrintOptions(*this); }
                  private:
                    int    indent_;
                    bool   showTypes_;
                    bool   showFlags_;
                    bool   showDoc_;
                  };
                
                  //@}
                  
                  //! @name Constructors/Destructor/Info. 
                  //@{
                
                  //! Constructor
                  ParameterList();
                
                  //! Constructor that names the entire parameter list.
                  ParameterList(const std::string &name);
                  
                  //! Copy constructor
                  ParameterList(const ParameterList& source);
                  
                  //! Destructor
                  virtual ~ParameterList();
                
                  //! Get the number of stored parameters.
                  Ordinal numParams () const;
                
                  //@}
                  //! @name Set Functions 
                  //@{
                
                  //! Set the name of <tt>*this</tt> list.
                  ParameterList& setName( const std::string &name );
                  
                  /// \brief Replace the current parameter list with \c source.
                  ///
                  /// \note This also replaces the name returned by <tt>this->name()</tt>
                  ParameterList& operator= (const ParameterList& source);
                  
                  /** Set the parameters in <tt>source</tt>.
                   *
                   * This function will set the parameters and sublists from
                   * <tt>source</tt> into <tt>*this</tt>, but will not remove
                   * parameters from <tt>*this</tt>.  Parameters in <tt>*this</tt>
                   * with the same names as those in <tt>source</tt> will be
                   * overwritten.
                   */
                  ParameterList& setParameters(const ParameterList& source);
                  
                  /** Set the parameters in <tt>source</tt> that are not already set in
                   * <tt>*this</tt>.
                   *
                   * Note, this function will set the parameters and sublists from
                   * <tt>source</tt> into <tt>*this</tt> but will not result in parameters
                   * being removed from <tt>*this</tt> or in parameters already set in
                   * <tt>*this</tt> being overrided.  Parameters in <tt>*this</tt> with the
                   * same names as those in <tt>source</tt> will not be overwritten.
                   */
                  ParameterList& setParametersNotAlreadySet(const ParameterList& source);
                
                  /** Disallow recusive validation when this sublist is used in a valid
                   * parameter list.
                   *
                   * This function should be called when setting a sublist in a valid
                   * parameter list which is broken off to be passed to another object.
                   * The other object should validate its own list.
                   */
                  ParameterList& disableRecursiveValidation();
                  
                  /*! \brief Set a parameter whose value has type T.
                
                    \param name [in] The parameter's name.
                    \param value [in] The parameter's value.  This determines the
                      template parameter T.  In most cases, you will not need to
                      specify the type T explicitly; the compiler will infer it from
                      this argument.
                    \param docString [in] Documentation string for the parameter.
                    \param validator [in] Validator for the parameter.  If not
                      specified, it defaults to \c null, the trivial validator (every
                      value passes validation).
                    
                    \note <ul>
                    <li> Use static_cast<T>() when the type is ambiguous. 
                    <li> Both char* and std::string std::map to are stored as strings internally. 
                    <li> Sets the parameter as "unused".
                    </ul>
                  */
                  template<typename T>
                  ParameterList& set (std::string const& name, 
                		      T const& value, 
                		      std::string const& docString = "",
                		      RCP<const ParameterEntryValidator> const& validator = null);
                
                  /// \brief Specialization of set() for a parameter which is a <tt>char[]</tt>.
                  ///
                  /// This version of set() copies the given character array to an
                  /// \c std::string and stores it that way in the ParameterList.
                  ParameterList& set(
                    std::string const& name, char value[], std::string const& docString = "",
                    RCP<const ParameterEntryValidator> const& validator = null
                    );
                
                  /// \brief Specialization of set() for a parameter which is a <tt>const char[]</tt>.
                  ///
                  /// This version of set() copies the given character array to an
                  /// \c std::string and stores it that way in the ParameterList.
                  ParameterList& set(
                    std::string const& name, const char value[], std::string const& docString = "",
                    RCP<const ParameterEntryValidator> const& validator = null
                    );
                
                  /// \brief Specialization of set() for a parameter which is itself a ParameterList.
                  ///
                  /// We call the input ParameterList a <i>sublist</i> of <tt>*this</tt>.
                  ParameterList& set(
                    std::string const& name, ParameterList const& value, std::string const& docString = ""
                    );
                
                  /*! \brief Set a parameter directly as a ParameterEntry. 
                   * \note This is required to preserve the isDefault value when reading back
                   * from XML. KL 7 August 2004 
                   */
                  ParameterList& setEntry(const std::string& name, const ParameterEntry& entry);
                
                  //@}
                  //! @name Get Functions 
                  //@{
                
                    /*! \brief Return the parameter's value, or the default value if it is not there.
                
                      If the parameter with the given name exists in this
                      ParameterList and has type T, return the parameter's value.  If
                      the parameter exists but does not have type T, throw an
                      exception.  Otherwise, if the parameter does not exist, add it
                      to the list with value <tt>def_value</tt>, and return
                      <tt>def_value</tt>.
                    
                    \note <ul> 
                    <li> Use the static_cast<T>() when the type is ambiguous.
                    <li> Both char* and std::string are stored as strings internally. 
                    <li> Sets the parameter as "used".
                    <li> Exception is thrown if \c name exists, but is not of type \c T.
                    </ul>
                  */
                  template<typename T>
                  T& get(const std::string& name, T def_value);
                
                  /*! \brief Specialization of get(), where the nominal value is a character string.
                    Both char* and std::string are stored as strings and return std::string values.
                  */
                  std::string& get(const std::string& name, char def_value[]);
                  
                  /*! \brief Specialization of get(), where the nominal value is a character string.
                    Both char* and std::string are stored as strings and return std::string values.
                  */
                  std::string& get(const std::string& name, const char def_value[]);
                
                  /// \brief Get a nonconst reference to the parameter.
                  ///
                  /// \param name [in] The name of the parameter.
                  ///
                  /// If the given parameter is not in the list at all, this method
                  /// throws Exceptions::InvalidParameter.  If the parameter is in the
                  /// list but does not have type T, this method throws
                  /// Exceptions::InvalidParameterType.  Both exceptions are
                  /// subclasses of Exceptions::InvalidParameter.
                  ///
                  /// You may use the returned reference to modify the parameter's
                  /// value in the list directly.
                  ///
                  /// When you call this method, you must specify the type T explicitly.
                  /// For example:
                  /// \code
                  /// Teuchos::ParameterList plist;
                  /// const int x = 42;
                  /// plist.set ("The Answer", x);
                  /// // ...
                  /// const int y = plist.get<int> ("The Answer");
                  /// \endcode
                  /// If the type T is itself a template parameter in your code, you
                  /// must use the \c template keyword.  For example:
                  /// \code
                  /// template<class T>
                  /// T& getMyParameter (Teuchos::ParameterList& plist) {
                  ///   return plist.template get<T> ("My Parameter");
                  /// }
                  /// \endcode
                  template<typename T>
                  T& get (const std::string& name);
                
                  /// \brief Get a const reference to the parameter.
                  ///
                  /// \param name [in] The name of the parameter.
                  ///
                  /// If the given parameter is not in the list at all, this method
                  /// throws Exceptions::InvalidParameter.  If the parameter is in the
                  /// list but does not have type T, this method throws
                  /// Exceptions::InvalidParameterType.  Both exceptions are
                  /// subclasses of Exceptions::InvalidParameter.
                  ///
                  /// When you call this method, you must specify the type T explicitly.
                  /// For example:
                  /// \code
                  /// Teuchos::ParameterList plist;
                  /// const int x = 42;
                  /// plist.set ("The Answer", x);
                  /// // ...
                  /// const int y = plist.get<int> ("The Answer");
                  /// \endcode
                  /// If the type T is itself a template parameter in your code, you
                  /// must use the \c template keyword.  For example:
                  /// \code
                  /// template<class T>
                  /// const T& getMyParameter (const Teuchos::ParameterList& plist) {
                  ///   return plist.template get<T> ("My Parameter");
                  /// }
                  /// \endcode
                  template<typename T>
                  const T& get (const std::string& name) const;  
                  
                  /*! \brief Retrieves the pointer for parameter \c name of type \c T from a
                    list.  A null pointer is returned if this parameter doesn't exist or is
                    the wrong type.  \note The syntax for calling this method is: <tt>
                    list.template getPtr<int>( "Iters" ) </tt>
                  */
                  template<typename T>
                  inline
                  T* getPtr(const std::string& name);
                  
                  /*! \brief Retrieves the pointer for parameter \c name of type \c T from a
                    constant list.  A null pointer is returned if this parameter doesn't exist
                    or is the wrong type.  \note The syntax for calling this method is: <tt>
                    list.template getPtr<int>( "Iters" ) </tt>
                  */
                  template<typename T>
                  inline
                  const T* getPtr(const std::string& name) const;  
                
                  // ToDo: Add getSafePtr() functions to return Ptr<T> instead of raw T*
                  
                  /*! \brief Retrieves an entry with the name <tt>name</tt>.
                   *
                   * Throws <tt>Exceptions::InvalidParameterName</tt> if this parameter does
                   * not exist.
                   */
                  ParameterEntry& getEntry(const std::string& name);  
                  
                  /*! \brief Retrieves a const entry with the name <tt>name</tt>.
                   *
                   * Throws <tt>Exceptions::InvalidParameterName</tt> if this parameter does
                   * not exist.
                   */
                  inline
                  const ParameterEntry& getEntry(const std::string& name) const;  
                  
                  /*! \brief Retrieves the pointer for an entry with the name <tt>name</tt> if
                   *  it exists. */
                  inline
                  ParameterEntry* getEntryPtr(const std::string& name);  
                
                  // ToDo: Add function called getEntrySafePtr() to return Ptr<> as the main
                  // implementation and deprecate getEntryPtr()
                  
                  /*! \brief Retrieves the pointer for a constant entry with the name <tt>name</tt> if
                   *  it exists. */
                  inline
                  const ParameterEntry* getEntryPtr(const std::string& name) const;  
                
                  /*! \brief Retrieves the RCP for an entry with the name <tt>name</tt> if
                   *  it exists. */
                  inline RCP<ParameterEntry> getEntryRCP(const std::string& name);  
                  
                  /*! \brief Retrieves the RCP for a constant entry with the name <tt>name</tt> if
                   *  it exists. */
                  inline RCP<const ParameterEntry> getEntryRCP(const std::string& name) const;
                
                  //@}
                
                  //! @name Parameter removal functions
                  //@{
                 
                  /** \brief Remove a parameter (does not depend on the type of the
                   * parameter).
                   *
                   * \param[in] name The name of the parameter to remove
                   *
                   * \param[in] throwIfNotExists If <tt>true</tt> then if the parameter with
                   * the name <tt>name</tt> does not exist then a std::exception will be
                   * thrown!
                   *
                   * \returns Returns <tt>true</tt> if the parameter was removed, and
                   * <tt>false</tt> if the parameter was not removed (<tt>false</tt> return
                   * value possible only if <tt>throwIfNotExists==false</tt>).
                   */
                  bool remove(
                    std::string const& name, bool throwIfNotExists = true
                    );
                
                  //@}
                  
                  //! @name Sublist Functions 
                  //@{
                
                  /*! \brief Creates an empty sublist and returns a reference to the sublist
                   *  \c name. If the list already exists, returns reference to that
                   *  sublist. If the name exists but is not a sublist, an std::exception is
                   *  thrown.
                   */
                  ParameterList& sublist(
                    const std::string& name, bool mustAlreadyExist = false
                    ,const std::string& docString = ""
                    );
                  
                  /*! \brief Return a const reference to an existing sublist \c name.  If the
                   *  list does not already exist or the name exists but is not a sublist, an
                   *  std::exception is thrown.
                   */
                  const ParameterList& sublist(const std::string& name) const;
                
                  //@}
                  
                  //! @name Attribute Functions 
                  //@{
                
                  //! The name of this ParameterList.
                  const std::string& name() const;
                
                  /// \brief Whether the given parameter exists in this list.
                  ///
                  /// Return true if a parameter with name \c name exists in this
                  /// list, else return false.
                  bool isParameter (const std::string& name) const;
                
                  /// \brief Whether the given sublist exists in this list.
                  ///
                  /// Return true if a parameter with name \c name exists in this
                  /// list, and is itself a ParameterList.  Otherwise, return false.
                  bool isSublist (const std::string& name) const;
                
                  /// \brief Whether the given parameter exists in this list and has type T.
                  ///
                  ///
                  /// Return true if a parameter with name \c name exists in this list
                  /// and has type T.  Otherwise, return false.
                  template<typename T>
                  bool isType (const std::string& name) const;
                
                #ifndef DOXYGEN_SHOULD_SKIP_THIS  
                  /*! \brief Query the existence and type of a parameter.
                   *
                   * \return "true" is a parameter with this \c name exists and is of type \c
                   * T, else "false".
                   *
                   * \note <b>It is not recommended that this method be used directly!</b>
                   *
                   * Please use either the helper function <b>isParameterType</b> or
                   * non-nominal <b>isType</b> method.
                  */
                  template<typename T>
                  bool isType(const std::string& name, T* ptr) const;
                #endif
                
                  //@}
                  
                  //! @name I/O Functions 
                  //@{
                
                  /*! \brief Print function to use in debugging in a debugger.
                   *
                   * Prints to *VerboseObjectBase::getDefaultOStream() so it will print well
                   * in parallel.
                   */
                  void print() const;
                
                  /*! \brief Printing method for parameter lists which takes an print options
                   *  object.*/
                  std::ostream& print(std::ostream& os, const PrintOptions &printOptions) const;
                
                  /*! \brief Printing method for parameter lists.  Indenting is used to indicate
                    parameter list hierarchies. */
                  std::ostream& print(std::ostream& os, int indent = 0, bool showTypes = false, bool showFlags = true ) const;
                  
                  //! Print out unused parameters in the ParameterList.
                  void unused(std::ostream& os) const;
                
                  //! Create a single formated std::string of all of the zero-level parameters in this list
                  std::string currentParametersString() const;
                
                  //@}
                
                  //! @name Read-only access to the iterator 
                  //@{
                
                  //! An iterator pointing to the first entry
                  inline ConstIterator begin() const;
                
                  //! An iterator pointing beyond the last entry
                  inline ConstIterator end() const;
                  
                  //! Access to name (i.e., returns i->first)
                  inline const std::string& name(ConstIterator i) const;
                
                  //! Access to ParameterEntry (i.e., returns i->second)
                  inline const ParameterEntry& entry(ConstIterator i) const;
                
                  //@}
                
                  //! @name Validation Functions 
                  //@{
                
                  /** \brief Validate the parameters in this list given valid selections in
                   * the input list.
                   *
                   * \param validParamList [in] This is the list that the parameters and
                   * sublist in <tt>*this</tt> are compared against.
                   *
                   * \param depth [in] Determines the number of levels of depth that the
                   * validation will recurse into.  A value of <tt>depth=0</tt> means that
                   * only the top level parameters and sublists will be checked.  Default:
                   * <tt>depth = large number</tt>.
                   *
                   * \param validateUsed [in] Determines if parameters that have been used are
                   * checked against those in <tt>validParamList</tt>.  Default:
                   * <tt>validateDefaults = VALIDATE_DEFAULTS_ENABLED</tt>.
                   *
                   * \param validateDefaults [in] Determines if parameters set at their
                   * default values using <tt>get(name,defaultVal)</tt> are checked against
                   * those in <tt>validParamList</tt>.  Default: <tt>validateDefaults =
                   * VALIDATE_DEFAULTS_ENABLED</tt>.
                   *
                   * If a parameter in <tt>*this</tt> is not found in <tt>validParamList</tt>
                   * then an <tt>std::exception</tt> of type
                   * <tt>Exceptions::InvalidParameterName</tt> will be thrown which will
                   * contain an excellent error message returned by <tt>excpt.what()</tt>.  If
                   * the parameter exists but has the wrong type, then an std::exception type
                   * <tt>Exceptions::InvalidParameterType</tt> will be thrown.  If the
                   * parameter exists and has the right type, but the value is not valid then
                   * an std::exception type <tt>Exceptions::InvalidParameterValue</tt> will be
                   * thrown.
                   *
                   * Recursive validation stops when:<ul>
                   *
                   * <li>The maxinum <tt>depth</tt> is reached
                   *
                   * <li>A sublist note in <tt>validParamList</tt> has been marked with the
                   * <tt>disableRecursiveValidation()</tt> function, or
                   *
                   * <li>There are not more parameters or sublists left in <tt>*this</tt>
                   *
                   * </ul>
                   *
                   * A breath-first search is performed to validate all of the parameters in
                   * one sublist before moving into nested subslist.
                   */
                  void validateParameters(
                    ParameterList const& validParamList,
                    int const depth = 1000,
                    EValidateUsed const validateUsed = VALIDATE_USED_ENABLED,
                    EValidateDefaults const validateDefaults = VALIDATE_DEFAULTS_ENABLED
                    ) const;
                
                  /** \brief Validate the parameters in this list given valid selections in
                   * the input list and set defaults for those not set.
                   *
                   * \param validParamList [in] This is the list that the parameters and
                   * sublist in <tt>*this</tt> are compared against.
                   *
                   * \param depth [in] Determines the number of levels of depth that the
                   * validation will recurse into.  A value of <tt>depth=0</tt> means that
                   * only the top level parameters and sublists will be checked.  Default:
                   * <tt>depth = large number</tt>.
                   *
                   * If a parameter in <tt>*this</tt> is not found in <tt>validParamList</tt>
                   * then an std::exception of type <tt>Exceptions::InvalidParameterName</tt> will
                   * be thrown which will contain an excellent error message returned by
                   * <tt>excpt.what()</tt>.  If the parameter exists but has the wrong type,
                   * then an std::exception type <tt>Exceptions::InvalidParameterType</tt> will be
                   * thrown.  If the parameter exists and has the right type, but the value is
                   * not valid then an std::exception type
                   * <tt>Exceptions::InvalidParameterValue</tt> will be thrown.  If a
                   * parameter in <tt>validParamList</tt> does not exist in <tt>*this</tt>,
                   * then it will be set at its default value as determined by
                   * <tt>validParamList</tt>.
                   *
                   * Recursive validation stops when:<ul>
                   *
                   * <li>The maxinum <tt>depth</tt> is reached
                   *
                   * <li>A sublist note in <tt>validParamList</tt> has been marked with the
                   * <tt>disableRecursiveValidation()</tt> function, or
                   *
                   * <li>There are not more parameters or sublists left in <tt>*this</tt>
                   *
                   * </ul>
                   *
                   * A breath-first search is performed to validate all of the parameters in
                   * one sublist before moving into nested subslist.
                   */
                  void validateParametersAndSetDefaults(
                    ParameterList const& validParamList,
                    int const depth = 1000
                    );
                
                  //@}
                  
                private: // Functions
                
                  //! An iterator pointing to the first entry
                  inline Iterator nonconstBegin();
                  //! An iterator pointing beyond the last entry
                  inline Iterator nonconstEnd();
                  //! Access to ParameterEntry (i.e., returns i->second)
                  inline ParameterEntry& nonconstEntry(Iterator i);
                  //! Validate that a parameter exists
                  void validateEntryExists(const std::string &funcName, const std::string &name,
                    const ParameterEntry *entry) const;
                  // ToDo: Change above function to take Ptr<> instead of raw pointer.
                  //! Validate that a type is the same
                  template<typename T>
                  void validateEntryType(const std::string &funcName, const std::string &name,
                    const ParameterEntry &entry ) const;
                  //! Validate a sublist param is indeed a sublist
                  void validateEntryIsList(const std::string &name, const ParameterEntry &entry) const;
                  //! Throw a sublist does not exist exception
                  void validateMissingSublistMustExist(const std::string &baselist_name,
                    const std::string &sublist_name, const bool mustAlreadyExist) const;
                  //! Update sublist names recursively
                  void updateSubListNames(int depth = 0);
                  
                private: // Data members
                
                  //! Name of the (sub)list
                  std::string name_;
                
                  //! Parameter list
                //use pragmas to disable some false-positive warnings for windows sharedlibs export
                //#ifdef _MSC_VER
                //#pragma warning(push)
                //#pragma warning(disable:4251)
                //#endif
                  params_t params_;
                //#ifdef _MSC_VER
                //#pragma warning(pop)
                //#endif
                
                  //! Validate into list or not
                  bool disableRecursiveValidation_;
                
                };
                
                
                /** \brief Nonmember constructor.
                 *
                 * \relates ParameterList
                 */
                inline
                RCP<ParameterList> parameterList()
                {
                  return rcp(new ParameterList);
                }
                
                
                /** \brief Nonmember constructor.
                 *
                 * \relates ParameterList
                 */
                inline
                RCP<ParameterList> parameterList(const std::string &name)
                {
                  return rcp(new ParameterList(name));
                }
                  
                
                /** \brief Nonmember constructor.
                 *
                 * \relates ParameterList
                 */
                inline
                RCP<ParameterList> parameterList(const ParameterList& source)
       ##### -> {
                  return rcp(new ParameterList(source));
                }
                
                
                /** \brief Nonmember constructor.
                 *
                 * \relates ParameterList
                 */
                inline
                RCP<ParameterList> createParameterList()
                {
                  return rcp(new ParameterList);
                }
                
                
                /** \brief Nonmember constructor.
                 *
                 * \relates ParameterList
                 */
                inline
                RCP<ParameterList> createParameterList(const std::string &name)
                {
                  return rcp(new ParameterList(name));
                }
                
                
                /** \brief Traits specialization.
                 *
                 * \relates ParameterList
                 */
                template<>
                class TEUCHOSPARAMETERLIST_LIB_DLL_EXPORT TypeNameTraits<ParameterList> {
                public:
                  static std::string name() { return "ParameterList"; }
                  static std::string concreteName( const ParameterList& /*t2*/ )
                    { return name(); }
                };
                
                
                /** \brief Returns true if two parameter lists are the same.
                 *
                 * \relates ParameterList
                 */
                TEUCHOSPARAMETERLIST_LIB_DLL_EXPORT bool operator==( const ParameterList& list1, const ParameterList& list2 );
                
                
                /** \brief Returns true if two parameter lists are <b>not</tt> the same.
                 *
                 * \relates ParameterList
                 */
                inline
                bool operator!=( const ParameterList& list1, const ParameterList& list2 )
                {
                  return !( list1 == list2 );
                }
                
                
                /** \brief Returns true if two parameter lists have the same values.
                 *
                 * Two parameter lists may have the same values but may not be identical.  For
                 * example, two parameters can have the same values but not have the same
                 * documentation strings or the same validators.
                 *
                 * \note This test respects ordering of the ParameterList entries; the same values in a different 
                 *       order will result in \false.
                 *
                 * \relates ParameterList
                 */
                TEUCHOSPARAMETERLIST_LIB_DLL_EXPORT bool haveSameValues( const ParameterList& list1, const ParameterList& list2 );
                
                
                // /////////////////////////////////////////////////////
                // Inline and Template Function Definitions
                
                
                inline
                ParameterList& ParameterList::setName( const std::string &name_in )
                {
                  name_ = name_in;
                  return *this;
                }
                
                
                // Set functions
                
                
                template<typename T>
                inline
          32 -> ParameterList& ParameterList::set(
                  std::string const& name_in, T const& value_in, std::string const& docString_in,
                  RCP<const ParameterEntryValidator> const& validator_in
                  )
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    Ptr<ParameterEntry> param = params_.getNonconstObjPtr(param_idx);
                    const std::string docString =
                      (docString_in.length() ? docString_in : param->docString());
                    const RCP<const ParameterEntryValidator> validator =
                      (nonnull(validator_in) ? validator_in : param->validator());
                     // Create temp param to validate before setting
                    ParameterEntry param_new(value_in, false, false, docString, validator );
                    if (nonnull(validator)) {
                      validator->validate(param_new, name_in, this->name());
                    }
                    // Strong guarantee: (if exception is thrown, the value is not changed)
                    *param = param_new;
                  }
                  else {
                    ParameterEntry param_new(value_in, false, false, docString_in, validator_in);
                    if (nonnull(param_new.validator())) {
                      param_new.validator()->validate(param_new, name_in, this->name());
                    }
                    params_.setObj(name_in, param_new);
                  }
                  return *this;
                }
                
                
                inline
                ParameterList& ParameterList::set(
                  std::string const& name_in, char value[], std::string const& docString
                  ,RCP<const ParameterEntryValidator> const& validator
                  ) 
                { return set(name_in, std::string(value), docString, validator); }
                
                
                inline
                ParameterList& ParameterList::set(
                  const std::string& name_in, const char value[], const std::string &docString
                  ,RCP<const ParameterEntryValidator> const& validator
                  ) 
                { return set( name_in, std::string(value), docString, validator ); }
                
                
                inline
                ParameterList& ParameterList::set(
                  std::string const& name_in, ParameterList const& value, std::string const& /*docString*/
                  )
                {
                  sublist(name_in) = value;
                  return *this;
                }
                
                
                inline
                ParameterList& ParameterList::setEntry(std::string const& name_in, ParameterEntry const& entry_in)
                {
                  params_.setObj(name_in, entry_in);
                  return *this;
                }
                
                
                // Get functions
                
                
                template<typename T>
           3 -> T& ParameterList::get(const std::string& name_in, T def_value)
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  Ordinal param_idx = params_.getObjOrdinalIndex(name_in); 
                  if (param_idx == SIOVOCB::getInvalidOrdinal()) {
                    // Param does not exist
                    param_idx = params_.setObj(name_in, ParameterEntry(def_value, true));
                  }
                  Ptr<ParameterEntry> param = params_.getNonconstObjPtr(param_idx);
                  this->template validateEntryType<T>("get", name_in, *param);
                  return getValue<T>(*param);
                }
                
                
                inline
                std::string& ParameterList::get(const std::string& name_in, char def_value[])
                { return get(name_in, std::string(def_value)); }
                
                
                inline
                std::string& ParameterList::get(const std::string& name_in, const char def_value[])
                { return get(name_in, std::string(def_value)); }
                
                
                template<typename T>
          68 -> T& ParameterList::get(const std::string& name_in) 
                {
                  ParameterEntry *foundEntry = this->getEntryPtr(name_in);
                  validateEntryExists("get",name_in,foundEntry);
                  this->template validateEntryType<T>("get",name_in,*foundEntry);
                  return getValue<T>(*foundEntry);
                }
                
                  
                template<typename T>
           4 -> const T& ParameterList::get(const std::string& name_in) const
                {
                  const ParameterEntry *foundEntry = this->getEntryPtr(name_in);
                  validateEntryExists("get",name_in,foundEntry);
                  this->template validateEntryType<T>("get",name_in,*foundEntry);
                  return getValue<T>(*foundEntry);
                }
                
                
                template<typename T>
                inline
                T* ParameterList::getPtr(const std::string& name_in) 
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    const Ptr<ParameterEntry> param_ptr = params_.getNonconstObjPtr(param_idx);
                    if (param_ptr->isType<T>()) {
                      return &param_ptr->getValue<T>(0);
                    }
                    // Note: The above is inefficinet.  You have to do the dynamic_cast twice
                    // (once to see if it is the type and once to do the cast).  This could be
                    // made more efficinet by upgrading Teuchos::any to add a any_cast_ptr()
                    // function but I don't think anyone actually uses this function.
                    return 0;
                  }
                  return 0;
                }
                
                  
                template<typename T>
                inline
                const T* ParameterList::getPtr(const std::string& name_in) const
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    const Ptr<const ParameterEntry> param_ptr = params_.getObjPtr(param_idx);
                    if (param_ptr->isType<T>()) {
                      return &param_ptr->getValue<T>(0);
                    }
                    // Note: The above is inefficinet, see above non-const getPtr() function.
                    return 0;
                  }
                  return 0;
                }
                
                
                inline
                ParameterEntry& ParameterList::getEntry(const std::string& name_in)
                {
                  ParameterEntry *foundEntry = this->getEntryPtr(name_in);
                  validateEntryExists("get", name_in, foundEntry);
                  return *foundEntry;
                }
                
                  
                inline
                const ParameterEntry& ParameterList::getEntry(const std::string& name_in) const
                {
                  const ParameterEntry *foundEntry = this->getEntryPtr(name_in);
                  validateEntryExists("get", name_in, foundEntry);
                  return *foundEntry;
                }
                
                
                inline
                ParameterEntry*
                ParameterList::getEntryPtr(const std::string& name_in)
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    return &*params_.getNonconstObjPtr(param_idx);
                  }
                  return 0;
                }
                
                
                inline
                const ParameterEntry*
                ParameterList::getEntryPtr(const std::string& name_in) const
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    return &*params_.getObjPtr(param_idx);
                  }
                  return 0;
                }
                
                
                inline RCP<ParameterEntry>
                ParameterList::getEntryRCP(const std::string& name_in)
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    return rcpFromPtr(params_.getNonconstObjPtr(param_idx));
                  }
                  return null;
                }
                
                
                inline RCP<const ParameterEntry>
                ParameterList::getEntryRCP(const std::string& name_in) const
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    return rcpFromPtr(params_.getObjPtr(param_idx));
                  }
                  return null;
                }
                
                
                // Attribute Functions
                
                
                inline
                const std::string& ParameterList::name() const
                {
                  return name_;
                }
                
                  
                #ifndef DOXYGEN_SHOULD_SKIP_THIS
                template<typename T>
                bool ParameterList::isType(const std::string& name_in, T* /*ptr*/) const
                {
                  typedef StringIndexedOrderedValueObjectContainerBase SIOVOCB;
                  const Ordinal param_idx = params_.getObjOrdinalIndex(name_in);
                  if (param_idx != SIOVOCB::getInvalidOrdinal()) {
                    return params_.getObjPtr(param_idx)->isType<T>();
                  }
                  return false;
                }
                #endif
                
                  
                template<typename T>
                bool ParameterList::isType(const std::string& name_in) const
                {
                  return this->isType(name_in, static_cast<T*>(0));
                }
                
                
                // Read-only access to the iterator
                
                
                inline ParameterList::ConstIterator ParameterList::begin() const
                {
                  return params_.begin();
                }
                
                
                inline ParameterList::ConstIterator ParameterList::end() const
                {
                  return params_.end();
                }
                
                
                inline const std::string& ParameterList::name(ConstIterator i) const
                {
                  return (i->first);
                }
                
                
                inline const ParameterEntry& ParameterList::entry(ConstIterator i) const
                {
                  return (i->second);
                }
                
                
                // private
                
                
                inline ParameterList::Iterator ParameterList::nonconstBegin()
                {
                  return params_.nonconstBegin();
                }
                
                
                inline ParameterList::Iterator ParameterList::nonconstEnd()
                {
                  return params_.nonconstEnd();
                }
                
                
                inline ParameterEntry& ParameterList::nonconstEntry(Iterator i)
                {
                  return (i->second);
                }
                
                
                template<typename T>
                inline
          86 -> void ParameterList::validateEntryType(
                  const std::string &/*funcName*/, const std::string &name_in,
                  const ParameterEntry &entry_in
                  ) const
                {
                  TEUCHOS_TEST_FOR_EXCEPTION_PURE_MSG(
                    entry_in.getAny().type() != typeid(T), Exceptions::InvalidParameterType
                    ,"Error!  An attempt was made to access parameter \""<<name_in<<"\""
                    " of type \""<<entry_in.getAny().typeName()<<"\""
                    "\nin the parameter (sub)list \""<<this->name()<<"\""
                    "\nusing the incorrect type \""<<TypeNameTraits<T>::name()<<"\"!"
                    );
                }
                
                
                // //////////////////////////////////////
                // Helper functions
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for getting a parameter from a non-const list.
                  This helper function prevents the need for giving a nominal value of the specific template type.
                    
                  \note The syntax for calling this function is:  <tt> getParameter<int>( list, "Iters" ) </tt>
                */
                template<typename T>
                T& getParameter( ParameterList& l, const std::string& name )
                {
                  return l.template get<T>(name);
                }
                
                  
                /*! \relates ParameterList
                  \brief A shorter name for <tt>getParameter()</tt>.
                    
                  \note The syntax for calling this function is:  <tt> get<int>( list, "Iters" ) </tt>
                */
                template<typename T>
                inline
                T& get( ParameterList& l, const std::string& name )
                {
                  return getParameter<T>(l,name);
                }
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for getting a parameter from a const list.
                  This helper function prevents the need for giving a nominal value of the specific template type.
                    
                  \note The syntax for calling this function is:  <tt> getParameter<int>( list, "Iters" ) </tt>    
                */
                template<typename T>
                const T& getParameter( const ParameterList& l, const std::string& name )
                {
                  return l.template get<T>(name);
                }
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for getting a pointer to a parameter from
                  a non-const list, if it exists.  This helper function prevents the need for
                  giving a nominal value of the specific template type.
                  \note The syntax for calling this function is:
                  <tt>getParameterPtr<int>(list,"Iters")</tt>
                */
                template<typename T>
                inline
                T* getParameterPtr( ParameterList& l, const std::string& name )
                {
                  return l.template getPtr<T>(name);
                }
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for getting a pointer to a parameter from
                  a non-const list, if it exists.  This helper function prevents the need for
                  giving a nominal value of the specific template type.
                  \note The syntax for calling this function is:
                  <tt>getParameterPtr<int>(list,"Iters")</tt>
                */
                template<typename T>
                inline
                const T* getParameterPtr( const ParameterList& l, const std::string& name )
                {
                  return l.template getPtr<T>(name);
                }
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for determining the type of a parameter entry for a non-const list.  
                  This helper function avoids the need for giving a nominal value of the specific template type.
                    
                  \note The syntax for calling this function is:  <tt> isParameterType<int>( list, "Iters" ) </tt>
                */
                template<typename T>
                inline
                bool isParameterType( ParameterList& l, const std::string& name )
                {
                  return l.isType( name, (T*)NULL );
                }
                
                  
                /*! \relates ParameterList
                  \brief A templated helper function for determining the type of a parameter entry for a const list.  
                  This helper function avoids the need for giving a nominal value of the specific template type.
                    
                  \note The syntax for calling this function is:  <tt> isParameterType<int>( list, "Iters" ) </tt>
                */
                template<typename T>
                inline
                bool isParameterType( const ParameterList& l, const std::string& name )
                {
                  return l.isType( name, (T*)NULL );
                }
                
                  
                /** \brief Set a std::string parameter representation of an array.
                 *
                 * \param paramName [in] The name of the parameter containing the std::string
                 * representation of the array.
                 *
                 * \param array [in] The array that will be set as a std::string parameter.
                 *
                 * \param paramList [in/out] The parameter list that the array will be set on.
                 *
                 * \relates ParameterList
                 */
                template<typename T>
                void setStringParameterFromArray(
                  const std::string          &paramName
                  ,const Array<T>       &array
                  ,ParameterList        *paramList
                  )
                {
                  TEUCHOS_TEST_FOR_EXCEPT(!paramList);
                  paramList->set(paramName,toString(array));
                }
                
                  
                /** \brief Get an Array object (with entries of type <tt>T</tt>) from a
                 * parameter holding a std::string representation of the array.
                 *
                 * \param paramList [in] The parameter list to extract the parameter array
                 * from.
                 *
                 * \param paramName [in] The name of the parameter containing the std::string
                 * representation of the array.
                 *
                 * \param arrayDim [in] If <tt>arrayDim >= 0</tt>, then the read in array must
                 * be equal to this dimension, or an std::exception will be thrown.  If
                 * <tt>arrayDim < 0</tt>, then an array of any dimension will be returned.
                 * The default is <tt>-1</tt> and therefore no array length validation will be
                 * performed.
                 *
                 * \param mustExist [in] If <tt>mustExist==true</tt>, then the parameter
                 * <tt>paramName</tt> must exist and must contain a valid array, or an
                 * std::exception is thrown.  If <tt>mustExist==false</tt>, and if the
                 * parameter <tt>paramName</tt> does not exist or contains an empty array
                 * std::string value, then an empty array object will be returned.
                 *
                 * \returns an array object if an std::exception is not thrown.  If
                 * <tt>mustExist==false</tt> and the parameter does not exist, then an empty
                 * array object will be returned.  If <tt>mustExist==true</tt> and
                 * <tt>arrayDim < 0</tt>, then if the parameter <tt>paramName</tt> exists and
                 * its array value is valid, then the converted array, of any size, will be
                 * returned.  If <tt>mustExist==true</tt> and <tt>arrayDim >= 0</tt> then an
                 * array of dimension <tt>arrayDim</tt> will be returned if an std::exception is
                 * not thrown.
                 *
                 * <b>Exceptions:</b>
                 *
                 * <ul>
                 *
                 * <li><tt>Exceptions::InvalidParameterName</tt> will be thrown if
                 * <tt>mustExist==true</tt> and the parameter <tt>paramName</tt> does not
                 * exist in <tt>paramList</tt>
                 *
                 * <li><tt>Exceptions::InvalidParameterType</tt> will be thrown if the
                 * parameter exists but does not have a value type of <tt>std::string</tt>.
                 *
                 * <li><tt>Exceptions::InvalidParameterValue</tt> will be thrown in the following cases:
                 *
                 *   <ul>
                 *   <li>If the parameter <tt>paramName</tt> exists but the array in std::string form
                 *       is not formated correctly.
                 *   <li>If <tt>arrayDim >= 0</tt> and the read in array dimension dies not equal
                 *       <tt>arrayDim</tt>
                 *   </ul>
                 *
                 * </ul>
                 *
                 * <b>Detailed Description:</b>
                 *
                 * This function allows <tt>Array<T></tt> objects to be read in from a
                 * parameter with a std::string representation of the array.  The templated function
                 * <tt>Teuchos::fromStringToArray()</tt> (see documentation for
                 * <tt>Teuchos::Array</tt>) is used to parse the std::string representation and
                 * return the array object (see this function's documentation for details on
                 * what the formatting of the array std::string must be and what can be handled and
                 * what can not be handled.
                 *
                 * \relates ParameterList
                 */
                template<typename T>
                Array<T> getArrayFromStringParameter(
                  const ParameterList   &paramList
                  ,const std::string         &paramName
                  ,const int            arrayDim        = -1
                  ,const bool           mustExist       = true
                  )
                {
                  std::string arrayStr;
                  if(mustExist) {
                    arrayStr = getParameter<std::string>(paramList,paramName);
                  }
                  else {
                    const std::string
                      *arrayStrPtr = getParameterPtr<std::string>(paramList,paramName);
                    if(arrayStrPtr) {
                      arrayStr = *arrayStrPtr;
                    }
                    else {
                      return Array<T>(); // Return an empty array
                    }
                  }
                  Array<T> a;
                  try {
                    a = fromStringToArray<T>(arrayStr);
                  }
                  catch( const InvalidArrayStringRepresentation&) {
                    TEUCHOS_TEST_FOR_EXCEPTION_PURE_MSG(
                      true, Exceptions::InvalidParameterValue
                      ,"Error!  The parameter \""<<paramName<<"\"\n"
                      "in the sublist \""<<paramList.name()<<"\"\n"
                      "exists, but the std::string value:\n"
                      "----------\n"
                      <<arrayStr<<
                      "\n----------\n"
                      "is not a valid array represntation!"
                      );
                  }
                  TEUCHOS_TEST_FOR_EXCEPTION_PURE_MSG(
                    ( ( a.size()>0 && arrayDim>=0 ) && static_cast<int>(a.size())!=arrayDim )
                    ,Exceptions::InvalidParameterValue
                    ,"Error!  The parameter \""<<paramName<<"\"\n"
                    "in the sublist \""<<paramList.name()<<"\"\n"
                    "exists and is a valid array, but the dimension of\n"
                    "the read in array a.size() = " << a.size() << "\n"
                    "was not equal to the expected size arrayDim = " << arrayDim << "!"
                    );
                  return a;
                }
                
                
                /*! \relates ParameterList
                  \brief Return a RCP to a sublist in another RCP-ed parameter list.
                */
                inline
                RCP<ParameterList> sublist(
                  const RCP<ParameterList> &paramList, const std::string& name,
                  bool mustAlreadyExist = false, const std::string& docString = ""
                  )
                {
                  return rcpWithEmbeddedObjPostDestroy(
                    &paramList->sublist(name, mustAlreadyExist, docString), paramList, false );
                }
                
                
                /*! \relates ParameterList
                  \brief Return a RCP to a sublist in another RCP-ed parameter list.
                */
                inline
                RCP<const ParameterList> sublist(
                  const RCP<const ParameterList> &paramList, const std::string& name
                  )
                {
                  return rcpWithEmbeddedObjPostDestroy(
                    &paramList->sublist(name), paramList, false );
                }
                
                  
                /*! \relates ParameterList
                  \brief Output stream operator for handling the printing of the parameter list.
                */
                inline std::ostream& operator<<(std::ostream& os, const ParameterList& l)
                {
                  return l.print(os);
                }
                
                  
                } // end of Teuchos namespace
                
                
                #endif


Top 10 Lines:

     Line      Count

     1132         86
      925         68
      830         32
      935          4
      900          3

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      193   Total number of line executions
    32.17   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Xpetra_TpetraMap.hpp:
                // @HEADER
                //
                // ***********************************************************************
                //
                //             Xpetra: A linear algebra interface package
                //                  Copyright 2012 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact
                //                    Jonathan Hu       (jhu@sandia.gov)
                //                    Andrey Prokopenko (aprokop@sandia.gov)
                //                    Ray Tuminaro      (rstumin@sandia.gov)
                //
                // ***********************************************************************
                //
                // @HEADER
                #ifndef XPETRA_TPETRAMAP_HPP
                #define XPETRA_TPETRAMAP_HPP
                
                /* this file is automatically generated - do not edit (see script/tpetra.py) */
                
                #include "Xpetra_TpetraConfigDefs.hpp"
                
                #include <Tpetra_Map.hpp>
                
                #include "Xpetra_Map.hpp"
                #include "Xpetra_Utils.hpp"
                
                #include "Xpetra_Exceptions.hpp"
                
                namespace Xpetra {
                
                  // TODO: move that elsewhere
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node>&             toTpetra(const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node>&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node > > toTpetra(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node > >         toXpetra(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<Map<LocalOrdinal,GlobalOrdinal,Node > >               toXpetraNonConst(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                  //
                
                  template <class LocalOrdinal = Map<>::local_ordinal_type,
                            class GlobalOrdinal = typename Map<LocalOrdinal>::global_ordinal_type,
                            class Node = typename Map<LocalOrdinal, GlobalOrdinal>::node_type>
                  class TpetraMap
                    : public virtual Map<LocalOrdinal,GlobalOrdinal,Node> {
                
                  public:
                
                    static Teuchos::RCP<Node> defaultArgNode() {
                        // Workaround function for a deferred visual studio bug
                        // http://connect.microsoft.com/VisualStudio/feedback/details/719847/erroneous-error-c2783-could-not-deduce-template-argument
                        // Use this function for default arguments rather than calling
                        // what is the return value below.  Also helps in reducing
                        // duplication in various constructors.
                        return KokkosClassic::Details::getNode<Node>();
                    }
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Constructor with Tpetra-defined contiguous uniform distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               LocalGlobal lg=GloballyDistributed,
                               const Teuchos::RCP< Node > &node = defaultArgNode())
                      : map_ (Teuchos::rcp (new Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > (numGlobalElements,
                                                                                                  indexBase, comm,
                                                                                                  toTpetra(lg), node)))
                    {}
                
                    //! Constructor with a user-defined contiguous distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               size_t numLocalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode())
                      : map_ (Teuchos::rcp (new Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > (numGlobalElements,
                                                                                                  numLocalElements,
                                                                                                  indexBase, comm,
                                                                                                  node)))
                    {}
                
                    //! Constructor with user-defined arbitrary (possibly noncontiguous) distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               const Teuchos::ArrayView< const GlobalOrdinal > &elementList,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode())
                      : map_(Teuchos::rcp(new Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node >(numGlobalElements,
                                                                                               elementList, indexBase,
                                                                                               comm, node)))
                    {}
                
                    //! Destructor.
       ##### ->     ~TpetraMap() {  }
                
                    //@}
                
                    //! @name Attributes
                    //@{
                
                    //! The number of elements in this Map.
       ##### ->     global_size_t getGlobalNumElements() const { XPETRA_MONITOR("TpetraMap::getGlobalNumElements"); return map_->getGlobalNumElements(); }
                
                    //! The number of elements belonging to the calling node.
       ##### ->     size_t getNodeNumElements() const { XPETRA_MONITOR("TpetraMap::getNodeNumElements"); return map_->getNodeNumElements(); }
                
                    //! The index base for this Map.
           4 ->     GlobalOrdinal getIndexBase() const { XPETRA_MONITOR("TpetraMap::getIndexBase"); return map_->getIndexBase(); }
                
                    //! The minimum local index.
       ##### ->     LocalOrdinal getMinLocalIndex() const { XPETRA_MONITOR("TpetraMap::getMinLocalIndex"); return map_->getMinLocalIndex(); }
                
                    //! The maximum local index on the calling process.
       ##### ->     LocalOrdinal getMaxLocalIndex() const { XPETRA_MONITOR("TpetraMap::getMaxLocalIndex"); return map_->getMaxLocalIndex(); }
                
                    //! The minimum global index owned by the calling process.
       ##### ->     GlobalOrdinal getMinGlobalIndex() const { XPETRA_MONITOR("TpetraMap::getMinGlobalIndex"); return map_->getMinGlobalIndex(); }
                
                    //! The maximum global index owned by the calling process.
       ##### ->     GlobalOrdinal getMaxGlobalIndex() const { XPETRA_MONITOR("TpetraMap::getMaxGlobalIndex"); return map_->getMaxGlobalIndex(); }
                
                    //! The minimum global index over all processes in the communicator.
       ##### ->     GlobalOrdinal getMinAllGlobalIndex() const { XPETRA_MONITOR("TpetraMap::getMinAllGlobalIndex"); return map_->getMinAllGlobalIndex(); }
                
                    //! The maximum global index over all processes in the communicator.
       ##### ->     GlobalOrdinal getMaxAllGlobalIndex() const { XPETRA_MONITOR("TpetraMap::getMaxAllGlobalIndex"); return map_->getMaxAllGlobalIndex(); }
                
                    //! The local index corresponding to the given global index.
       ##### ->     LocalOrdinal getLocalElement(GlobalOrdinal globalIndex) const { XPETRA_MONITOR("TpetraMap::getLocalElement"); return map_->getLocalElement(globalIndex); }
                
                    //! The global index corresponding to the given local index.
       ##### ->     GlobalOrdinal getGlobalElement(LocalOrdinal localIndex) const { XPETRA_MONITOR("TpetraMap::getGlobalElement"); return map_->getGlobalElement(localIndex); }
                
                    //! Return the process IDs and corresponding local IDs for the given global IDs.
       ##### ->     LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList, const Teuchos::ArrayView< LocalOrdinal > &LIDList) const { XPETRA_MONITOR("TpetraMap::getRemoteIndexList"); return toXpetra(map_->getRemoteIndexList(GIDList, nodeIDList, LIDList)); }
                
                    //! Return the process IDs for the given global IDs.
       ##### ->     LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList) const { XPETRA_MONITOR("TpetraMap::getRemoteIndexList"); return toXpetra(map_->getRemoteIndexList(GIDList, nodeIDList)); }
                
                    //! Return a view of the global indices owned by this node.
       ##### ->     Teuchos::ArrayView< const GlobalOrdinal > getNodeElementList() const { XPETRA_MONITOR("TpetraMap::getNodeElementList"); return map_->getNodeElementList(); }
                
                    //@}
                
                    //! @name Boolean tests
                    //@{
                
                    //! True if the local index is valid for this Map on this node, else false.
       ##### ->     bool isNodeLocalElement(LocalOrdinal localIndex) const { XPETRA_MONITOR("TpetraMap::isNodeLocalElement"); return map_->isNodeLocalElement(localIndex); }
                
                    //! True if the global index is found in this Map on this node, else false.
       ##### ->     bool isNodeGlobalElement(GlobalOrdinal globalIndex) const { XPETRA_MONITOR("TpetraMap::isNodeGlobalElement"); return map_->isNodeGlobalElement(globalIndex); }
                
                    //! True if this Map is distributed contiguously, else false.
       ##### ->     bool isContiguous() const { XPETRA_MONITOR("TpetraMap::isContiguous"); return map_->isContiguous(); }
                
                    //! Whether this Map is globally distributed or locally replicated.
       ##### ->     bool isDistributed() const { XPETRA_MONITOR("TpetraMap::isDistributed"); return map_->isDistributed(); }
                
                    //! True if and only if map is compatible with this Map.
       ##### ->     bool isCompatible(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { XPETRA_MONITOR("TpetraMap::isCompatible"); return map_->isCompatible(toTpetra(map)); }
                
                    //! True if and only if map is identical to this Map.
       ##### ->     bool isSameAs(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { XPETRA_MONITOR("TpetraMap::isSameAs"); return map_->isSameAs(toTpetra(map)); }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Get this Map's Comm object.
          11 ->     Teuchos::RCP< const Teuchos::Comm< int > >  getComm() const { XPETRA_MONITOR("TpetraMap::getComm"); return map_->getComm(); }
                
                    //! Get this Map's Node object.
       ##### ->     Teuchos::RCP< Node >  getNode() const { XPETRA_MONITOR("TpetraMap::getNode"); return map_->getNode(); }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Return a simple one-line description of this object.
       ##### ->     std::string description() const { XPETRA_MONITOR("TpetraMap::description"); return map_->description(); }
                
                    //! Print this object with the given verbosity level to the given FancyOStream.
       ##### ->     void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { XPETRA_MONITOR("TpetraMap::describe"); map_->describe(out, verbLevel); }
                
       ##### ->     RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > removeEmptyProcesses () const {
                      return toXpetra(map_->removeEmptyProcesses());
                    }
       ##### ->     RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > replaceCommWithSubset (const Teuchos::RCP<const Teuchos::Comm<int> >& newComm) const {
                      return toXpetra(map_->replaceCommWithSubset(newComm));
                    }
                
                    template<class Node2>
                    RCP<Map<LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const {
                      return toXpetraNonConst(map_->clone(node2));
                    }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMap constructor to wrap a Tpetra::Map object
                    TpetraMap(const Teuchos::RCP<const Tpetra::Map<LocalOrdinal, GlobalOrdinal, Node > > &map)
                      : map_(map) { }
                
                    //! Get the library used by this object (Tpetra or Epetra?)
           4 ->     UnderlyingLib lib() const { return UseTpetra; }
                
                    //! Get the underlying Tpetra map
                    RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > getTpetra_Map() const { return map_; }
                
                    //@}
                
                  protected:
                
                    RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > map_;
                
                  }; // TpetraMap class
                
                  // TODO: move that elsewhere
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> & toTpetra(const Map<LocalOrdinal,GlobalOrdinal,Node> &map) {
                    // TODO: throw exception
                    const TpetraMap<LocalOrdinal,GlobalOrdinal,Node> & tpetraMap = dynamic_cast<const TpetraMap<LocalOrdinal,GlobalOrdinal,Node> &>(*map.getMap());
                    return *tpetraMap.getTpetra_Map();
                  }
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
           1 ->   const RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > toTpetra(const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map) {
                    typedef TpetraMap<LocalOrdinal, GlobalOrdinal, Node> TpetraMapClass;
                    if (map != Teuchos::null) {
                      XPETRA_RCP_DYNAMIC_CAST(const TpetraMapClass, map->getMap(), tpetraMap, "toTpetra");
                      return tpetraMap->getTpetra_Map();
                    }
                    return Teuchos::null;
                  }
                
                  // In some cases (for instance, in MueLu adapter to Tpetra operator), we need to return a reference. This is only possible if
                  // we assume that the map argument is nonzero
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > toTpetraNonZero(const RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > &map) {
                    TEUCHOS_TEST_FOR_EXCEPTION(map.is_null(), std::invalid_argument, "map must be nonzero");
                    typedef TpetraMap<LocalOrdinal, GlobalOrdinal, Node> TpetraMapClass;
                    XPETRA_RCP_DYNAMIC_CAST(const TpetraMapClass, map->getMap(), tpetraMap, "toTpetra");
                    return tpetraMap->getTpetra_Map();
                  }
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> > toXpetra(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >& map) {
                    if (!map.is_null())
                      return rcp(new TpetraMap<LocalOrdinal, GlobalOrdinal, Node>(map));
                
                    return Teuchos::null;
                  }
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<Map<LocalOrdinal,GlobalOrdinal,Node> > toXpetraNonConst(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >& map) {
                    if (!map.is_null())
                      return rcp(new TpetraMap<LocalOrdinal,GlobalOrdinal,Node>(map));
                
                    return Teuchos::null;
                  }
                
                  // TODO: removed (but currently used in unit test)
                  namespace useTpetra {
                
                    //! Non-member function to create a locally replicated Map with a specified node.
                    template <class LocalOrdinal, class GlobalOrdinal, class Node>
                    Teuchos::RCP< const TpetraMap<LocalOrdinal,GlobalOrdinal,Node> >
                    createLocalMapWithNode(size_t numElements, const Teuchos::RCP< const Teuchos::Comm< int > > &comm, const Teuchos::RCP< Node > &node) {
                      XPETRA_MONITOR("useTpetra::createLocalMapWithNode");
                
                      return rcp(new TpetraMap<LocalOrdinal,GlobalOrdinal,Node>(Tpetra::createLocalMapWithNode<LocalOrdinal,GlobalOrdinal,Node>(numElements, comm, node)));
                    }
                
                    //! Non-member function to create a (potentially) non-uniform, contiguous Map with the default node.
                    template <class LocalOrdinal, class GlobalOrdinal>
                    Teuchos::RCP< const TpetraMap<LocalOrdinal,GlobalOrdinal> >
                    createContigMap(global_size_t numElements, size_t localNumElements, const Teuchos::RCP< const Teuchos::Comm< int > > &comm) {
                      XPETRA_MONITOR("useTpetra::createContigMap");
                
                      return rcp(new TpetraMap<LocalOrdinal,GlobalOrdinal>(Tpetra::createContigMap<LocalOrdinal,GlobalOrdinal>(numElements, localNumElements, comm)));
                    }
                
                    //! Non-member function to create a (potentially) non-uniform, contiguous Map with a user-specified node.
                    template <class LocalOrdinal, class GlobalOrdinal, class Node>
                    Teuchos::RCP< const TpetraMap<LocalOrdinal,GlobalOrdinal,Node> >
                    createContigMapWithNode(global_size_t numElements, size_t localNumElements,
                                            const Teuchos::RCP< const Teuchos::Comm< int > > &comm, const Teuchos::RCP< Node > &node) {
                      XPETRA_MONITOR("useTpetra::createContigMap");
                      return rcp(new TpetraMap<LocalOrdinal,GlobalOrdinal,Node>(Tpetra::createContigMapWithNode<LocalOrdinal,GlobalOrdinal,Node>(numElements, localNumElements, comm, node)));
                    }
                  } // useTpetra namespace
                
                  // TODO: move that elsewhere
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node>&             toTpetra(const Xpetra::Map<LocalOrdinal,GlobalOrdinal,Node>&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node > > toTpetra(const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<const Map<LocalOrdinal,GlobalOrdinal,Node > >         toXpetra(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                
                  template <class LocalOrdinal, class GlobalOrdinal, class Node>
                  const RCP<Map<LocalOrdinal,GlobalOrdinal,Node > >               toXpetraNonConst(const RCP<const Tpetra::Map<LocalOrdinal,GlobalOrdinal,Node> >&);
                
                #ifdef HAVE_XPETRA_EPETRA
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_INT))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_INT))))
                
                  // specialization for Tpetra Map on EpetraNode and GO=int
                  template <>
                  class TpetraMap<int, int, EpetraNode>
                    : public virtual Map<int,int,EpetraNode> {
                
                  public:
                    typedef int GlobalOrdinal;
                    typedef int LocalOrdinal;
                    typedef EpetraNode Node;
                
                    static Teuchos::RCP<Node> defaultArgNode() {
                        // Workaround function for a deferred visual studio bug
                        // http://connect.microsoft.com/VisualStudio/feedback/details/719847/erroneous-error-c2783-could-not-deduce-template-argument
                        // Use this function for default arguments rather than calling
                        // what is the return value below.  Also helps in reducing
                        // duplication in various constructors.
                        return KokkosClassic::Details::getNode<Node>();
                    }
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Constructor with Tpetra-defined contiguous uniform distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               LocalGlobal lg=GloballyDistributed,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor with a user-defined contiguous distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               size_t numLocalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor with user-defined arbitrary (possibly noncontiguous) distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               const Teuchos::ArrayView< const GlobalOrdinal > &elementList,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Destructor.
                    ~TpetraMap() {  }
                
                    //@}
                
                    //! @name Attributes
                    //@{
                
                    //! The number of elements in this Map.
                    global_size_t getGlobalNumElements() const { return 0; }
                
                    //! The number of elements belonging to the calling node.
                    size_t getNodeNumElements() const { return 0; }
                
                    //! The index base for this Map.
                    GlobalOrdinal getIndexBase() const { return 0; }
                
                    //! The minimum local index.
                    LocalOrdinal getMinLocalIndex() const { return 0; }
                
                    //! The maximum local index on the calling process.
                    LocalOrdinal getMaxLocalIndex() const { return 0; }
                
                    //! The minimum global index owned by the calling process.
                    GlobalOrdinal getMinGlobalIndex() const { return 0; }
                
                    //! The maximum global index owned by the calling process.
                    GlobalOrdinal getMaxGlobalIndex() const { return 0; }
                
                    //! The minimum global index over all processes in the communicator.
                    GlobalOrdinal getMinAllGlobalIndex() const { return 0; }
                
                    //! The maximum global index over all processes in the communicator.
                    GlobalOrdinal getMaxAllGlobalIndex() const { return 0; }
                
                    //! The local index corresponding to the given global index.
                    LocalOrdinal getLocalElement(GlobalOrdinal globalIndex) const { return 0; }
                
                    //! The global index corresponding to the given local index.
                    GlobalOrdinal getGlobalElement(LocalOrdinal localIndex) const { return 0; }
                
                    //! Return the process IDs and corresponding local IDs for the given global IDs.
                    LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList, const Teuchos::ArrayView< LocalOrdinal > &LIDList) const { return Xpetra::IDNotPresent; }
                
                    //! Return the process IDs for the given global IDs.
                    LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList) const { return Xpetra::IDNotPresent; }
                
                    //! Return a view of the global indices owned by this node.
                    Teuchos::ArrayView< const GlobalOrdinal > getNodeElementList() const { return Teuchos::ArrayView<const GlobalOrdinal>(); }
                
                    //@}
                
                    //! @name Boolean tests
                    //@{
                
                    //! True if the local index is valid for this Map on this node, else false.
                    bool isNodeLocalElement(LocalOrdinal localIndex) const { return false; }
                
                    //! True if the global index is found in this Map on this node, else false.
                    bool isNodeGlobalElement(GlobalOrdinal globalIndex) const { return false; }
                
                    //! True if this Map is distributed contiguously, else false.
                    bool isContiguous() const { return false; }
                
                    //! Whether this Map is globally distributed or locally replicated.
                    bool isDistributed() const { return false; }
                
                    //! True if and only if map is compatible with this Map.
                    bool isCompatible(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { return false; }
                
                    //! True if and only if map is identical to this Map.
                    bool isSameAs(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { return false; }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Get this Map's Comm object.
                    Teuchos::RCP< const Teuchos::Comm< int > >  getComm() const { return Teuchos::null; }
                
                    //! Get this Map's Node object.
                    Teuchos::RCP< Node >  getNode() const { return Teuchos::null; }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Return a simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print this object with the given verbosity level to the given FancyOStream.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > removeEmptyProcesses () const { return Teuchos::null; }
                    RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > replaceCommWithSubset (const Teuchos::RCP<const Teuchos::Comm<int> >& newComm) const { return Teuchos::null; }
                
                    template<class Node2>
                    RCP<Map<LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMap constructor to wrap a Tpetra::Map object
                    TpetraMap(const Teuchos::RCP<const Tpetra::Map<LocalOrdinal, GlobalOrdinal, Node > > &map) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "int", typeid(EpetraNode).name() );
                    }
                
                    //! Get the library used by this object (Tpetra or Epetra?)
                    UnderlyingLib lib() const { return UseTpetra; }
                
                    //! Get the underlying Tpetra map
                    RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > getTpetra_Map() const { return Teuchos::null; }
                
                    //@}
                
                  }; // TpetraMap class (specialization for GO=int and NO=EpetraNode)
                #endif
                
                #if ((defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_OPENMP) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))) || \
                    (!defined(EPETRA_HAVE_OMP) && (!defined(HAVE_TPETRA_INST_SERIAL) || !defined(HAVE_TPETRA_INST_INT_LONG_LONG))))
                  // specialization for Tpetra Map on EpetraNode and GO=int
                  template <>
                  class TpetraMap<int, long long, EpetraNode>
                    : public virtual Map<int,long long,EpetraNode> {
                
                  public:
                    typedef long long GlobalOrdinal;
                    typedef int LocalOrdinal;
                    typedef EpetraNode Node;
                
                    static Teuchos::RCP<Node> defaultArgNode() {
                        // Workaround function for a deferred visual studio bug
                        // http://connect.microsoft.com/VisualStudio/feedback/details/719847/erroneous-error-c2783-could-not-deduce-template-argument
                        // Use this function for default arguments rather than calling
                        // what is the return value below.  Also helps in reducing
                        // duplication in various constructors.
                        return KokkosClassic::Details::getNode<Node>();
                    }
                
                    //! @name Constructors and destructor
                    //@{
                
                    //! Constructor with Tpetra-defined contiguous uniform distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               LocalGlobal lg=GloballyDistributed,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor with a user-defined contiguous distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               size_t numLocalElements,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Constructor with user-defined arbitrary (possibly noncontiguous) distribution.
                    TpetraMap (global_size_t numGlobalElements,
                               const Teuchos::ArrayView< const GlobalOrdinal > &elementList,
                               GlobalOrdinal indexBase,
                               const Teuchos::RCP< const Teuchos::Comm< int > > &comm,
                               const Teuchos::RCP< Node > &node = defaultArgNode()) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Destructor.
                    ~TpetraMap() {  }
                
                    //@}
                
                    //! @name Attributes
                    //@{
                
                    //! The number of elements in this Map.
                    global_size_t getGlobalNumElements() const { return 0; }
                
                    //! The number of elements belonging to the calling node.
                    size_t getNodeNumElements() const { return 0; }
                
                    //! The index base for this Map.
                    GlobalOrdinal getIndexBase() const { return 0; }
                
                    //! The minimum local index.
                    LocalOrdinal getMinLocalIndex() const { return 0; }
                
                    //! The maximum local index on the calling process.
                    LocalOrdinal getMaxLocalIndex() const { return 0; }
                
                    //! The minimum global index owned by the calling process.
                    GlobalOrdinal getMinGlobalIndex() const { return 0; }
                
                    //! The maximum global index owned by the calling process.
                    GlobalOrdinal getMaxGlobalIndex() const { return 0; }
                
                    //! The minimum global index over all processes in the communicator.
                    GlobalOrdinal getMinAllGlobalIndex() const { return 0; }
                
                    //! The maximum global index over all processes in the communicator.
                    GlobalOrdinal getMaxAllGlobalIndex() const { return 0; }
                
                    //! The local index corresponding to the given global index.
                    LocalOrdinal getLocalElement(GlobalOrdinal globalIndex) const { return 0; }
                
                    //! The global index corresponding to the given local index.
                    GlobalOrdinal getGlobalElement(LocalOrdinal localIndex) const { return 0; }
                
                    //! Return the process IDs and corresponding local IDs for the given global IDs.
                    LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList, const Teuchos::ArrayView< LocalOrdinal > &LIDList) const { return Xpetra::IDNotPresent; }
                
                    //! Return the process IDs for the given global IDs.
                    LookupStatus getRemoteIndexList(const Teuchos::ArrayView< const GlobalOrdinal > &GIDList, const Teuchos::ArrayView< int > &nodeIDList) const { return Xpetra::IDNotPresent; }
                
                    //! Return a view of the global indices owned by this node.
                    Teuchos::ArrayView< const GlobalOrdinal > getNodeElementList() const { return Teuchos::ArrayView<const GlobalOrdinal>(); }
                
                    //@}
                
                    //! @name Boolean tests
                    //@{
                
                    //! True if the local index is valid for this Map on this node, else false.
                    bool isNodeLocalElement(LocalOrdinal localIndex) const { return false; }
                
                    //! True if the global index is found in this Map on this node, else false.
                    bool isNodeGlobalElement(GlobalOrdinal globalIndex) const { return false; }
                
                    //! True if this Map is distributed contiguously, else false.
                    bool isContiguous() const { return false; }
                
                    //! Whether this Map is globally distributed or locally replicated.
                    bool isDistributed() const { return false; }
                
                    //! True if and only if map is compatible with this Map.
                    bool isCompatible(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { return false; }
                
                    //! True if and only if map is identical to this Map.
                    bool isSameAs(const Map< LocalOrdinal, GlobalOrdinal, Node > &map) const { return false; }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Get this Map's Comm object.
                    Teuchos::RCP< const Teuchos::Comm< int > >  getComm() const { return Teuchos::null; }
                
                    //! Get this Map's Node object.
                    Teuchos::RCP< Node >  getNode() const { return Teuchos::null; }
                
                    //@}
                
                    //! @name
                    //@{
                
                    //! Return a simple one-line description of this object.
                    std::string description() const { return std::string(""); }
                
                    //! Print this object with the given verbosity level to the given FancyOStream.
                    void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default) const { }
                
                    RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > removeEmptyProcesses () const { return Teuchos::null; }
                    RCP<const Map<LocalOrdinal, GlobalOrdinal, Node> > replaceCommWithSubset (const Teuchos::RCP<const Teuchos::Comm<int> >& newComm) const { return Teuchos::null; }
                
                    template<class Node2>
                    RCP<Map<LocalOrdinal, GlobalOrdinal, Node2> > clone(const RCP<Node2> &node2) const { return Teuchos::null; }
                
                    //@}
                
                    //! @name Xpetra specific
                    //@{
                
                    //! TpetraMap constructor to wrap a Tpetra::Map object
                    TpetraMap(const Teuchos::RCP<const Tpetra::Map<LocalOrdinal, GlobalOrdinal, Node > > &map) {
                      XPETRA_TPETRA_ETI_EXCEPTION( typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name() , typeid(TpetraMap<LocalOrdinal,GlobalOrdinal,EpetraNode>).name(), "long long", typeid(EpetraNode).name() );
                    }
                
                    //! Get the library used by this object (Tpetra or Epetra?)
                    UnderlyingLib lib() const { return UseTpetra; }
                
                    //! Get the underlying Tpetra map
                    RCP< const Tpetra::Map< LocalOrdinal, GlobalOrdinal, Node > > getTpetra_Map() const { return Teuchos::null; }
                
                    //@}
                  }; // TpetraMap class (specialization for GO=int and NO=EpetraNode)
                #endif
                
                #endif // HAVE_XPETRA_EPETRA
                
                } // Xpetra namespace
                
                // TODO: remove?
                //!  Returns true if \c map is identical to this map. Implemented in TpetraMap::isSameAs().
                template <class LocalOrdinal, class GlobalOrdinal, class Node>
                bool operator== (const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node> &map1, const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node> &map2) {
                  XPETRA_MONITOR("TpetraMap==TpetraMap");
                  return map1.isSameAs(map2);
                }
                
                //! Returns true if \c map is not identical to this map. Implemented in TpetraMap::isSameAs().
                template <class LocalOrdinal, class GlobalOrdinal, class Node>
                bool operator!= (const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node> &map1, const Xpetra::TpetraMap<LocalOrdinal,GlobalOrdinal,Node> &map2) {
                  XPETRA_MONITOR("TpetraMap!=TpetraMap");
                  return !map1.isSameAs(map2);
                }
                
                #define XPETRA_TPETRAMAP_SHORT
                #endif // XPETRA_TPETRAMAP_HPP


Top 10 Lines:

     Line      Count

      209         11
      145          4
      247          4
      269          1

Execution Summary:

       29   Executable lines in this file
       29   Lines executed
   100.00   Percent of the file executed

       20   Total number of line executions
     0.69   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_RCPNode.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_RCP_NODE_HPP
                #define TEUCHOS_RCP_NODE_HPP
                
                
                /** \file Teuchos_RCPNode.hpp
                 *
                 * \brief Reference-counted pointer node classes.
                 */
                
                
                #include "Teuchos_ConfigDefs.hpp"
                #include "Teuchos_any.hpp"
                #include "Teuchos_map.hpp"
                #include "Teuchos_ENull.hpp"
                #include "Teuchos_Assert.hpp"
                #include "Teuchos_Exceptions.hpp"
                #include "Teuchos_TypeNameTraits.hpp"
                #include "Teuchos_toString.hpp"
                #include "Teuchos_getBaseObjVoidPtr.hpp"
                
                
                namespace Teuchos {
                
                
                /** \brief Used to specify a pre or post destruction of extra data
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };
                
                /** \brief Used to specify if the pointer is weak or strong.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                enum ERCPStrength { RCP_STRONG=0, RCP_WEAK=1 };
                
                /** \brief Used to determine if RCPNode lookup is performed or not.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                enum ERCPNodeLookup { RCP_ENABLE_NODE_LOOKUP, RCP_DISABLE_NODE_LOOKUP };
                
                /** \brief . */
                inline void debugAssertStrength(ERCPStrength strength)
                {
                #ifdef TEUCHOS_DEBUG
                  switch (strength) {
                  case RCP_STRONG:
                    // fall through
                  case RCP_WEAK:
                    return; // Fine
                  default:
                    TEUCHOS_TEST_FOR_EXCEPTION(
                      true, std::logic_error, "Teuchos::RCPNode: ERCPStrength enum value "
                      << strength << " is invalid (neither RCP_STRONG = " << RCP_STRONG
                      << " nor RCP_WEAK = " << RCP_WEAK << ").");
                  }
                #else
                  (void) strength; // Silence "unused variable" compiler warning.
                #endif // TEUCHOS_DEBUG
                }
                
                /** \brief Traits class specialization for <tt>toString(...)</tt> function for
                 * converting from <tt>ERCPStrength</tt> to <tt>std::string</tt>.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                template<>
                class TEUCHOSCORE_LIB_DLL_EXPORT ToStringTraits<ERCPStrength> {
                public:
                  static std::string toString( const ERCPStrength &t )
                    {
                      switch (t) {
                        case RCP_STRONG:
                          return "RCP_STRONG";
                        case RCP_WEAK:
                          return "RCP_WEAK";
                        default:
                          // Should never get here but fall through ...
                          break;
                      }
                      // Should never get here!
                #ifdef TEUCHOS_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPT(true);
                #else
                      return "";
                #endif
                    }
                };
                
                
                /** \brief Node class to keep track of address and the reference count for a
                 * reference-counted utility class and delete the object.
                 *
                 * This is not a general user-level class.  This is used in the implementation
                 * of all of the reference-counting utility classes.
                 *
                 * NOTE: The reference counts all start a 0 so the client (i.e. RCPNodeHandle)
                 * must increment them from 0 after creation.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT RCPNode {
                public:
                  /** \brief . */
                  RCPNode(bool has_ownership_in)
                    : has_ownership_(has_ownership_in), extra_data_map_(NULL)
                #ifdef TEUCHOS_DEBUG
                    ,insertion_number_(-1)
                #endif // TEUCHOS_DEBUG
                    {
                      count_[RCP_STRONG] = 0;
                      count_[RCP_WEAK] = 0;
                    }
                  /** \brief . */
                  virtual ~RCPNode()
                    {
                      if(extra_data_map_)
                        delete extra_data_map_;
                    }
                  /** \brief . */
                  int strong_count() const
                    {
                      return count_[RCP_STRONG];
                    }
                  /** \brief . */
                  int weak_count() const
                    {
                      return count_[RCP_WEAK];
                    }
                  /** \brief . */
                  int incr_count( const ERCPStrength strength )
                    {
                      debugAssertStrength(strength);
                      return ++count_[strength];
                    }
                  /** \brief . */
                  int deincr_count( const ERCPStrength strength )
                    {
                      debugAssertStrength(strength);
                      return --count_[strength];
                    }
                  /** \brief . */
                  void has_ownership(bool has_ownership_in)
                    {
                      has_ownership_ = has_ownership_in;
                    }
                  /** \brief . */
                  bool has_ownership() const
                    {
                      return has_ownership_;
                    }
                  /** \brief . */
                  void set_extra_data(
                    const any &extra_data, const std::string& name,
                    EPrePostDestruction destroy_when, bool force_unique );
                  /** \brief . */
                  any& get_extra_data( const std::string& type_name,
                    const std::string& name );
                  /** \brief . */
                  const any& get_extra_data( const std::string& type_name,
                    const std::string& name
                    ) const
                    {
                      return const_cast<RCPNode*>(this)->get_extra_data(type_name, name);
                    }
                  /** \brief . */
                  any* get_optional_extra_data(const std::string& type_name,
                    const std::string& name );
                  /** \brief . */
                  const any* get_optional_extra_data(
                    const std::string& type_name, const std::string& name
                    ) const
                    {
                      return const_cast<RCPNode*>(this)->get_optional_extra_data(type_name, name);
                    }
                  /** \brief . */
                  virtual bool is_valid_ptr() const = 0;
                  /** \brief . */
                  virtual void delete_obj() = 0;
                  /** \brief . */
                  virtual void throw_invalid_obj_exception(
                    const std::string& rcp_type_name,
                    const void* rcp_ptr,
                    const RCPNode* rcp_node_ptr,
                    const void* rcp_obj_ptr
                    ) const = 0;
                  /** \brief . */
                  virtual const std::string get_base_obj_type_name() const = 0;
                #ifdef TEUCHOS_DEBUG
                  /** \brief . */
                  virtual const void* get_base_obj_map_key_void_ptr() const = 0;
                #endif
                protected:
                  /** \brief . */
                  void pre_delete_extra_data()
                    {
                      if(extra_data_map_)
                        impl_pre_delete_extra_data();
                    }
                private:
                  struct extra_data_entry_t {
                    extra_data_entry_t() : destroy_when(POST_DESTROY) {}
                    extra_data_entry_t( const any &_extra_data, EPrePostDestruction _destroy_when )
                      : extra_data(_extra_data), destroy_when(_destroy_when)
                      {}
                    any extra_data;
                    EPrePostDestruction destroy_when;
                  };
                  typedef Teuchos::map<std::string,extra_data_entry_t> extra_data_map_t;
                  int count_[2];
                  bool has_ownership_;
                  extra_data_map_t *extra_data_map_;
                  // Above is made a pointer to reduce overhead for the general case when this
                  // is not used.  However, this adds just a little bit to the overhead when
                  // it is used.
                  // Provides the "basic" guarantee!
                  void impl_pre_delete_extra_data();
                  // Not defined and not to be called
                  RCPNode();
                  RCPNode(const RCPNode&);
                  RCPNode& operator=(const RCPNode&);
                #ifdef TEUCHOS_DEBUG
                  int insertion_number_;
                public:
                  void set_insertion_number(int insertion_number_in)
                    {
                      insertion_number_ = insertion_number_in;
                    }
                  int insertion_number() const
                    {
                      return insertion_number_;
                    }
                #endif // TEUCHOS_DEBUG
                };
                
                
                /** \brief Throw that a pointer passed into an RCP object is null.
                 *
                 * \relates RCPNode
                 */
                TEUCHOSCORE_LIB_DLL_EXPORT void throw_null_ptr_error( const std::string &type_name );
                
                
                /** \brief Debug-mode RCPNode tracing class.
                 *
                 * This is a static class that is used to trace all RCP nodes that are created
                 * and destroyed and to look-up RCPNodes given an an object's address.  This
                 * database is used for several different types of debug-mode runtime checking
                 * including a) the detection of cicular references, b) detecting the creation
                 * of duplicate owning RCPNode objects for the same reference-counted object,
                 * and c) to create weak RCP objects for existing RCPNode objects.
                 *
                 * This is primarily an internal implementation class but there are a few
                 * functions (maked as such below) that can be called by general users to turn
                 * on and off node tracing and to print the active RCPNode objects at any
                 * time.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT RCPNodeTracer {
                public:
                
                  /** \name Public types. */
                  //@{
                
                  /** \brief RCP statistics struct. */
                  struct RCPNodeStatistics {
                    RCPNodeStatistics()
                      : maxNumRCPNodes(0), totalNumRCPNodeAllocations(0),
                        totalNumRCPNodeDeletions(0)
                      {}
                    long int maxNumRCPNodes;
                    long int totalNumRCPNodeAllocations;
                    long int totalNumRCPNodeDeletions;
                  };
                
                  //@}
                
                  /** \name General user functions (can be called by any client) */
                  //@{
                
                  /** \brief Return if we are tracing active nodes or not.
                   *
                   * NOTE: This will always return <tt>false</tt> when <tt>TEUCHOS_DEBUG</tt> is
                   * not defined.
                   */
                  static bool isTracingActiveRCPNodes();
                
                #if defined(TEUCHOS_DEBUG) && !defined(HAVE_TEUCHOS_DEBUG_RCP_NODE_TRACING)
                  /** \brief Set if will be tracing active RCP nodes.
                   *
                   * This will only cause tracing of RCPNode-based objects that are created
                   * after this has been called with <tt>true</tt>.  This function can later be
                   * called with <tt>false</tt> to turn off tracing RCPNode objects.  This can
                   * allow the client to keep track of RCPNode objects that get created in
                   * specific blocks of code and can help as a debugging aid.
                   *
                   * NOTE: This function call will not even compile unless
                   * <tt>defined(TEUCHOS_DEBUG) &&
                   * !defined(HAVE_TEUCHOS_DEBUG_RCP_NODE_TRACING)<tt>.  This occurs when
                   * Teuchos is configured with <tt>Teuchos_ENABLE_DEBUG=ON</tt> but with
                   * <tt>Teuchos_ENABLE_DEBUG_RCP_NODE_TRACING=OFF</tt>.  The motivation for
                   * this logic is that if debug support is not enabled, then node tracing can
                   * not be enbled.  If node tracing is turned on at configure time then there
                   * is no sense in trying to turn it on or off.
                   */
                  static void setTracingActiveRCPNodes(bool tracingActiveNodes);
                #endif
                
                  /** \brief Print the number of active RCPNode objects currently being
                   * tracked.
                   */
                  static int numActiveRCPNodes();
                
                  /** \brief Return the statistics on RCPNode allocations. */
                  static RCPNodeStatistics getRCPNodeStatistics() ;
                
                  /** \brief Print the RCPNode allocation statistics. */
                  static void printRCPNodeStatistics(
                    const RCPNodeStatistics& rcpNodeStatistics, std::ostream &out);
                
                  /** \brief Set if RCPNode usage statistics will be printed when the program
                   * ends or not.
                   */
                  static void setPrintRCPNodeStatisticsOnExit(
                    bool printRCPNodeStatisticsOnExit);
                
                  /** \brief Return if RCPNode usage statistics will be printed when the
                   * program ends or not.
                   */
                  static bool getPrintRCPNodeStatisticsOnExit();
                
                  /** \brief Set if printActiveRCPNodes() is called on exit from the
                   * program.
                   */
                  static void setPrintActiveRcpNodesOnExit(bool printActiveRcpNodesOnExit);
                
                  /** \brief Return if printActiveRCPNodes() is called on exit from the
                   * program.
                   */
                  static bool getPrintActiveRcpNodesOnExit();
                
                  /** \brief Print the list of currently active RCP nodes.
                   *
                   * When the macro <tt>TEUCHOS_SHOW_ACTIVE_REFCOUNTPTR_NODE_TRACE</tt> is
                   * defined, this function will print out all of the RCP nodes that are
                   * currently active.  This function can be called at any time during a
                   * program.
                   *
                   * When the macro <tt>TEUCHOS_SHOW_ACTIVE_REFCOUNTPTR_NODE_TRACE</tt> is
                   * defined this function will get called automatically after the program
                   * ends by default and all of the local and global RCP objects have been
                   * destroyed.  If any RCP nodes are printed at that time, then this is an
                   * indication that there may be some circular references that will caused
                   * memory leaks.  You memory checking tool such as valgrind or purify should
                   * complain about this!
                   */
                  static void printActiveRCPNodes(std::ostream &out);
                
                  //@}
                
                  /** \name Internal implementation functions (not to be called by general
                   * clients).
                   */
                  //@{
                
                  /** \brief Add new RCPNode to the global list.
                   *
                   * Only gets called when RCPNode tracing has been activated.
                   */
                  static void addNewRCPNode(RCPNode* rcp_node,
                    const std::string &info );
                
                  /** \brief Remove an RCPNode from global list.
                   *
                   * Always gets called in a debug build (<tt>TEUCHOS_DEBUG</tt> defined) when
                   * node tracing is enabled.
                   */
                  static void removeRCPNode( RCPNode* rcp_node );
                
                  /** \brief Get a <tt>const void*</tt> address to be used as the lookup key
                   * for an RCPNode given its embedded object's typed pointer.
                   *
                   * This only returns the base address reliabily for all types if
                   * <tt>HAS_TEUCHOS_GET_BASE_OBJ_VOID_PTR</tt> is defined.
                   *
                   * \returns <tt>0</tt> if <tt>p == 0</tt>.
                   */
                  template<class T>
                  static const void* getRCPNodeBaseObjMapKeyVoidPtr(T *p)
                    {
                #ifdef HAS_TEUCHOS_GET_BASE_OBJ_VOID_PTR
                      return getBaseObjVoidPtr(p);
                #else
                      // This will not return the base address for polymorphic types if
                      // multiple inheritance and/or virtual bases are used but returning the
                      // static_cast should be okay in how it is used.  It is just that the
                      // RCPNode tracing support will not always be able to figure out if two
                      // pointers of different type are pointing to the same object or not.
                      return static_cast<const void*>(p);
                #endif
                    }
                
                  /** \brief Return a raw pointer to an existing owning RCPNode given its
                   * lookup key.
                   *
                   * \returns <tt>returnVal != 0</tt> if an owning RCPNode exists, <tt>0</tt>
                   * otherwsise.
                   */
                  static RCPNode* getExistingRCPNodeGivenLookupKey(
                    const void* lookupKey);
                
                  /** \brief Return a raw pointer to an existing owning RCPNode given the
                   * address to the underlying object if it exits.
                   *
                   * \returns <tt>returnVal != 0</tt> if an owning RCPNode exists, <tt>0</tt>
                   * otherwsise.
                   */
                  template<class T>
                  static RCPNode* getExistingRCPNode(T *p)
                    {
                      return getExistingRCPNodeGivenLookupKey(getRCPNodeBaseObjMapKeyVoidPtr(p));
                    }
                
                  /** \brief Header string used in printActiveRCPNodes(). */
                  static std::string getActiveRCPNodeHeaderString();
                
                  /** \brief Common error message string on how to debug RCPNode problems. */
                  static std::string getCommonDebugNotesString();
                
                  //@}
                
                };
                
                
                #ifdef TEUCHOS_DEBUG
                #  define TEUCHOS_RCP_INSERION_NUMBER_STR() \
                      "  insertionNumber:      " << rcp_node_ptr->insertion_number() << "\n"
                #else
                #  define TEUCHOS_RCP_INSERION_NUMBER_STR()
                #endif
                
                
                /** \brief Templated implementation class of <tt>RCPNode</tt> that has the
                 * responsibility for deleting the reference-counted object.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                template<class T, class Dealloc_T>
                class RCPNodeTmpl : public RCPNode {
                public:
                  /** \brief For defined types. */
                  RCPNodeTmpl(T* p, Dealloc_T dealloc, bool has_ownership_in)
                    : RCPNode(has_ownership_in), ptr_(p),
                #ifdef TEUCHOS_DEBUG
                      base_obj_map_key_void_ptr_(RCPNodeTracer::getRCPNodeBaseObjMapKeyVoidPtr(p)),
                      deleted_ptr_(0),
                #endif
                      dealloc_(dealloc)
                    {}
                  /** \brief For undefined types . */
                  RCPNodeTmpl(T* p, Dealloc_T dealloc, bool has_ownership_in, ENull)
                    : RCPNode(has_ownership_in), ptr_(p),
                #ifdef TEUCHOS_DEBUG
                      base_obj_map_key_void_ptr_(0),
                      deleted_ptr_(0),
                #endif
                      dealloc_(dealloc)
                    {}
                  /** \brief . */
                  Dealloc_T& get_nonconst_dealloc()
                    { return dealloc_; }
                  /** \brief . */
                  const Dealloc_T& get_dealloc() const
                    { return dealloc_; }
                  /** \brief . */
         173 ->   ~RCPNodeTmpl()
                    {
                #ifdef TEUCHOS_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPTION( ptr_!=0, std::logic_error,
                        "Error, the underlying object must be explicitly deleted before deleting"
                        " the node object!" );
                #endif
                    }
                  /** \brief . */
       ##### ->   virtual bool is_valid_ptr() const
                    {
                      return ptr_ != 0;
                    }
                  /** \brief Delete the underlying object.
                   *
                   * Provides the "strong guarantee" when exceptions are thrown in debug mode
                   * and but may not even provide the "basic guarantee" in release mode.  .
                   */
         173 ->   virtual void delete_obj()
                    {
                      if (ptr_!= 0) {
                        this->pre_delete_extra_data(); // May throw!
                        T* tmp_ptr = ptr_;
                #ifdef TEUCHOS_DEBUG
                        deleted_ptr_ = tmp_ptr;
                #endif
                        ptr_ = 0;
                        if (has_ownership()) {
                #ifdef TEUCHOS_DEBUG
                          try {
                #endif
                            dealloc_.free(tmp_ptr);
                #ifdef TEUCHOS_DEBUG
                          }
                          catch(...) {
                            // Object was not deleted due to an exception!
                            ptr_ = tmp_ptr;
                            throw;
                          }
                #endif
                        }
                        // 2008/09/22: rabartl: Above, we have to be careful to set the member
                        // this->ptr_=0 before calling delete on the object's address in order
                        // to avoid a double call to delete in cases of circular references
                        // involving weak and strong pointers (see the unit test
                        // circularReference_c_then_a in RCP_UnitTests.cpp).  NOTE: It is
                        // critcial that no member of *this get accesses after
                        // dealloc_.free(...) gets called!  Also, in order to provide the
                        // "strong" guarantee we have to include the above try/catch.  This
                        // overhead is unfortunate but I don't know of any other way to
                        // statisfy the "strong" guarantee and still avoid a double delete.
                      }
                    }
                  /** \brief . */
       ##### ->   virtual void throw_invalid_obj_exception(
                    const std::string& rcp_type_name,
                    const void* rcp_ptr,
                    const RCPNode* rcp_node_ptr,
                    const void* rcp_obj_ptr
                    ) const
                    {
                      TEUCHOS_TEST_FOR_EXCEPT_MSG( ptr_!=0, "Internal coding error!" );
                      const T* deleted_ptr =
                #ifdef TEUCHOS_DEBUG
                        deleted_ptr_
                #else
                        0
                #endif
                        ;
                      TEUCHOS_ASSERT(rcp_node_ptr);
                      TEUCHOS_TEST_FOR_EXCEPTION( true, DanglingReferenceError,
                        "Error, an attempt has been made to dereference the underlying object\n"
                        "from a weak smart pointer object where the underling object has already\n"
                        "been deleted since the strong count has already gone to zero.\n"
                        "\n"
                        "Context information:\n"
                        "\n"
                        "  RCP type:             " << rcp_type_name << "\n"
                        "  RCP address:          " << rcp_ptr << "\n"
                        "  RCPNode type:         " << typeName(*this) << "\n"
                        "  RCPNode address:      " << rcp_node_ptr << "\n"
                        TEUCHOS_RCP_INSERION_NUMBER_STR()
                        "  RCP ptr address:      " << rcp_obj_ptr << "\n"
                        "  Concrete ptr address: " << deleted_ptr << "\n"
                        "\n"
                        << RCPNodeTracer::getCommonDebugNotesString()
                        );
                      // 2008/09/22: rabartl: Above, we do not provide the concreate object
                      // type or the concrete object address.  In the case of the concrete
                      // object address, in a non-debug build, we don't want to pay a price
                      // for extra storage that we strictly don't need.  In the case of the
                      // concrete object type name, we don't want to force non-debug built
                      // code to have the require that types be fully defined in order to use
                      // the memory management software.  This is related to bug 4016.
                
                    }
                  /** \brief . */
       ##### ->   const std::string get_base_obj_type_name() const
                    {
                #ifdef TEUCHOS_DEBUG
                      return TypeNameTraits<T>::name();
                #else
                      return "UnknownType";
                #endif
                    }
                #ifdef TEUCHOS_DEBUG
                  /** \brief . */
                  const void* get_base_obj_map_key_void_ptr() const
                    {
                      return base_obj_map_key_void_ptr_;
                    }
                #endif
                private:
                  T *ptr_;
                #ifdef TEUCHOS_DEBUG
                  const void *base_obj_map_key_void_ptr_;
                  T *deleted_ptr_;
                #endif
                  Dealloc_T dealloc_;
                  // not defined and not to be called
                  RCPNodeTmpl();
                  RCPNodeTmpl(const RCPNodeTmpl&);
                  RCPNodeTmpl& operator=(const RCPNodeTmpl&);
                
                }; // end class RCPNodeTmpl<T>
                
                
                /** \brief Sets up node tracing and prints remaining RCPNodes on destruction.
                 *
                 * This class is used by automataic code that sets up support for RCPNode
                 * tracing and for printing of remaining nodes on destruction.
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT ActiveRCPNodesSetup {
                public:
                  /** \brief . */
                  ActiveRCPNodesSetup();
                  /** \brief . */
                  ~ActiveRCPNodesSetup();
                  /** \brief . */
                  void foo();
                private:
                  static int count_;
                };
                
                
                } // namespace Teuchos
                
                
                namespace {
                // This static variable is declared before all other static variables that
                // depend on RCP or other classes. Therefore, this static variable will be
                // deleted *after* all of these other static variables that depend on RCP or
                // created classes go away!  This ensures that the node tracing machinery is
                // setup and torn down correctly (this is the same trick used by the standard
                // stream objects in many compiler implementations).
                Teuchos::ActiveRCPNodesSetup local_activeRCPNodesSetup;
                } // namespace (anonymous)
                
                
                namespace Teuchos {
                
                /** \class RCPNodeHandle
                 * \brief Handle class that manages the RCPNode's reference counting.
                 *
                 * \warning This class is <i>not</i> intended for Teuchos users.  It
                 *   is an implementation detail of Teuchos' reference-counting
                 *   "smart" pointer (RCP) and array (ArrayRCP) classes.
                 *
                 * NOTE: I (Ross Bartlett) am not generally a big fan of handle classes and
                 * greatly prefer smart pointers.  However, this is one case where a handle
                 * class makes sense.  First, I want special behavior in some functions when
                 * the wrapped RCPNode pointer is null.  Second, I can't use one of the
                 * smart-pointer classes because this class is used to implement all of those
                 * smart-pointer classes!
                 *
                 * \ingroup teuchos_mem_mng_grp
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT RCPNodeHandle {
                public:
                  //! Default constructor
                  RCPNodeHandle (ENull null_arg = null)
                    : node_ (0), strength_ (RCP_STRONG)
                  {
                    (void) null_arg; // Silence "unused variable" compiler warning.
                  }
                
                  //! Constructor that takes a pointer to an RCPNode.
                  RCPNodeHandle (RCPNode* node,
                                 ERCPStrength strength_in = RCP_STRONG,
                                 bool newNode = true)
                    : node_ (node), strength_ (strength_in)
                  {
                #ifdef TEUCHOS_DEBUG
                    TEUCHOS_ASSERT(node);
                #endif // TEUCHOS_DEBUG
                
                    bind();
                
                #ifdef TEUCHOS_DEBUG
                    // Add the node if this is the first RCPNodeHandle to get it.  We have
                    // to add it because unbind() will call the remove_RCPNode(...) function
                    // and it needs to match when node tracing is on from the beginning.
                    if (RCPNodeTracer::isTracingActiveRCPNodes() && newNode) {
                      std::ostringstream os;
                      os << "{T=Unknown, ConcreteT=Unknown, p=Unknown,"
                         << " has_ownership="<<node_->has_ownership()<<"}";
                      RCPNodeTracer::addNewRCPNode(node_, os.str());
                    }
                #else
                    (void) newNode; // Silence "unused variable" compiler warning.
                #endif // TEUCHOS_DEBUG
                  }
                
                #ifdef TEUCHOS_DEBUG
                  /** \brief Only gets called in debug mode. */
                  template<typename T>
                  RCPNodeHandle (RCPNode* node, T *p, const std::string &T_name,
                                 const std::string &ConcreteT_name,
                                 const bool has_ownership_in,
                                 ERCPStrength strength_in = RCP_STRONG)
                    : node_ (node), strength_ (strength_in)
                  {
                    TEUCHOS_ASSERT(strength_in == RCP_STRONG); // Can't handle weak yet!
                    TEUCHOS_ASSERT(node_);
                    bind();
                    if (RCPNodeTracer::isTracingActiveRCPNodes()) {
                      std::ostringstream os;
                      os << "{T="<<T_name<<", ConcreteT="<< ConcreteT_name
                         <<", p="<<static_cast<const void*>(p)
                         <<", has_ownership="<<has_ownership_in<<"}";
                      RCPNodeTracer::addNewRCPNode(node_, os.str());
                    }
                  }
                #endif // TEUCHOS_DEBUG
                
                  //! Copy constructor
                  RCPNodeHandle (const RCPNodeHandle& node_ref)
                    : node_ (node_ref.node_), strength_ (node_ref.strength_)
                  {
                    bind();
                  }
                
                  //! Swap the contents of \c node_ref with \c *this.
                  void swap (RCPNodeHandle& node_ref) {
                    std::swap (node_ref.node_, node_);
                    std::swap (node_ref.strength_, strength_);
                  }
                
                  /// \brief Assignment operator.
                  ///
                  /// This method satisfies the strong exception guarantee: It either
                  /// returns successfully, or throws an exception without modifying
                  /// any user-visible state.
                  RCPNodeHandle& operator= (const RCPNodeHandle& node_ref) {
                    // Assignment to self check: Note, We don't need to do an assigment to
                    // self check here because such a check is already done in the RCP and
                    // ArrayRCP classes.
                    // Take care of this's existing node and object
                    unbind(); // May throw in some cases
                    // Assign the new node
                    node_ = node_ref.node_;
                    strength_ = node_ref.strength_;
                    bind();
                    // Return
                    return *this;
                  }
                
                  //! Destructor
                  ~RCPNodeHandle() {
                    unbind();
                  }
                
                  //! Return a weak handle.
                  RCPNodeHandle create_weak() const {
                    if (node_) {
                      return RCPNodeHandle(node_, RCP_WEAK, false);
                    }
                    return RCPNodeHandle();
                  }
                  //! Return a strong handle.
                  RCPNodeHandle create_strong() const {
                    if (node_) {
                      return RCPNodeHandle(node_, RCP_STRONG, false);
                    }
                    return RCPNodeHandle();
                  }
                  //! Return a pointer to the underlying RCPNode.
                  RCPNode* node_ptr() const {
                    return node_;
                  }
                  //! Whether the underlying RCPNode is NULL.
                  bool is_node_null() const {
                    return node_==0;
                  }
                  /// \brief Whether the underlying pointer is valid.
                  ///
                  /// \note NULL is a valid pointer; this method returns true in that case.
                  bool is_valid_ptr() const {
                    if (node_) {
                      return node_->is_valid_ptr();
                    }
                    return true; // Null is a valid ptr!
                  }
                  /// \brief Whether the RCPNode for which \c node2 is a handle is the
                  ///   same RCPNode as this object's RCPNode.
                  bool same_node(const RCPNodeHandle &node2) const {
                    return node_ == node2.node_;
                  }
                  //! The strong count for this RCPNode, or 0 if the node is NULL.
                  int strong_count() const {
                    if (node_) {
                      return node_->strong_count();
                    }
                    return 0;
                  }
                  //! The weak count for this RCPNode, or 0 if the node is NULL.
                  int weak_count() const {
                    if (node_) {
                      return node_->weak_count();
                    }
                    return 0;
                  }
                  //! The sum of the weak and string counts.
                  int total_count() const {
                    if (node_) {
                      return node_->strong_count() + node_->weak_count();
                    }
                    return 0;
                  }
                  //! The strong count; retained for backwards compatibility.
                  int count() const {
                    if (node_) {
                      return node_->strong_count();
                    }
                    return 0;
                  }
                  //! The strength of this handle.
                  ERCPStrength strength() const {
                    return strength_;
                  }
                  /** \brief . */
                  void has_ownership(bool has_ownership_in)
                    {
                      if (node_)
                        node_->has_ownership(has_ownership_in);
                    }
                  /** \brief . */
                  bool has_ownership() const
                    {
                      if (node_)
                        return node_->has_ownership();
                      return false;
                    }
                  /** \brief . */
                  void set_extra_data(
                    const any &extra_data, const std::string& name,
                    EPrePostDestruction destroy_when, bool force_unique
                    )
                    {
                      debug_assert_not_null();
                      node_->set_extra_data(extra_data, name, destroy_when, force_unique);
                    }
                  /** \brief . */
                  any& get_extra_data( const std::string& type_name,
                    const std::string& name
                    )
                    {
                      debug_assert_not_null();
                      return node_->get_extra_data(type_name, name);
                    }
                  /** \brief . */
                  const any& get_extra_data( const std::string& type_name,
                    const std::string& name
                    ) const
                    {
                      return const_cast<RCPNodeHandle*>(this)->get_extra_data(type_name, name);
                    }
                  /** \brief . */
                  any* get_optional_extra_data(
                    const std::string& type_name, const std::string& name
                    )
                    {
                      debug_assert_not_null();
                      return node_->get_optional_extra_data(type_name, name);
                    }
                  /** \brief . */
                  const any* get_optional_extra_data(
                    const std::string& type_name, const std::string& name
                    ) const
                    {
                      return const_cast<RCPNodeHandle*>(this)->get_optional_extra_data(type_name, name);
                    }
                  /** \brief . */
                  void debug_assert_not_null() const
                    {
                #ifdef TEUCHOS_DEBUG
                      if (!node_)
                        throw_null_ptr_error(typeName(*this));
                #endif
                    }
                  /** \brief . */
                  template<class RCPType>
                  void assert_valid_ptr(const RCPType& rcp_obj) const
                    {
                      if (!node_)
                        return; // Null is a valid pointer!
                      if (!is_valid_ptr()) {
                        node_->throw_invalid_obj_exception( typeName(rcp_obj),
                          this, node_, rcp_obj.access_private_ptr() );
                      }
                    }
                  /** \brief . */
                  template<class RCPType>
                  void debug_assert_valid_ptr(const RCPType& rcp_obj) const
                    {
                #ifdef TEUCHOS_DEBUG
                      assert_valid_ptr(rcp_obj);
                #endif
                    }
                #ifdef TEUCHOS_DEBUG
                  const void* get_base_obj_map_key_void_ptr() const
                    {
                      if (node_)
                        return node_->get_base_obj_map_key_void_ptr();
                      return 0;
                    }
                #endif
                private:
                  RCPNode *node_;
                  ERCPStrength strength_;
                  inline void bind()
                    {
                      if (node_)
                        node_->incr_count(strength_);
                    }
      160029 ->   inline void unbind()
                    {
                      // Optimize this implementation for count > 1
                      if (node_ && node_->deincr_count(strength_)==0) {
                        // If we get here, the reference count has gone to 0 and something
                        // interesting is going to happen.  In this case, we need to
                        // reincrement the count back to 1 and call the more complex function
                        // that will either delete the object or delete the node.
                        node_->incr_count(strength_);
                        unbindOne();
                      }
                      // If we get here, either node_==0 or the count is still greater than 0.
                      // In this case, nothing interesting is going to happen so we are done!
                    }
                  void unbindOne(); // Provides the "strong" guarantee!
                
                };
                
                
                /** \brief Ouput stream operator for RCPNodeHandle.
                 *
                 * \relates RCPNodeHandle
                 */
                inline
                std::ostream& operator<<(std::ostream& out, const RCPNodeHandle& node)
                {
                  // mfh 15 Sep 2015: Make sure that NULL pointers print consistently.
                  // Clang 3.5 likes to print an empty string in that case, while GCC
                  // prints 0.  Thus, we test if the pointer is NULL and print 0 in
                  // that case.  This is important for MueLu tests, which compare
                  // string print-outs.
                  if (node.node_ptr () == NULL) {
                    out << "0";
                  } else {
                    out << node.node_ptr ();
                  }
                  return out;
                }
                
                
                /** \brief Deletes a (non-owning) RCPNode but not it's underlying object in
                 * case of a throw.
                 *
                 * This class is used in contexts where RCPNodeTracer::addNewRCPNode(...)
                 * might thrown an exception for a duplicate node being added.  The assumption
                 * is that there must already be an owning (or non-owning) RCP object that
                 * will delete the underlying object and therefore this class should *not*
                 * call delete_obj()!
                 */
                class TEUCHOSCORE_LIB_DLL_EXPORT RCPNodeThrowDeleter {
                public:
                  /** \brief . */
                  RCPNodeThrowDeleter(RCPNode *node)
                    : node_(node)
                    {}
                  /** \brief Called with node_!=0 when an exception is thrown.
                   *
                   * When an exception is not thrown, the client should have called release()
                   * before this function is called.
                   */
                  ~RCPNodeThrowDeleter()
                    {
                      if (node_) {
                        node_->has_ownership(false); // Avoid actually deleting ptr_
                        node_->delete_obj(); // Sets the pointer ptr_=0 to allow RCPNode delete
                        delete node_;
                      }
                    }
                  /** \brief . */
                  RCPNode* get() const
                    {
                      return node_;
                    }
                  /** \brief Releaes the RCPNode pointer before the destructor is called. */
                  void release()
                    {
                      node_ = 0;
                    }
                private:
                  RCPNode *node_;
                  RCPNodeThrowDeleter(); // Not defined
                  RCPNodeThrowDeleter(const RCPNodeThrowDeleter&); // Not defined
                  RCPNodeThrowDeleter& operator=(const RCPNodeThrowDeleter&); // Not defined
                };
                
                
                //
                // Unit testing support
                //
                
                
                #if defined(TEUCHOS_DEBUG) && !defined(HAVE_TEUCHOS_DEBUG_RCP_NODE_TRACING)
                
                class SetTracingActiveNodesStack {
                public:
                  SetTracingActiveNodesStack()
                    {RCPNodeTracer::setTracingActiveRCPNodes(true);}
                  ~SetTracingActiveNodesStack()
                    {RCPNodeTracer::setTracingActiveRCPNodes(false);}
                };
                
                #  define SET_RCPNODE_TRACING() Teuchos::SetTracingActiveNodesStack setTracingActiveNodesStack;
                
                #else
                
                #  define SET_RCPNODE_TRACING() (void)0
                
                #endif //  defined(TEUCHOS_DEBUG) && !defined(HAVE_TEUCHOS_DEBUG_RCP_NODE_TRACING)
                
                
                } // end namespace Teuchos
                
                
                #endif // TEUCHOS_RCP_NODE_HPP


Top 10 Lines:

     Line      Count

      956     160029
      519        173
      537        173

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

   160375   Total number of line executions
 26729.17   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/Teuchos_DefaultMpiComm.hpp:
                // @HEADER
                // ***********************************************************************
                //
                //                    Teuchos: Common Tools Package
                //                 Copyright (2004) Sandia Corporation
                //
                // Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
                // license for use of this work by or on behalf of the U.S. Government.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ***********************************************************************
                // @HEADER
                
                #ifndef TEUCHOS_MPI_COMM_HPP
                #define TEUCHOS_MPI_COMM_HPP
                
                /// \file Teuchos_DefaultMpiComm.hpp
                /// \brief Implementation of Teuchos wrappers for MPI.
                ///
                /// \warning It only makes sense to include this file if MPI is enabled.
                
                #include <Teuchos_ConfigDefs.hpp>
                
                // If MPI is not enabled, disable the contents of this file.
                #ifdef HAVE_TEUCHOS_MPI
                
                #include "Teuchos_Comm.hpp"
                #include "Teuchos_CommUtilities.hpp"
                #include "Teuchos_OrdinalTraits.hpp"
                #include "Teuchos_OpaqueWrapper.hpp"
                #include "Teuchos_MpiReductionOpSetter.hpp"
                #include "Teuchos_SerializationTraitsHelpers.hpp"
                #include "Teuchos_Workspace.hpp"
                #include "Teuchos_TypeNameTraits.hpp"
                #include "Teuchos_as.hpp"
                #include "Teuchos_Assert.hpp"
                #include "mpi.h"
                #include <iterator>
                
                // This must be defined globally for the whole program!
                //#define TEUCHOS_MPI_COMM_DUMP
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                #  include "Teuchos_VerboseObject.hpp"
                #endif
                
                namespace Teuchos {
                
                //! Human-readable string version of the given MPI error code.
                std::string
                mpiErrorCodeToString (const int err);
                
                namespace details {
                  /// \brief Give \c comm to MPI_Comm_free, if MPI is not yet finalized.
                  ///
                  /// This function "frees" the given communicator by giving it to
                  /// MPI_Comm_free.  It only does so if MPI_Finalize has not yet been
                  /// called.  If MPI_Finalize has been called, this function does
                  /// nothing, since it is not legal to call most MPI functions after
                  /// MPI_Finalize has been called.  This function also ignores any
                  /// errors returned by MPI_Finalize, which makes it suitable for use
                  /// in a destructor.
                  ///
                  /// \note This function may allow a memory leak in your program, if
                  ///   you have allowed the MPI_Comm to persist after MPI_Finalize
                  ///   has been called.
                  void safeCommFree (MPI_Comm* comm);
                
                  /// Set the given communicator's error handler to \c handler.
                  ///
                  /// If the MPI version is >= 2, this calls MPI_Comm_set_handler().
                  /// If the MPI version is 1, this calls MPI_Errhandler_set().
                  int setCommErrhandler (MPI_Comm comm, MPI_Errhandler handler);
                
                } // namespace details
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                template<typename Ordinal, typename T>
                void dumpBuffer(
                  const std::string &funcName, const std::string &buffName
                  ,const Ordinal bytes, const T buff[]
                  )
                {
                  Teuchos::RCP<Teuchos::FancyOStream>
                    out = Teuchos::VerboseObjectBase::getDefaultOStream();
                  Teuchos::OSTab tab(out);
                  *out
                    << "\n" << funcName << "::" << buffName << ":\n";
                  tab.incrTab();
                  for( Ordinal i = 0; i < bytes; ++i ) {
                    *out << buffName << "[" << i << "] = '" << buff[i] << "'\n";
                  }
                  *out << "\n";
                }
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                /// \class MpiCommStatus
                /// \brief MPI-specific implementation of CommStatus.
                ///
                /// Users would not normally create an instance of this class.  The
                /// only time they might wish to do so is to encapsulate an MPI_Status
                /// returned by an external library or by their own code, and pass it
                /// into one of our functions like wait() or waitAll().
                ///
                /// \tparam OrdinalType The same template parameter as \c Comm.  Only
                ///   use \c int here.  We only make this a template class for
                ///   compatibility with \c Comm.
                template<class OrdinalType>
                class MpiCommStatus : public CommStatus<OrdinalType> {
                public:
                  MpiCommStatus (MPI_Status status) : status_ (status) {}
                
                  //! Destructor (declared virtual for memory safety)
       ##### ->   virtual ~MpiCommStatus() {}
                
                  //! The source rank that sent the message.
           4 ->   OrdinalType getSourceRank () { return status_.MPI_SOURCE; }
                
                  //! The tag of the received message.
       ##### ->   OrdinalType getTag () { return status_.MPI_TAG; }
                
                  //! The error code of the received message.
                  OrdinalType getError () { return status_.MPI_ERROR; }
                
                private:
                  //! We forbid default construction syntactically.
                  MpiCommStatus ();
                
                  //! The raw MPI_Status struct that this class encapsulates.
                  MPI_Status status_;
                };
                
                /// \fn mpiCommStatus
                /// \brief Nonmember constructor for MpiCommStatus.
                /// \relates MpiCommStatus
                template<class OrdinalType>
                inline RCP<MpiCommStatus<OrdinalType> >
                mpiCommStatus (MPI_Status rawMpiStatus)
                {
                  return rcp (new MpiCommStatus<OrdinalType> (rawMpiStatus));
                }
                
                /// \class MpiCommRequestBase
                /// \brief Base class MPI implementation of CommRequest.
                /// \tparam OrdinalType Same as the template parameter of Comm.
                ///
                /// This class wraps MPI_Request, which is MPI's reification of a
                /// nonblocking communication operation.
                ///
                /// Users would not normally create an instance of this class.  Calls
                /// to nonblocking communication operations (such as ireceive() or
                /// isend()) return a pointer to a CommRequest.  If the Comm is an
                /// MpiComm, then the returned CommRequest is an MpiCommRequest.
                ///
                /// Users might wish to create an MpiCommRequest directly if they want
                /// to encapsulate an MPI_Request returned by an external library or
                /// by their own code.
                template<class OrdinalType>
                class MpiCommRequestBase : public CommRequest<OrdinalType> {
                public:
                  //! Default constructor.
                  MpiCommRequestBase () :
                    rawMpiRequest_ (MPI_REQUEST_NULL)
                  {}
                
                  //! Constructor (from a raw MPI_Request).
                  MpiCommRequestBase (MPI_Request rawMpiRequest) :
                    rawMpiRequest_ (rawMpiRequest)
                  {}
                
                  /// \brief Return and relinquish ownership of the raw MPI_Request.
                  ///
                  /// "Relinquish ownership" means that this object sets its raw
                  /// MPI_Request to <tt>MPI_REQUEST_NULL</tt>, but returns the
                  /// original MPI_Request.  This effectively gives the caller
                  /// ownership of the raw MPI_Request.  This prevents hanging
                  /// requests.
                  MPI_Request releaseRawMpiRequest()
                  {
                    MPI_Request tmp_rawMpiRequest = rawMpiRequest_;
                    rawMpiRequest_ = MPI_REQUEST_NULL;
                    return tmp_rawMpiRequest;
                  }
                
                  //! Whether the raw MPI_Request is <tt>MPI_REQUEST_NULL</tt>.
                  bool isNull() const {
                    return rawMpiRequest_ == MPI_REQUEST_NULL;
                  }
                
                  /// \brief Wait on this communication request to complete.
                  ///
                  /// This is a blocking operation.  The user is responsible for
                  /// avoiding deadlock.  (For example, a receive must have a matching
                  /// send, otherwise a wait on the receive will wait forever.)
       ##### ->   RCP<CommStatus<OrdinalType> > wait () {
                    MPI_Status rawMpiStatus;
                    // Whether this function satisfies the strong exception guarantee
                    // depends on whether MPI_Wait modifies its input request on error.
                    const int err = MPI_Wait (&rawMpiRequest_, &rawMpiStatus);
                    TEUCHOS_TEST_FOR_EXCEPTION(
                      err != MPI_SUCCESS, std::runtime_error,
                      "Teuchos: MPI_Wait() failed with error \""
                      << mpiErrorCodeToString (err));
                    // MPI_Wait sets the MPI_Request to MPI_REQUEST_NULL on success.
                    return mpiCommStatus<OrdinalType> (rawMpiStatus);
                  }
                
                  /// \brief Cancel the communication request, and return its status.
                  ///
                  /// If this request is invalid or has already been invalidated, this
                  /// method returns null.
                  RCP<CommStatus<OrdinalType> > cancel () {
                    if (rawMpiRequest_ == MPI_REQUEST_NULL) {
                      return null;
                    }
                    else {
                      int err = MPI_Cancel (&rawMpiRequest_);
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        err != MPI_SUCCESS, std::runtime_error,
                        "Teuchos: MPI_Cancel failed with the following error: "
                        << mpiErrorCodeToString (err));
                
                      // Wait on the request.  If successful, MPI_Wait will set the
                      // MPI_Request to MPI_REQUEST_NULL.  The returned status may
                      // still be useful; for example, one may call MPI_Test_cancelled
                      // to test an MPI_Status from a nonblocking send.
                      MPI_Status status;
                      err = MPI_Wait (&rawMpiRequest_, &status);
                      TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                        "Teuchos::MpiCommStatus::cancel: MPI_Wait failed with the following "
                        "error: " << mpiErrorCodeToString (err));
                      return mpiCommStatus<OrdinalType> (status);
                    }
                  }
                
                  //! Destructor; cancels the request if it is still pending.
                  virtual ~MpiCommRequestBase () {
                    if (rawMpiRequest_ != MPI_REQUEST_NULL) {
                      // We're in a destructor, so don't throw errors.  However, if
                      // MPI_Cancel fails, it's probably a bad idea to call MPI_Wait.
                      const int err = MPI_Cancel (&rawMpiRequest_);
                      if (err == MPI_SUCCESS) {
                        // The MPI_Cancel succeeded.  Now wait on the request.  Ignore
                        // any reported error, since we can't do anything about those
                        // in the destructor (other than kill the program).  If
                        // successful, MPI_Wait will set the MPI_Request to
                        // MPI_REQUEST_NULL.  We ignore the returned MPI_Status, since
                        // if the user let the request fall out of scope, she must not
                        // care about the status.
                        //
                        // mfh 21 Oct 2012: The MPI standard requires completing a
                        // canceled request by calling a function like MPI_Wait,
                        // MPI_Test, or MPI_Request_free.  MPI_Wait on a canceled
                        // request behaves like a local operation (it does not
                        // communicate or block waiting for communication).  One could
                        // also call MPI_Request_free instead of MPI_Wait, but
                        // MPI_Request_free is intended more for persistent requests
                        // (created with functions like MPI_Recv_init).
                        (void) MPI_Wait (&rawMpiRequest_, MPI_STATUS_IGNORE);
                      }
                    }
                  }
                
                private:
                  //! The raw MPI request (an opaque object).
                  MPI_Request rawMpiRequest_;
                };
                
                /// \class MpiCommRequest
                /// \brief MPI implementation of CommRequest.
                /// \tparam OrdinalType Same as the template parameter of Comm.
                ///
                /// This class wraps MPI_Request, which is MPI's reification of a
                /// nonblocking communication operation.
                ///
                /// Users would not normally create an instance of this class.  Calls
                /// to nonblocking communication operations (such as \c ireceive() or
                /// \c isend()) return a pointer to a CommRequest.  If the Comm is an
                /// MpiComm, then the returned CommRequest is an MpiCommRequest.
                ///
                /// Users might wish to create an MpiCommRequest directly if they want
                /// to encapsulate an MPI_Request returned by an external library or
                /// by their own code.
                template<class OrdinalType>
                class MpiCommRequest : public MpiCommRequestBase<OrdinalType> {
                public:
                  //! Default constructor.
                  MpiCommRequest () :
                    MpiCommRequestBase<OrdinalType> (MPI_REQUEST_NULL),
                    numBytes_ (0)
                  {}
                
                  //! Constructor (from a raw MPI_Request).
                  MpiCommRequest (MPI_Request rawMpiRequest,
                                  const ArrayView<char>::size_type numBytesInMessage) :
                    MpiCommRequestBase<OrdinalType> (rawMpiRequest),
                    numBytes_ (numBytesInMessage)
                  {}
                
                  /// \brief Number of bytes in the nonblocking send or receive request.
                  ///
                  /// Remembering this is inexpensive, and is also useful for
                  /// debugging (e.g., for detecting whether the send and receive have
                  /// matching message lengths).
                  ArrayView<char>::size_type numBytes () const {
                    return numBytes_;
                  }
                
                  //! Destructor; cancels the request if it is still pending.
       ##### ->   virtual ~MpiCommRequest () {}
                
                private:
                  //! Number of bytes in the nonblocking send or receive request.
                  ArrayView<char>::size_type numBytes_;
                };
                
                /// \fn mpiCommRequest
                /// \brief Nonmember constructor for MpiCommRequest.
                /// \tparam OrdinalType Same as the template parameter of MpiCommRequest.
                /// \relates MpiCommRequest
                ///
                /// \param rawMpiRequest [in] The raw MPI_Request opaque object.
                /// \param numBytes [in] The number of bytes in the nonblocking
                ///   send or receive request.
                template<class OrdinalType>
                inline RCP<MpiCommRequest<OrdinalType> >
                mpiCommRequest (MPI_Request rawMpiRequest,
                                const ArrayView<char>::size_type numBytes)
                {
                  return rcp (new MpiCommRequest<OrdinalType> (rawMpiRequest, numBytes));
                }
                
                /// \class MpiComm
                /// \brief Implementation of Comm that uses MPI for communication.
                /// \tparam Ordinal The index type for communication; same as the
                ///   template parameter of Comm.
                ///
                /// This class uses MPI (the Message Passing Interface) to implement
                /// the Comm interface.  It includes constructors that take an
                /// MPI_Comm from the application.
                ///
                /// Assertions:
                /// - <tt>getRawMpiComm().get() != NULL<tt>
                /// - <tt>*getRawMpiComm() != MPI_COMM_NULL</tt>
                /// - <tt>getSize() > 0</tt>
                /// - <tt>0 <= getRank() && getRank() < getSize()</tt>
                ///
                template<typename Ordinal>
           1 -> class MpiComm : public Comm<Ordinal> {
                public:
                  //! @name Constructors
                  //@{
                
                  /// \brief Construct an MpiComm with an MPI_Comm.
                  ///
                  /// This constructs an MpiComm that uses the given "raw" MPI
                  /// communicator underneath.  The MPI_Comm must be valid for the
                  /// lifetime of this MpiComm.  You are responsible for freeing the
                  /// MPI_Comm (using MPI_Comm_free) if necessary.
                  ///
                  /// This constructor should be used only in one of two cases:
                  /// 1. When the given MPI_Comm is one of the predefined
                  ///    communicators that need not and must not be freed after use,
                  ///    like MPI_COMM_WORLD or MPI_COMM_SELF.
                  /// 2. When you know that the given MPI_Comm will not be freed until
                  ///    after the lifetime of this MpiComm.
                  ///
                  /// If you cannot be sure of either of these two conditions, you
                  /// should use the version of the constructor that takes an
                  /// <tt>RCP<const OpaqueWrapper<MPI_Comm> ></tt>.
                  ///
                  /// Precondition:
                  /// - <tt>rawMpiComm != MPI_COMM_NULL</tt>
                  explicit MpiComm (MPI_Comm rawMpiComm);
                
                  /// \brief Construct an MpiComm with the given wrapped MPI_Comm.
                  ///
                  /// This constructs an MpiComm that uses the given "raw" MPI
                  /// communicator underneath.  This version of the constructor
                  /// accepts the MPI_Comm wrapped in an OpaqueWrapper, which along
                  /// with the RCP has the option to free the MPI_Comm (via
                  /// MPI_Comm_free) after use if necessary.  You are responsible when
                  /// creating the OpaqueWrapper for supplying a "free" function if
                  /// needed.  We recommend using details::safeCommFree for the "free"
                  /// function, if one is needed.
                  ///
                  /// Preconditions:
                  /// - <tt>rawMpiComm.get() != NULL</tt>
                  /// - <tt>*rawMpiComm != MPI_COMM_NULL</tt>
                  MpiComm (const RCP<const OpaqueWrapper<MPI_Comm> >& rawMpiComm);
                
                  /// \brief Construct an MpiComm with a wrapped MPI_Comm and a default tag.
                  ///
                  /// This constructor has the same meaning as the one-argument
                  /// constructor that takes RCP<const OpaqueWrapper<MPI_Comm> >,
                  /// except that it sets the default message tag on all processes to
                  /// \c defaultTag.  This avoids the MPI_Bcast that the other two
                  /// constructors do.
                  ///
                  /// This constructor is declared private for now, because it is an
                  /// implementation detail of duplicate().  We may choose to expose
                  /// it in the future.
                  ///
                  /// Preconditions:
                  ///   - <tt>rawMpiComm.get() != NULL</tt>
                  ///   - <tt>*rawMpiComm != MPI_COMM_NULL</tt>
                  ///   - \c defaultTag is the same on all processes in the given
                  ///     communicator
                  MpiComm (const RCP<const OpaqueWrapper<MPI_Comm> >& rawMpiComm,
                           const int defaultTag);
                
                  /**
                   * \brief Construct a communicator with a new context with the same
                   *   properties as the original.
                   *
                   * The newly constructed communicator will have a duplicate communication
                   * space that has the same properties (e.g. processes, attributes,
                   * topologies) as the input communicator.
                   *
                   * \param other The communicator to copy from.
                   *
                   * <b>Preconditions:</b><ul>
                   * <li><tt>
                   * other.getRawMpiComm().get() != NULL && *other.getRawMpiComm() != NULL
                   * </tt></li>
                   * </ul>
                   */
                  MpiComm (const MpiComm<Ordinal>& other);
                
                  /** \brief Return the embedded wrapped opaque <tt>MPI_Comm</tt> object. */
                  RCP<const OpaqueWrapper<MPI_Comm> > getRawMpiComm () const {
                    return rawMpiComm_;
                  }
                
                  /// \brief Set the MPI error handler for this communicator.
                  ///
                  /// \param errHandler [in] The error handler to set.  If null, do
                  ///   nothing.
                  ///
                  /// MPI lets you set an error handler function specific to each
                  /// communicator.  (See Section 8.3 of the MPI 3.0 Standard.)
                  /// MpiComm wraps this functionality using this method.  You must
                  /// first either create an error handler using
                  /// MPI_Comm_create_errhandler() (or MPI_Errhandler_create() if you
                  /// are stuck with an MPI 1 implementation), or use one of the
                  /// default error handlers that the MPI standard or your MPI
                  /// implementation provides.  You will need to wrap the MPI error
                  /// handler in an OpaqueWrapper.  (See the documentation of
                  /// OpaqueWrapper for the rationale behind not using MPI's opaque
                  /// objects directly.)
                  ///
                  /// MpiComm will not attempt to call MPI_Errhandler_free() on the
                  /// error handler you provide.  You are responsible for arranging
                  /// that this be done.  Note that MPI_Comm_create_errhandler()
                  /// (which creates an error handler, given a function pointer) does
                  /// not attach the error handler to an MPI_Comm, so the lifetime of
                  /// the error handler is not tied to the MPI_Comm to which it is
                  /// assigned.  An error handler can be assigned to more than one
                  /// MPI_Comm, in fact.  You just need to guarantee that if you
                  /// create a custom error handler, then that handler gets freed at
                  /// some point.  "The call to <tt>MPI_FINALIZE</tt> does not free
                  /// objects created by MPI calls; these objects are freed using
                  /// <tt>MPI_xxx_FREE</tt> calls" (Section 8.7, MPI 3.0 Standard).
                  /// Note that it is legitimate to call MPI_Errhandler_free() right
                  /// after setting the MPI_Comm's error handler; see Section 8.3.4 of
                  /// the MPI 3.0 Standard ("The error handler [given to
                  /// MPI_Errhandler_free] will be deallocated after all the objects
                  /// associated with it (communicator, window, or file) have been
                  /// deallocated").  You might instead attach your error handler as a
                  /// attribute to <tt>MPI_COMM_SELF</tt>, in such a way that
                  /// MPI_Errhandler_free() will be called when <tt>MPI_COMM_SELF</tt>
                  /// is freed (which MPI_Finalize() does automatically).  We do not
                  /// take responsibility for doing any of these things; you are
                  /// responsible for freeing the error handler.
                  ///
                  /// Here is an example showing how to change an MpiComm's error
                  /// handler.  The default error handler for any <tt>MPI_Comm</tt> is
                  /// <tt>MPI_ERRORS_ARE_FATAL</tt>.  This handler immediately aborts
                  /// if MPI encounters an error, without returning an error code from
                  /// the MPI function.  Suppose that instead you would like MPI
                  /// functions to return an error code if MPI should encounter an
                  /// error.  (In that case, Teuchos' MPI wrappers will detect the
                  /// returned error code and throw an exception with an appropriate
                  /// error message.  If MPI aborts immediately on error, Teuchos
                  /// won't have the chance to detect and report the error.)  If so,
                  /// you may set the error handler to MPI_ERRORS_RETURN, one of MPI's
                  /// built-in error handlers.  Here is how you may do this for an
                  /// MpiComm:
                  /// \code
                  /// // Suppose that you've already created this MpiComm.
                  /// RCP<const MpiComm<int> > comm = ...;
                  ///
                  /// // Wrap the error handler.
                  /// RCP<const OpaqueWrapper<MPI_Errhandler> > errHandler =
                  ///   rcp (new OpaqueWrapper<MPI_Errhandler> (MPI_ERRORS_RETURN));
                  /// // Set the MpiComm's error handler.
                  /// comm->setErrorHandler (errHandler);
                  /// \endcode
                  void setErrorHandler (const RCP<const OpaqueWrapper<MPI_Errhandler> >& errHandler);
                
                  //@}
                  //! @name Implementation of Comm interface
                  //@{
                
                  //! The calling process' rank.
                  virtual int getRank() const;
                
                  //! The number of processes in the communicator.
                  virtual int getSize() const;
                
                  //! Execute a barrier; must be called collectively.
                  virtual void barrier() const;
                
                  /** \brief . */
                  virtual void broadcast(
                    const int rootRank, const Ordinal bytes, char buffer[]
                    ) const;
                
                  //! Gather values from all processes to the root process.
                  virtual void
                  gather (const Ordinal sendBytes, const char sendBuffer[],
                          const Ordinal recvBytes, char recvBuffer[],
                          const int root) const;
                  /** \brief . */
                  virtual void gatherAll(
                    const Ordinal sendBytes, const char sendBuffer[]
                    ,const Ordinal recvBytes, char recvBuffer[]
                    ) const;
                  /** \brief . */
                  virtual void reduceAll(
                    const ValueTypeReductionOp<Ordinal,char> &reductOp
                    ,const Ordinal bytes, const char sendBuffer[], char globalReducts[]
                    ) const;
                  /** \brief . */
                  virtual void scan(
                    const ValueTypeReductionOp<Ordinal,char> &reductOp
                    ,const Ordinal bytes, const char sendBuffer[], char scanReducts[]
                    ) const;
                  /** \brief . */
                  virtual void send(
                    const Ordinal bytes, const char sendBuffer[], const int destRank
                    ) const;
                  /** \brief . */
                  virtual void
                  send (const Ordinal bytes,
                        const char sendBuffer[],
                        const int destRank,
                        const int tag) const;
                  /** \brief . */
                  virtual void ssend(
                    const Ordinal bytes, const char sendBuffer[], const int destRank
                    ) const;
                  //! Variant of ssend() that takes a message tag.
                  virtual void
                  ssend (const Ordinal bytes,
                         const char sendBuffer[],
                         const int destRank,
                         const int tag) const;
                  /** \brief . */
                  virtual int receive(
                    const int sourceRank, const Ordinal bytes, char recvBuffer[]
                    ) const;
                  /** \brief . */
                  virtual void readySend(
                    const ArrayView<const char> &sendBuffer,
                    const int destRank
                    ) const;
                  //! Variant of readySend() that accepts a message tag.
                  virtual void
                  readySend (const Ordinal bytes,
                             const char sendBuffer[],
                             const int destRank,
                             const int tag) const;
                  /** \brief . */
                  virtual RCP<CommRequest<Ordinal> > isend(
                    const ArrayView<const char> &sendBuffer,
                    const int destRank
                    ) const;
                  //! Variant of isend() that takes a tag.
                  virtual RCP<CommRequest<Ordinal> >
                  isend (const ArrayView<const char> &sendBuffer,
                         const int destRank,
                         const int tag) const;
                  /** \brief . */
                  virtual RCP<CommRequest<Ordinal> > ireceive(
                    const ArrayView<char> &Buffer,
                    const int sourceRank
                    ) const;
                  /** \brief . */
                  virtual RCP<CommRequest<Ordinal> >
                  ireceive (const ArrayView<char> &Buffer,
                            const int sourceRank,
                            const int tag) const;
                  /** \brief . */
                  virtual void waitAll(
                    const ArrayView<RCP<CommRequest<Ordinal> > > &requests
                    ) const;
                  /** \brief . */
                  virtual void
                  waitAll (const ArrayView<RCP<CommRequest<Ordinal> > >& requests,
                           const ArrayView<RCP<CommStatus<Ordinal> > >& statuses) const;
                  /** \brief . */
                  virtual RCP<CommStatus<Ordinal> >
                  wait (const Ptr<RCP<CommRequest<Ordinal> > >& request) const;
                  /** \brief . */
                  virtual RCP< Comm<Ordinal> > duplicate() const;
                  /** \brief . */
                  virtual RCP< Comm<Ordinal> > split(const int color, const int key) const;
                  /** \brief . */
                  virtual RCP< Comm<Ordinal> > createSubcommunicator(
                    const ArrayView<const int>& ranks) const;
                
                  //@}
                  //! @name Implementation of Describable interface
                  //@{
                
                  /** \brief . */
                  std::string description() const;
                
                  //@}
                
                  // These should be private but the PGI compiler requires them be public
                
                  static int const minTag_ = 26000; // These came from Teuchos::MpiComm???
                  static int const maxTag_ = 26099; // ""
                
                  /// \brief The current tag.
                  ///
                  /// \warning This method is ONLY for use by Teuchos developers.
                  ///   Users should not depend on the interface of this method.
                  ///   It may change or disappear at any time without warning.
       ##### ->   int getTag () const { return tag_; }
                
                private:
                
                  /// \brief Set internal data members once the rawMpiComm_ data member is valid.
                  ///
                  /// This method should only be called from MpiComm's constructor.
                  void setupMembersFromComm();
                  static int tagCounter_;
                
                  /// \brief The "raw" MPI_Comm (communicator).
                  ///
                  /// We wrap the MPI_Comm so that it is freed automatically when its
                  /// reference count goes to zero, if it does need to be freed after
                  /// use by calling MPI_Comm_free.  (Predefined MPI_Comm, which
                  /// include but are not limited to MPI_COMM_WORLD and MPI_COMM_SELF,
                  /// need not and must not be freed after use.)
                  RCP<const OpaqueWrapper<MPI_Comm> > rawMpiComm_;
                
                  //! The rank of the calling process.
                  int rank_;
                
                  //! The number of processes in the communicator.
                  int size_;
                
                  /// \brief The current tag, to use for all MPI functions that need it.
                  ///
                  /// Each MpiComm instance always uses the same tag.  Different
                  /// MpiComm instances use different tags.  The tag is set in
                  /// MpiComm's constructor.  Please refer to
                  /// <a href="https://software.sandia.gov/bugzilla/show_bug.cgi?id=5740">Bug 5740</a>
                  /// for further discussion.
                  int tag_;
                
                  //! MPI error handler.  If null, MPI uses the default error handler.
                  RCP<const OpaqueWrapper<MPI_Errhandler> > customErrorHandler_;
                
                  void assertRank(const int rank, const std::string &rankName) const;
                
                  // Not defined and not to be called!
                  MpiComm();
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                public:
                  static bool show_dump;
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                };
                
                
                /** \brief Helper function that creates a dynamically allocated
                 * <tt>MpiComm</tt> object or returns <tt>Teuchos::null</tt> to correctly
                 * represent a null communicator.
                 *
                 * <b>Postconditions:</b></ul>
                 * <li>[<tt>rawMpiComm.get()!=NULL && *rawMpiComm!=MPI_COMM_NULL</tt>]
                 *     <tt>return.get()!=NULL</tt>
                 * <li>[<tt>rawMpiComm.get()==NULL || *rawMpiComm==MPI_COMM_NULL</tt>]
                 *     <tt>return.get()==NULL</tt>
                 * </ul>
                 *
                 * \relates MpiComm
                 */
                template<typename Ordinal>
                RCP<MpiComm<Ordinal> >
                createMpiComm(
                  const RCP<const OpaqueWrapper<MPI_Comm> > &rawMpiComm
                  );
                
                
                /** \brief Helper function that extracts a raw <tt>MPI_Comm</tt> object out of
                 * a <tt>Teuchos::MpiComm</tt> wrapper object.
                 *
                 * <b>Preconditions:</b></ul>
                 * <li><tt>dynamic_cast<const MpiComm<Ordinal>*>(&comm) != 0</tt>
                 * </ul>
                 *
                 * If the underlying type is not an <tt>MpiComm<Ordinal></tt> object, then the
                 * function with throw an exception which contains the type information as for
                 * why it failed.
                 *
                 * <b>WARNING:</b> The lifetime of the returned <tt>MPI_Comm</tt> object is
                 * controlled by the owning <tt>RCP<OpaqueWrapper<MPI_Comm> ></tt> object and
                 * is not guaranteed to live the entire life of the program.  Therefore, only
                 * use this function to grab and use the underlying <tt>MPI_Comm</tt> object
                 * in a vary narrow scope and then forget it.  If you need it again, get it
                 * off of the <tt>comm</tt> object each time.
                 *
                 * If you want a memory safe <tt><tt>RCP<OpaqueWrapper<MPI_Comm> ></tt> to the
                 * raw <tt>MPI_Comm</tt> object, then call:
                 *
                 * \verbatim
                 * dyn_cast<const MpiComm<Ordinal> >(comm).getRawMpiComm()
                 * \endverbatim
                 *
                 * \relates MpiComm
                 */
                template<typename Ordinal>
                MPI_Comm
                getRawMpiComm(const Comm<Ordinal> &comm);
                
                
                // ////////////////////////
                // Implementations
                
                
                // Static members
                
                
                template<typename Ordinal>
                int MpiComm<Ordinal>::tagCounter_ = MpiComm<Ordinal>::minTag_;
                
                
                // Constructors
                
                
                template<typename Ordinal>
                MpiComm<Ordinal>::
                MpiComm (const RCP<const OpaqueWrapper<MPI_Comm> >& rawMpiComm)
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    rawMpiComm.get () == NULL, std::invalid_argument,
                    "Teuchos::MpiComm constructor: The input RCP is null.");
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    *rawMpiComm == MPI_COMM_NULL, std::invalid_argument,
                    "Teuchos::MpiComm constructor: The given MPI_Comm is MPI_COMM_NULL.");
                
                  rawMpiComm_ = rawMpiComm;
                
                  // mfh 09 Jul 2013: Please resist the temptation to modify the given
                  // MPI communicator's error handler here.  See Bug 5943.  Note that
                  // an MPI communicator's default error handler is
                  // MPI_ERRORS_ARE_FATAL, which immediately aborts on error (without
                  // returning an error code from the MPI function).  Users who want
                  // MPI functions instead to return an error code if they encounter
                  // an error, should set the error handler to MPI_ERRORS_RETURN.  DO
                  // NOT SET THE ERROR HANDLER HERE!!!  Teuchos' MPI wrappers should
                  // always check the error code returned by an MPI function,
                  // regardless of the error handler.  Users who want to set the error
                  // handler on an MpiComm may call its setErrorHandler method.
                
                  setupMembersFromComm ();
                }
                
                
                template<typename Ordinal>
       ##### -> MpiComm<Ordinal>::
                MpiComm (const RCP<const OpaqueWrapper<MPI_Comm> >& rawMpiComm,
                         const int defaultTag)
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    rawMpiComm.get () == NULL, std::invalid_argument,
                    "Teuchos::MpiComm constructor: The input RCP is null.");
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    *rawMpiComm == MPI_COMM_NULL, std::invalid_argument,
                    "Teuchos::MpiComm constructor: The given MPI_Comm is MPI_COMM_NULL.");
                
                  rawMpiComm_ = rawMpiComm;
                  // Set size_ (the number of processes in the communicator).
                  int err = MPI_Comm_size (*rawMpiComm_, &size_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm constructor: MPI_Comm_size failed with "
                    "error \"" << mpiErrorCodeToString (err) << "\".");
                  // Set rank_ (the calling process' rank).
                  err = MPI_Comm_rank (*rawMpiComm_, &rank_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm constructor: MPI_Comm_rank failed with "
                    "error \"" << mpiErrorCodeToString (err) << "\".");
                  tag_ = defaultTag; // set the default message tag
                }
                
                
                template<typename Ordinal>
                MpiComm<Ordinal>::MpiComm (MPI_Comm rawMpiComm)
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(rawMpiComm == MPI_COMM_NULL,
                    std::invalid_argument, "Teuchos::MpiComm constructor: The given MPI_Comm "
                    "is MPI_COMM_NULL.");
                  // We don't supply a "free" function here, since this version of the
                  // constructor makes the caller responsible for freeing rawMpiComm
                  // after use if necessary.
                  rawMpiComm_ = opaqueWrapper<MPI_Comm> (rawMpiComm);
                
                  // mfh 09 Jul 2013: Please resist the temptation to modify the given
                  // MPI communicator's error handler here.  See Bug 5943.  Note that
                  // an MPI communicator's default error handler is
                  // MPI_ERRORS_ARE_FATAL, which immediately aborts on error (without
                  // returning an error code from the MPI function).  Users who want
                  // MPI functions instead to return an error code if they encounter
                  // an error, should set the error handler to MPI_ERRORS_RETURN.  DO
                  // NOT SET THE ERROR HANDLER HERE!!!  Teuchos' MPI wrappers should
                  // always check the error code returned by an MPI function,
                  // regardless of the error handler.  Users who want to set the error
                  // handler on an MpiComm may call its setErrorHandler method.
                
                  setupMembersFromComm ();
                }
                
                
                template<typename Ordinal>
                MpiComm<Ordinal>::MpiComm (const MpiComm<Ordinal>& other) :
                  rawMpiComm_ (opaqueWrapper<MPI_Comm> (MPI_COMM_NULL)) // <- This will be set below
                {
                  // These are logic errors, since they violate MpiComm's invariants.
                  RCP<const OpaqueWrapper<MPI_Comm> > origCommPtr = other.getRawMpiComm ();
                  TEUCHOS_TEST_FOR_EXCEPTION(origCommPtr == null, std::logic_error,
                    "Teuchos::MpiComm copy constructor: "
                    "The input's getRawMpiComm() method returns null.");
                  MPI_Comm origComm = *origCommPtr;
                  TEUCHOS_TEST_FOR_EXCEPTION(origComm == MPI_COMM_NULL, std::logic_error,
                    "Teuchos::MpiComm copy constructor: "
                    "The input's raw MPI_Comm is MPI_COMM_NULL.");
                
                  // mfh 19 Oct 2012: Don't change the behavior of MpiComm's copy
                  // constructor for now.  Later, we'll switch to the version that
                  // calls MPI_Comm_dup.  For now, we just copy other's handle over.
                  // Note that the new MpiComm's tag is still different than the input
                  // MpiComm's tag.  See Bug 5740.
                  if (true) {
                    rawMpiComm_ = origCommPtr;
                  }
                  else { // false (not run)
                    MPI_Comm newComm;
                    const int err = MPI_Comm_dup (origComm, &newComm);
                    TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                      "Teuchos::MpiComm copy constructor: MPI_Comm_dup failed with "
                      "the following error: " << mpiErrorCodeToString (err));
                    // No side effects until after everything has succeeded.
                    rawMpiComm_ = opaqueWrapper (newComm, details::safeCommFree);
                  }
                
                  setupMembersFromComm ();
                }
                
                
                template<typename Ordinal>
           1 -> void MpiComm<Ordinal>::setupMembersFromComm ()
                {
                  int err = MPI_Comm_size (*rawMpiComm_, &size_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm constructor: MPI_Comm_size failed with "
                    "error \"" << mpiErrorCodeToString (err) << "\".");
                  err = MPI_Comm_rank (*rawMpiComm_, &rank_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm constructor: MPI_Comm_rank failed with "
                    "error \"" << mpiErrorCodeToString (err) << "\".");
                
                  // Set the default tag to make unique across all communicators
                  if (tagCounter_ > maxTag_) {
                    tagCounter_ = minTag_;
                  }
                  tag_ = tagCounter_++;
                  // Ensure that the same tag is used on all processes.
                  //
                  // FIXME (mfh 09 Jul 2013) This would not be necessary if MpiComm
                  // were just to call MPI_Comm_dup (as every library should) when
                  // given its communicator.  Of course, MPI_Comm_dup may also be
                  // implemented as a collective, and may even be more expensive than
                  // a broadcast.  If we do decide to use MPI_Comm_dup, we can get rid
                  // of the broadcast below, and also get rid of tag_, tagCounter_,
                  // minTag_, and maxTag_.
                  MPI_Bcast (&tag_, 1, MPI_INT, 0, *rawMpiComm_);
                }
                
                
                template<typename Ordinal>
                void
                MpiComm<Ordinal>::
                setErrorHandler (const RCP<const OpaqueWrapper<MPI_Errhandler> >& errHandler)
                {
                  if (! is_null (errHandler)) {
                    const int err = details::setCommErrhandler (*getRawMpiComm (), *errHandler);
                    TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                      "Teuchos::MpiComm: Setting the MPI_Comm's error handler failed with "
                      "error \"" << mpiErrorCodeToString (err) << "\".");
                  }
                  // Wait to set this until the end, in case setting the error handler
                  // doesn't succeed.
                  customErrorHandler_ = errHandler;
                }
                
                //
                // Overridden from Comm
                //
                
                template<typename Ordinal>
          26 -> int MpiComm<Ordinal>::getRank() const
                {
                  return rank_;
                }
                
                
                template<typename Ordinal>
          19 -> int MpiComm<Ordinal>::getSize() const
                {
                  return size_;
                }
                
                
                template<typename Ordinal>
       ##### -> void MpiComm<Ordinal>::barrier() const
                {
                  TEUCHOS_COMM_TIME_MONITOR(
                    "Teuchos::MpiComm<"<<OrdinalTraits<Ordinal>::name()<<">::barrier()"
                    );
                  const int err = MPI_Barrier (*rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::barrier: MPI_Barrier failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
           2 -> void MpiComm<Ordinal>::broadcast(
                  const int rootRank, const Ordinal bytes, char buffer[]
                  ) const
                {
                  TEUCHOS_COMM_TIME_MONITOR(
                    "Teuchos::MpiComm<"<<OrdinalTraits<Ordinal>::name()<<">::broadcast(...)"
                    );
                  const int err = MPI_Bcast (buffer, bytes, MPI_CHAR, rootRank, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::broadcast: MPI_Bcast failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
       ##### -> void MpiComm<Ordinal>::gatherAll(
                  const Ordinal sendBytes, const char sendBuffer[],
                  const Ordinal recvBytes, char recvBuffer[]
                  ) const
                {
                  TEUCHOS_COMM_TIME_MONITOR(
                    "Teuchos::MpiComm<"<<OrdinalTraits<Ordinal>::name()<<">::gatherAll(...)"
                    );
                  TEUCHOS_ASSERT_EQUALITY((sendBytes*size_), recvBytes );
                  const int err =
                    MPI_Allgather (const_cast<char *>(sendBuffer), sendBytes, MPI_CHAR,
                                   recvBuffer, sendBytes, MPI_CHAR, *rawMpiComm_);
                  // NOTE: 'sendBytes' is being sent above for the MPI arg recvcount (which is
                  // very confusing in the MPI documentation) for MPI_Allgether(...).
                
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::gatherAll: MPI_Allgather failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                void
       ##### -> MpiComm<Ordinal>::gather (const Ordinal sendBytes,
                                          const char sendBuffer[],
                                          const Ordinal recvBytes,
                                          char recvBuffer[],
                                          const int root) const
                {
                  (void) recvBytes; // silence compile warning for "unused parameter"
                
                  TEUCHOS_COMM_TIME_MONITOR(
                    "Teuchos::MpiComm<"<<OrdinalTraits<Ordinal>::name()<<">::gather(...)"
                    );
                  const int err =
                    MPI_Gather (const_cast<char *> (sendBuffer), sendBytes, MPI_CHAR,
                                recvBuffer, sendBytes, MPI_CHAR, root, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::gather: MPI_Gather failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                void
           4 -> MpiComm<Ordinal>::
                reduceAll (const ValueTypeReductionOp<Ordinal,char> &reductOp,
                           const Ordinal bytes,
                           const char sendBuffer[],
                           char globalReducts[]) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::reduceAll(...)" );
                  int err = MPI_SUCCESS;
                
                  Details::MpiReductionOp<Ordinal> opWrap (reductOp);
                  MPI_Op op = Details::setMpiReductionOp (opWrap);
                
                  // FIXME (mfh 23 Nov 2014) Ross decided to mash every type into
                  // char.  This can cause correctness issues if we're actually doing
                  // a reduction over, say, double.  Thus, he creates a custom
                  // MPI_Datatype here that represents a contiguous block of char, so
                  // that MPI doesn't split up the reduction type and thus do the sum
                  // wrong.  It's a hack but it works.
                
                  MPI_Datatype char_block;
                  err = MPI_Type_contiguous (bytes, MPI_CHAR, &char_block);
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    err != MPI_SUCCESS, std::runtime_error, "Teuchos::reduceAll: "
                    "MPI_Type_contiguous failed with error \"" << mpiErrorCodeToString (err)
                    << "\".");
                  err = MPI_Type_commit (&char_block);
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    err != MPI_SUCCESS, std::runtime_error, "Teuchos::reduceAll: "
                    "MPI_Type_commit failed with error \"" << mpiErrorCodeToString (err)
                    << "\".");
                
                  err = MPI_Allreduce (const_cast<char*> (sendBuffer), globalReducts, 1,
                                       char_block, op, *rawMpiComm_);
                  if (err != MPI_SUCCESS) {
                    // Don't throw until we release the type resources we allocated
                    // above.  If freeing fails for some reason, let the memory leak
                    // go; we already have more serious problems if MPI_Allreduce
                    // doesn't work.
                    (void) MPI_Type_free (&char_block);
                    TEUCHOS_TEST_FOR_EXCEPTION(
                      true, std::runtime_error, "Teuchos::reduceAll (MPI, custom op): "
                      "MPI_Allreduce failed with error \"" << mpiErrorCodeToString (err)
                      << "\".");
                  }
                  err = MPI_Type_free (&char_block);
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    err != MPI_SUCCESS, std::runtime_error, "Teuchos::reduceAll: "
                    "MPI_Type_free failed with error \"" << mpiErrorCodeToString (err)
                    << "\".");
                }
                
                
                template<typename Ordinal>
           1 -> void MpiComm<Ordinal>::scan(
                  const ValueTypeReductionOp<Ordinal,char> &reductOp
                  ,const Ordinal bytes, const char sendBuffer[], char scanReducts[]
                  ) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::scan(...)" );
                
                  Details::MpiReductionOp<Ordinal> opWrap (reductOp);
                  MPI_Op op = Details::setMpiReductionOp (opWrap);
                  const int err =
                    MPI_Scan (const_cast<char*> (sendBuffer), scanReducts, bytes, MPI_CHAR,
                              op, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::scan: MPI_Scan() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                void
       ##### -> MpiComm<Ordinal>::send (const Ordinal bytes,
                                        const char sendBuffer[],
                                        const int destRank) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::send(...)" );
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                  if(show_dump) {
                    dumpBuffer<Ordinal,char>(
                      "Teuchos::MpiComm<Ordinal>::send(...)"
                      ,"sendBuffer", bytes, sendBuffer
                      );
                  }
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                  const int err = MPI_Send (const_cast<char*>(sendBuffer), bytes, MPI_CHAR,
                                            destRank, tag_, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::send: MPI_Send() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                void
       ##### -> MpiComm<Ordinal>::send (const Ordinal bytes,
                                        const char sendBuffer[],
                                        const int destRank,
                                        const int tag) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::send(...)" );
                  const int err = MPI_Send (const_cast<char*> (sendBuffer), bytes, MPI_CHAR,
                                            destRank, tag, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::send: MPI_Send() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                void
       ##### -> MpiComm<Ordinal>::ssend (const Ordinal bytes,
                                         const char sendBuffer[],
                                         const int destRank) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::ssend(...)" );
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                  if(show_dump) {
                    dumpBuffer<Ordinal,char>(
                      "Teuchos::MpiComm<Ordinal>::send(...)"
                      ,"sendBuffer", bytes, sendBuffer
                      );
                  }
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                  const int err = MPI_Ssend (const_cast<char*>(sendBuffer), bytes, MPI_CHAR,
                                             destRank, tag_, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::send: MPI_Ssend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                template<typename Ordinal>
                void
       ##### -> MpiComm<Ordinal>::ssend (const Ordinal bytes,
                                         const char sendBuffer[],
                                         const int destRank,
                                         const int tag) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::ssend(...)" );
                  const int err =
                    MPI_Ssend (const_cast<char*>(sendBuffer), bytes, MPI_CHAR,
                               destRank, tag, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::send: MPI_Ssend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                template<typename Ordinal>
       ##### -> void MpiComm<Ordinal>::readySend(
                  const ArrayView<const char> &sendBuffer,
                  const int destRank
                  ) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::readySend" );
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                  if(show_dump) {
                    dumpBuffer<Ordinal,char>(
                      "Teuchos::MpiComm<Ordinal>::readySend(...)"
                      ,"sendBuffer", bytes, sendBuffer
                      );
                  }
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                  const int err =
                    MPI_Rsend (const_cast<char*>(sendBuffer.getRawPtr()), sendBuffer.size(),
                               MPI_CHAR, destRank, tag_, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::readySend: MPI_Rsend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
       ##### -> void MpiComm<Ordinal>::
                readySend (const Ordinal bytes,
                           const char sendBuffer[],
                           const int destRank,
                           const int tag) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::readySend" );
                  const int err =
                    MPI_Rsend (const_cast<char*> (sendBuffer), bytes,
                               MPI_CHAR, destRank, tag, *rawMpiComm_);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::readySend: MPI_Rsend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                }
                
                
                template<typename Ordinal>
                int
       ##### -> MpiComm<Ordinal>::receive (const int sourceRank,
                                           const Ordinal bytes,
                                           char recvBuffer[]) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::receive(...)" );
                
                  // A negative source rank indicates MPI_ANY_SOURCE, namely that we
                  // will take an incoming message from any process, as long as the
                  // tag matches.
                  const int theSrcRank = (sourceRank < 0) ? MPI_ANY_SOURCE : sourceRank;
                
                  MPI_Status status;
                  const int err = MPI_Recv (recvBuffer, bytes, MPI_CHAR, theSrcRank, tag_,
                                            *rawMpiComm_, &status);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::receive: MPI_Recv() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                  if (show_dump) {
                    dumpBuffer<Ordinal,char> ("Teuchos::MpiComm<Ordinal>::receive(...)",
                                              "recvBuffer", bytes, recvBuffer);
                  }
                #endif // TEUCHOS_MPI_COMM_DUMP
                
                  // Returning the source rank is useful in the MPI_ANY_SOURCE case.
                  return status.MPI_SOURCE;
                }
                
                
                template<typename Ordinal>
                RCP<CommRequest<Ordinal> >
       ##### -> MpiComm<Ordinal>::isend (const ArrayView<const char> &sendBuffer,
                                         const int destRank) const
                {
                  using Teuchos::as;
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::isend(...)" );
                
                  MPI_Request rawMpiRequest = MPI_REQUEST_NULL;
                  const int err =
                    MPI_Isend (const_cast<char*> (sendBuffer.getRawPtr ()),
                               as<Ordinal> (sendBuffer.size ()), MPI_CHAR,
                               destRank, tag_, *rawMpiComm_, &rawMpiRequest);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::isend: MPI_Isend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  return mpiCommRequest<Ordinal> (rawMpiRequest, sendBuffer.size ());
                }
                
                
                template<typename Ordinal>
                RCP<CommRequest<Ordinal> >
       ##### -> MpiComm<Ordinal>::
                isend (const ArrayView<const char> &sendBuffer,
                       const int destRank,
                       const int tag) const
                {
                  using Teuchos::as;
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::isend(...)" );
                
                  MPI_Request rawMpiRequest = MPI_REQUEST_NULL;
                  const int err =
                    MPI_Isend (const_cast<char*> (sendBuffer.getRawPtr ()),
                               as<Ordinal> (sendBuffer.size ()), MPI_CHAR,
                               destRank, tag, *rawMpiComm_, &rawMpiRequest);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::isend: MPI_Isend() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  return mpiCommRequest<Ordinal> (rawMpiRequest, sendBuffer.size ());
                }
                
                
                template<typename Ordinal>
                RCP<CommRequest<Ordinal> >
       ##### -> MpiComm<Ordinal>::ireceive (const ArrayView<char> &recvBuffer,
                                            const int sourceRank) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::ireceive(...)" );
                
                  // A negative source rank indicates MPI_ANY_SOURCE, namely that we
                  // will take an incoming message from any process, as long as the
                  // tag matches.
                  const int theSrcRank = (sourceRank < 0) ? MPI_ANY_SOURCE : sourceRank;
                
                  MPI_Request rawMpiRequest = MPI_REQUEST_NULL;
                  const int err =
                    MPI_Irecv (const_cast<char*>(recvBuffer.getRawPtr()), recvBuffer.size(),
                               MPI_CHAR, theSrcRank, tag_, *rawMpiComm_, &rawMpiRequest);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::ireceive: MPI_Irecv() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  return mpiCommRequest<Ordinal> (rawMpiRequest, recvBuffer.size());
                }
                
                template<typename Ordinal>
                RCP<CommRequest<Ordinal> >
       ##### -> MpiComm<Ordinal>::ireceive (const ArrayView<char> &recvBuffer,
                                            const int sourceRank,
                                            const int tag) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::ireceive(...)" );
                
                  // A negative source rank indicates MPI_ANY_SOURCE, namely that we
                  // will take an incoming message from any process, as long as the
                  // tag matches.
                  const int theSrcRank = (sourceRank < 0) ? MPI_ANY_SOURCE : sourceRank;
                
                  MPI_Request rawMpiRequest = MPI_REQUEST_NULL;
                  const int err =
                    MPI_Irecv (const_cast<char*> (recvBuffer.getRawPtr ()), recvBuffer.size (),
                               MPI_CHAR, theSrcRank, tag, *rawMpiComm_, &rawMpiRequest);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error,
                    "Teuchos::MpiComm::ireceive: MPI_Irecv() failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  return mpiCommRequest<Ordinal> (rawMpiRequest, recvBuffer.size ());
                }
                
                namespace {
                  // Called by the two-argument MpiComm::waitAll() variant.
                  template<typename Ordinal>
                  void
                  waitAllImpl (const ArrayView<RCP<CommRequest<Ordinal> > >& requests,
                               const ArrayView<MPI_Status>& rawMpiStatuses)
                  {
                    typedef typename ArrayView<RCP<CommRequest<Ordinal> > >::size_type size_type;
                    const size_type count = requests.size();
                    // waitAllImpl() is not meant to be called by users, so it's a bug
                    // for the two views to have different lengths.
                    TEUCHOS_TEST_FOR_EXCEPTION(rawMpiStatuses.size() != count,
                      std::logic_error, "Teuchos::MpiComm's waitAllImpl: rawMpiStatus.size() = "
                      << rawMpiStatuses.size() << " != requests.size() = " << requests.size()
                      << ".  Please report this bug to the Tpetra developers.");
                    if (count == 0) {
                      return; // No requests on which to wait
                    }
                
                    // MpiComm wraps MPI and can't expose any MPI structs or opaque
                    // objects.  Thus, we have to unpack requests into a separate array.
                    // If that's too slow, then your code should just call into MPI
                    // directly.
                    //
                    // Pull out the raw MPI requests from the wrapped requests.
                    // MPI_Waitall should not fail if a request is MPI_REQUEST_NULL, but
                    // we keep track just to inform the user.
                    bool someNullRequests = false;
                    Array<MPI_Request> rawMpiRequests (count, MPI_REQUEST_NULL);
                    for (int i = 0; i < count; ++i) {
                      RCP<CommRequest<Ordinal> > request = requests[i];
                      if (! is_null (request)) {
                        RCP<MpiCommRequestBase<Ordinal> > mpiRequest =
                          rcp_dynamic_cast<MpiCommRequestBase<Ordinal> > (request);
                        // releaseRawMpiRequest() sets the MpiCommRequest's raw
                        // MPI_Request to MPI_REQUEST_NULL.  This makes waitAll() not
                        // satisfy the strong exception guarantee.  That's OK because
                        // MPI_Waitall() doesn't promise that it satisfies the strong
                        // exception guarantee, and we would rather conservatively
                        // invalidate the handles than leave dangling requests around
                        // and risk users trying to wait on the same request twice.
                        rawMpiRequests[i] = mpiRequest->releaseRawMpiRequest();
                      }
                      else { // Null requests map to MPI_REQUEST_NULL
                        rawMpiRequests[i] = MPI_REQUEST_NULL;
                        someNullRequests = true;
                      }
                    }
                
                    // This is the part where we've finally peeled off the wrapper and
                    // we can now interact with MPI directly.
                    //
                    // One option in the one-argument version of waitAll() is to ignore
                    // the statuses completely.  MPI lets you pass in the named constant
                    // MPI_STATUSES_IGNORE for the MPI_Status array output argument in
                    // MPI_Waitall(), which would tell MPI not to bother with the
                    // statuses.  However, we want the statuses because we can use them
                    // for detailed error diagnostics in case something goes wrong.
                    const int err = MPI_Waitall (count, rawMpiRequests.getRawPtr(),
                                                 rawMpiStatuses.getRawPtr());
                
                    // In MPI_Waitall(), an error indicates that one or more requests
                    // failed.  In that case, there could be requests that completed
                    // (their MPI_Status' error field is MPI_SUCCESS), and other
                    // requests that have not completed yet but have not necessarily
                    // failed (MPI_PENDING).  We make no attempt here to wait on the
                    // pending requests.  It doesn't make sense for us to do so, because
                    // in general Teuchos::Comm doesn't attempt to provide robust
                    // recovery from failed messages.
                    if (err != MPI_SUCCESS) {
                      if (err == MPI_ERR_IN_STATUS) {
                        //
                        // When MPI_Waitall returns MPI_ERR_IN_STATUS (a standard error
                        // class), it's telling us to check the error codes in the
                        // returned statuses.  In that case, we do so and generate a
                        // detailed exception message.
                        //
                        // Figure out which of the requests failed.
                        Array<std::pair<size_type, int> > errorLocationsAndCodes;
                        for (size_type k = 0; k < rawMpiStatuses.size(); ++k) {
                          const int curErr = rawMpiStatuses[k].MPI_ERROR;
                          if (curErr != MPI_SUCCESS) {
                            errorLocationsAndCodes.push_back (std::make_pair (k, curErr));
                          }
                        }
                        const size_type numErrs = errorLocationsAndCodes.size();
                        if (numErrs > 0) {
                          // There was at least one error.  Assemble a detailed
                          // exception message reporting which requests failed,
                          // their error codes, and their source
                          std::ostringstream os;
                          os << "Teuchos::MpiComm::waitAll: MPI_Waitall() failed with error \""
                             << mpiErrorCodeToString (err) << "\".  Of the " << count
                             << " total request" << (count != 1 ? "s" : "") << ", " << numErrs
                             << " failed.  Here are the indices of the failed requests, and the "
                            "error codes extracted from their returned MPI_Status objects:"
                             << std::endl;
                          for (size_type k = 0; k < numErrs; ++k) {
                            const size_type errInd = errorLocationsAndCodes[k].first;
                            os << "Request " << errInd << ": MPI_ERROR = "
                               << mpiErrorCodeToString (rawMpiStatuses[errInd].MPI_ERROR)
                               << std::endl;
                          }
                          if (someNullRequests) {
                            os << "  On input to MPI_Waitall, there was at least one MPI_"
                              "Request that was MPI_REQUEST_NULL.  MPI_Waitall should not "
                              "normally fail in that case, but we thought we should let you know "
                              "regardless.";
                          }
                          TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error, os.str());
                        }
                        // If there were no actual errors in the returned statuses,
                        // well, then I guess everything is OK.  Just keep going.
                      }
                      else {
                        std::ostringstream os;
                        os << "Teuchos::MpiComm::waitAll: MPI_Waitall() failed with error \""
                           << mpiErrorCodeToString (err) << "\".";
                        if (someNullRequests) {
                          os << "  On input to MPI_Waitall, there was at least one MPI_Request "
                            "that was MPI_REQUEST_NULL.  MPI_Waitall should not normally fail in "
                            "that case, but we thought we should let you know regardless.";
                        }
                        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error, os.str());
                      }
                    }
                
                    // Invalidate the input array of requests by setting all entries
                    // to null.
                    std::fill (requests.begin(), requests.end(), null);
                  }
                
                
                
                  // Called by the one-argument MpiComm::waitAll() variant.
                  template<typename Ordinal>
                  void
          10 ->   waitAllImpl (const ArrayView<RCP<CommRequest<Ordinal> > >& requests)
                  {
                    typedef typename ArrayView<RCP<CommRequest<Ordinal> > >::size_type size_type;
                    const size_type count = requests.size ();
                    if (count == 0) {
                      return; // No requests on which to wait
                    }
                
                    // MpiComm wraps MPI and can't expose any MPI structs or opaque
                    // objects.  Thus, we have to unpack requests into a separate
                    // array.  If that's too slow, then your code should just call
                    // into MPI directly.
                    //
                    // Pull out the raw MPI requests from the wrapped requests.
                    // MPI_Waitall should not fail if a request is MPI_REQUEST_NULL,
                    // but we keep track just to inform the user.
                    bool someNullRequests = false;
                    Array<MPI_Request> rawMpiRequests (count, MPI_REQUEST_NULL);
                    for (int i = 0; i < count; ++i) {
                      RCP<CommRequest<Ordinal> > request = requests[i];
                      if (! request.is_null ()) {
                        RCP<MpiCommRequestBase<Ordinal> > mpiRequest =
                          rcp_dynamic_cast<MpiCommRequestBase<Ordinal> > (request);
                        // releaseRawMpiRequest() sets the MpiCommRequest's raw
                        // MPI_Request to MPI_REQUEST_NULL.  This makes waitAll() not
                        // satisfy the strong exception guarantee.  That's OK because
                        // MPI_Waitall() doesn't promise that it satisfies the strong
                        // exception guarantee, and we would rather conservatively
                        // invalidate the handles than leave dangling requests around
                        // and risk users trying to wait on the same request twice.
                        rawMpiRequests[i] = mpiRequest->releaseRawMpiRequest ();
                      }
                      else { // Null requests map to MPI_REQUEST_NULL
                        rawMpiRequests[i] = MPI_REQUEST_NULL;
                        someNullRequests = true;
                      }
                    }
                
                    // This is the part where we've finally peeled off the wrapper and
                    // we can now interact with MPI directly.
                    //
                    // MPI lets us pass in the named constant MPI_STATUSES_IGNORE for
                    // the MPI_Status array output argument in MPI_Waitall(), which
                    // tells MPI not to bother writing out the statuses.
                    const int err = MPI_Waitall (count, rawMpiRequests.getRawPtr(),
                                                 MPI_STATUSES_IGNORE);
                
                    // In MPI_Waitall(), an error indicates that one or more requests
                    // failed.  In that case, there could be requests that completed
                    // (their MPI_Status' error field is MPI_SUCCESS), and other
                    // requests that have not completed yet but have not necessarily
                    // failed (MPI_PENDING).  We make no attempt here to wait on the
                    // pending requests.  It doesn't make sense for us to do so,
                    // because in general Teuchos::Comm doesn't attempt to provide
                    // robust recovery from failed messages.
                    if (err != MPI_SUCCESS) {
                      std::ostringstream os;
                      os << "Teuchos::MpiComm::waitAll: MPI_Waitall() failed with error \""
                         << mpiErrorCodeToString (err) << "\".";
                      if (someNullRequests) {
                        os << std::endl << "On input to MPI_Waitall, there was at least one "
                          "MPI_Request that was MPI_REQUEST_NULL.  MPI_Waitall should not "
                          "normally fail in that case, but we thought we should let you know "
                          "regardless.";
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error, os.str());
                    }
                
                    // Invalidate the input array of requests by setting all entries
                    // to null.  We delay this until the end, since some
                    // implementations of CommRequest might hold the only reference to
                    // the communication buffer, and we don't want that to go away
                    // until we've waited on the communication operation.
                    std::fill (requests.begin(), requests.end(), null);
                  }
                
                } // namespace (anonymous)
                
                
                
                template<typename Ordinal>
                void
           8 -> MpiComm<Ordinal>::
                waitAll (const ArrayView<RCP<CommRequest<Ordinal> > >& requests) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::waitAll(requests)" );
                  // Call the one-argument version of waitAllImpl, to avoid overhead
                  // of handling statuses (which the user didn't want anyway).
                  waitAllImpl<Ordinal> (requests);
                }
                
                
                template<typename Ordinal>
                void
           2 -> MpiComm<Ordinal>::
                waitAll (const ArrayView<RCP<CommRequest<Ordinal> > >& requests,
                         const ArrayView<RCP<CommStatus<Ordinal> > >& statuses) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::waitAll(requests, statuses)" );
                
                  typedef typename ArrayView<RCP<CommRequest<Ordinal> > >::size_type size_type;
                  const size_type count = requests.size();
                
                  TEUCHOS_TEST_FOR_EXCEPTION(count != statuses.size(),
                    std::invalid_argument, "Teuchos::MpiComm::waitAll: requests.size() = "
                    << count << " != statuses.size() = " << statuses.size() << ".");
                
                  Array<MPI_Status> rawMpiStatuses (count);
                  waitAllImpl<Ordinal> (requests, rawMpiStatuses());
                
                  // Repackage the raw MPI_Status structs into the wrappers.
                  for (size_type i = 0; i < count; ++i) {
                    statuses[i] = mpiCommStatus<Ordinal> (rawMpiStatuses[i]);
                  }
                }
                
                
                template<typename Ordinal>
                RCP<CommStatus<Ordinal> >
       ##### -> MpiComm<Ordinal>::wait (const Ptr<RCP<CommRequest<Ordinal> > >& request) const
                {
                  TEUCHOS_COMM_TIME_MONITOR( "Teuchos::MpiComm::wait(...)" );
                
                  if (is_null (*request)) {
                    return null; // Nothing to wait on ...
                  }
                  else {
                    RCP<CommStatus<Ordinal> > status = (*request)->wait ();
                    // mfh 22 Oct 2012: The unit tests expect waiting on the
                    // CommRequest to invalidate it by setting it to null.
                    *request = null;
                    return status;
                  }
                }
                
                template<typename Ordinal>
                RCP< Comm<Ordinal> >
       ##### -> MpiComm<Ordinal>::duplicate() const
                {
                  MPI_Comm origRawComm = *rawMpiComm_;
                  MPI_Comm newRawComm = MPI_COMM_NULL;
                  const int err = MPI_Comm_dup (origRawComm, &newRawComm);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::runtime_error, "Teuchos"
                    "::MpiComm::duplicate: MPI_Comm_dup failed with the following error: "
                    << mpiErrorCodeToString (err));
                
                  // Wrap the raw communicator, and pass the (const) wrapped
                  // communicator to MpiComm's constructor.  We created the raw comm,
                  // so we have to supply a function that frees it after use.
                  RCP<OpaqueWrapper<MPI_Comm> > wrapped =
                    opaqueWrapper<MPI_Comm> (newRawComm, details::safeCommFree);
                  // Since newComm's raw MPI_Comm is the result of an MPI_Comm_dup,
                  // its messages cannot collide with those of any other MpiComm.
                  // This means we can assign its tag without an MPI_Bcast.
                  RCP<MpiComm<Ordinal> > newComm =
                    rcp (new MpiComm<Ordinal> (wrapped.getConst (), minTag_));
                  return rcp_implicit_cast<Comm<Ordinal> > (newComm);
                }
                
                
                template<typename Ordinal>
                RCP< Comm<Ordinal> >
       ##### -> MpiComm<Ordinal>::split(const int color, const int key) const
                {
                  MPI_Comm newComm;
                  const int splitReturn =
                    MPI_Comm_split (*rawMpiComm_,
                                    color < 0 ? MPI_UNDEFINED : color,
                                    key,
                                    &newComm);
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    splitReturn != MPI_SUCCESS,
                    std::logic_error,
                    "Teuchos::MpiComm::split: Failed to create communicator with color "
                    << color << "and key " << key << ".  MPI_Comm_split failed with error \""
                    << mpiErrorCodeToString (splitReturn) << "\".");
                  if (newComm == MPI_COMM_NULL) {
                    return RCP< Comm<Ordinal> >();
                  } else {
                    RCP<const OpaqueWrapper<MPI_Comm> > wrapped =
                      opaqueWrapper<MPI_Comm> (newComm, details::safeCommFree);
                    // Since newComm's raw MPI_Comm is the result of an
                    // MPI_Comm_split, its messages cannot collide with those of any
                    // other MpiComm.  This means we can assign its tag without an
                    // MPI_Bcast.
                    return rcp (new MpiComm<Ordinal> (wrapped, minTag_));
                  }
                }
                
                
                template<typename Ordinal>
                RCP< Comm<Ordinal> >
       ##### -> MpiComm<Ordinal>::createSubcommunicator(const ArrayView<const int> &ranks) const
                {
                  int err = MPI_SUCCESS; // For error codes returned by MPI functions
                
                  // Get the group that this communicator is in.
                  MPI_Group thisGroup;
                  err = MPI_Comm_group (*rawMpiComm_, &thisGroup);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::logic_error,
                    "Failed to obtain the current communicator's group.  "
                    "MPI_Comm_group failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  // Create a new group with the specified members.
                  MPI_Group newGroup;
                  // It's rude to cast away const, but MPI functions demand it.
                  //
                  // NOTE (mfh 14 Aug 2012) Please don't ask for &ranks[0] unless you
                  // know that ranks.size() > 0.  That's why I'm using getRawPtr().
                  err = MPI_Group_incl (thisGroup, ranks.size(),
                                        const_cast<int*> (ranks.getRawPtr ()), &newGroup);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::logic_error,
                    "Failed to create subgroup.  MPI_Group_incl failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  // Create a new communicator from the new group.
                  MPI_Comm newComm;
                  try {
                    err = MPI_Comm_create (*rawMpiComm_, newGroup, &newComm);
                    TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::logic_error,
                      "Failed to create subcommunicator.  MPI_Comm_create failed with error \""
                      << mpiErrorCodeToString (err) << "\".");
                  } catch (...) {
                    // Attempt to free the new group before rethrowing.  If
                    // successful, this will prevent a memory leak due to the "lost"
                    // group that was allocated successfully above.  Since we're
                    // throwing std::logic_error anyway, we can only promise
                    // best-effort recovery; thus, we don't check the error code.
                    (void) MPI_Group_free (&newGroup);
                    (void) MPI_Group_free (&thisGroup);
                    throw;
                  }
                
                  // We don't need the group any more, so free it.
                  err = MPI_Group_free (&newGroup);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::logic_error,
                    "Failed to free subgroup.  MPI_Group_free failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                  err = MPI_Group_free (&thisGroup);
                  TEUCHOS_TEST_FOR_EXCEPTION(err != MPI_SUCCESS, std::logic_error,
                    "Failed to free subgroup.  MPI_Group_free failed with error \""
                    << mpiErrorCodeToString (err) << "\".");
                
                  if (newComm == MPI_COMM_NULL) {
                    return RCP<Comm<Ordinal> > ();
                  } else {
                    using Teuchos::details::safeCommFree;
                    typedef OpaqueWrapper<MPI_Comm> ow_type;
                    RCP<const ow_type> wrapper =
                      rcp_implicit_cast<const ow_type> (opaqueWrapper (newComm, safeCommFree));
                    // Since newComm's raw MPI_Comm is the result of an
                    // MPI_Comm_create, its messages cannot collide with those of any
                    // other MpiComm.  This means we can assign its tag without an
                    // MPI_Bcast.
                    return rcp (new MpiComm<Ordinal> (wrapper, minTag_));
                  }
                }
                
                
                // Overridden from Describable
                
                
                template<typename Ordinal>
       ##### -> std::string MpiComm<Ordinal>::description() const
                {
                  std::ostringstream oss;
                  oss
                    << typeName(*this)
                    << "{"
                    << "size="<<size_
                    << ",rank="<<rank_
                    << ",rawMpiComm="<<static_cast<MPI_Comm>(*rawMpiComm_)
                    <<"}";
                  return oss.str();
                }
                
                
                #ifdef TEUCHOS_MPI_COMM_DUMP
                template<typename Ordinal>
                bool MpiComm<Ordinal>::show_dump = false;
                #endif
                
                
                // private
                
                
                template<typename Ordinal>
                void MpiComm<Ordinal>::assertRank(const int rank, const std::string &rankName) const
                {
                  TEUCHOS_TEST_FOR_EXCEPTION(
                    ! ( 0 <= rank && rank < size_ ), std::logic_error
                    ,"Error, "<<rankName<<" = " << rank << " is not < 0 or is not"
                    " in the range [0,"<<size_-1<<"]!"
                    );
                }
                
                
                } // namespace Teuchos
                
                
                template<typename Ordinal>
                Teuchos::RCP<Teuchos::MpiComm<Ordinal> >
                Teuchos::createMpiComm(
                  const RCP<const OpaqueWrapper<MPI_Comm> > &rawMpiComm
                  )
                {
                  if( rawMpiComm.get()!=NULL && *rawMpiComm != MPI_COMM_NULL )
                    return rcp(new MpiComm<Ordinal>(rawMpiComm));
                  return Teuchos::null;
                }
                
                
                template<typename Ordinal>
                MPI_Comm
                Teuchos::getRawMpiComm(const Comm<Ordinal> &comm)
                {
                  return *(
                    dyn_cast<const MpiComm<Ordinal> >(comm).getRawMpiComm()
                    );
                }
                
                
                #endif // HAVE_TEUCHOS_MPI
                #endif // TEUCHOS_MPI_COMM_HPP
                


Top 10 Lines:

     Line      Count

      946         26
      953         19
     1488         10
     1570          8
      145          4
     1033          4
      973          2
     1582          2
      377          1
      896          1

Execution Summary:

       36   Executable lines in this file
       36   Lines executed
   100.00   Percent of the file executed

       78   Total number of line executions
     2.17   Average executions per line


*** File /opt/gnu/gcc/include/c++/4.9.2/sstream:
                // String based streams -*- C++ -*-
                
                // Copyright (C) 1997-2014 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/sstream
                 *  This is a Standard C++ Library header.
                 */
                
                //
                // ISO C++ 14882: 27.7  String-based streams
                //
                
                #ifndef _GLIBCXX_SSTREAM
                #define _GLIBCXX_SSTREAM 1
                
                #pragma GCC system_header
                
                #include <istream>
                #include <ostream>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // [27.7.1] template class basic_stringbuf
                  /**
                   *  @brief  The actual work of input and output (for std::string).
                   *  @ingroup io
                   *
                   *  @tparam _CharT  Type of character stream.
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  This class associates either or both of its input and output sequences
                   *  with a sequence of characters, which can be initialized from, or made
                   *  available as, a @c std::basic_string.  (Paraphrased from [27.7.1]/1.)
                   *
                   *  For this class, open modes (of type @c ios_base::openmode) have
                   *  @c in set if the input sequence can be read, and @c out set if the
                   *  output sequence can be written.
                  */
                  template<typename _CharT, typename _Traits, typename _Alloc>
       ##### ->     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
                    {
                    public:
                      // Types:
                      typedef _CharT 					char_type;
                      typedef _Traits 					traits_type;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 251. basic_stringbuf missing allocator_type
                      typedef _Alloc				       	allocator_type;
                      typedef typename traits_type::int_type 		int_type;
                      typedef typename traits_type::pos_type 		pos_type;
                      typedef typename traits_type::off_type 		off_type;
                
                      typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
                      typedef basic_string<char_type, _Traits, _Alloc> 	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                
                    protected:
                      /// Place to stash in || out || in | out settings for current stringbuf.
                      ios_base::openmode 	_M_mode;
                
                      // Data Members:
                      __string_type 		_M_string;
                
                    public:
                      // Constructors:
                      /**
                       *  @brief  Starts with an empty string buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  The default constructor initializes the parent class using its
                       *  own default ctor.
                      */
                      explicit
                      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
                      : __streambuf_type(), _M_mode(__mode), _M_string()
                      { }
                
                      /**
                       *  @brief  Starts with an existing string buffer.
                       *  @param  __str  A string to copy as a starting buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  This constructor initializes the parent class using its
                       *  own default ctor.
                      */
                      explicit
                      basic_stringbuf(const __string_type& __str,
                		      ios_base::openmode __mode = ios_base::in | ios_base::out)
                      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
                      { _M_stringbuf_init(__mode); }
                
                      // Get and set:
                      /**
                       *  @brief  Copying out the string buffer.
                       *  @return  A copy of one of the underlying sequences.
                       *
                       *  <em>If the buffer is only created in input mode, the underlying
                       *  character sequence is equal to the input sequence; otherwise, it
                       *  is equal to the output sequence.</em> [27.7.1.2]/1
                      */
                      __string_type
                      str() const
                      {
                	__string_type __ret;
                	if (this->pptr())
                	  {
                	    // The current egptr() may not be the actual string end.
                	    if (this->pptr() > this->egptr())
                	      __ret = __string_type(this->pbase(), this->pptr());
                	    else
                 	      __ret = __string_type(this->pbase(), this->egptr());
                	  }
                	else
                	  __ret = _M_string;
                	return __ret;
                      }
                
                      /**
                       *  @brief  Setting a new buffer.
                       *  @param  __s  The string to use as a new sequence.
                       *
                       *  Deallocates any previous stored sequence, then copies @a s to
                       *  use as a new one.
                      */
                      void
                      str(const __string_type& __s)
                      {
                	// Cannot use _M_string = __s, since v3 strings are COW.
                	_M_string.assign(__s.data(), __s.size());
                	_M_stringbuf_init(_M_mode);
                      }
                
                    protected:
                      // Common initialization code goes here.
                      void
                      _M_stringbuf_init(ios_base::openmode __mode)
                      {
                	_M_mode = __mode;
                	__size_type __len = 0;
                	if (_M_mode & (ios_base::ate | ios_base::app))
                	  __len = _M_string.size();
                	_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
                      }
                
                      virtual streamsize
                      showmanyc()
                      { 
                	streamsize __ret = -1;
                	if (_M_mode & ios_base::in)
                	  {
                	    _M_update_egptr();
                	    __ret = this->egptr() - this->gptr();
                	  }
                	return __ret;
                      }
                
                      virtual int_type
                      underflow();
                
                      virtual int_type
                      pbackfail(int_type __c = traits_type::eof());
                
                      virtual int_type
                      overflow(int_type __c = traits_type::eof());
                
                      /**
                       *  @brief  Manipulates the buffer.
                       *  @param  __s  Pointer to a buffer area.
                       *  @param  __n  Size of @a __s.
                       *  @return  @c this
                       *
                       *  If no buffer has already been created, and both @a __s and @a __n are
                       *  non-zero, then @c __s is used as a buffer; see
                       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html
                       *  for more.
                      */
                      virtual __streambuf_type*
                      setbuf(char_type* __s, streamsize __n)
                      {
                	if (__s && __n >= 0)
                	  {
                	    // This is implementation-defined behavior, and assumes
                	    // that an external char_type array of length __n exists
                	    // and has been pre-allocated. If this is not the case,
                	    // things will quickly blow up.
                	    
                	    // Step 1: Destroy the current internal array.
                	    _M_string.clear();
                	    
                	    // Step 2: Use the external array.
                	    _M_sync(__s, __n, 0);
                	  }
                	return this;
                      }
                
                      virtual pos_type
                      seekoff(off_type __off, ios_base::seekdir __way,
                	      ios_base::openmode __mode = ios_base::in | ios_base::out);
                
                      virtual pos_type
                      seekpos(pos_type __sp,
                	      ios_base::openmode __mode = ios_base::in | ios_base::out);
                
                      // Internal function for correctly updating the internal buffer
                      // for a particular _M_string, due to initialization or re-sizing
                      // of an existing _M_string.
                      void
                      _M_sync(char_type* __base, __size_type __i, __size_type __o);
                
                      // Internal function for correctly updating egptr() to the actual
                      // string end.
                      void
                      _M_update_egptr()
                      {
                	const bool __testin = _M_mode & ios_base::in;
                	if (this->pptr() && this->pptr() > this->egptr())
                	  {
                	    if (__testin)
                	      this->setg(this->eback(), this->gptr(), this->pptr());
                	    else
                	      this->setg(this->pptr(), this->pptr(), this->pptr());
                	  }
                      }
                
                      // Works around the issue with pbump, part of the protected
                      // interface of basic_streambuf, taking just an int.
                      void
                      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
                    };
                
                
                  // [27.7.2] Template class basic_istringstream
                  /**
                   *  @brief  Controlling input for std::string.
                   *  @ingroup io
                   *
                   *  @tparam _CharT  Type of character stream.
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  This class supports reading from objects of type std::basic_string,
                   *  using the inherited functions from std::basic_istream.  To control
                   *  the associated sequence, an instance of std::basic_stringbuf is used,
                   *  which this page refers to as @c sb.
                  */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_istringstream : public basic_istream<_CharT, _Traits>
                    {
                    public:
                      // Types:
                      typedef _CharT 					char_type;
                      typedef _Traits 					traits_type;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 251. basic_stringbuf missing allocator_type
                      typedef _Alloc				       	allocator_type;
                      typedef typename traits_type::int_type 		int_type;
                      typedef typename traits_type::pos_type 		pos_type;
                      typedef typename traits_type::off_type 		off_type;
                
                      // Non-standard types:
                      typedef basic_string<_CharT, _Traits, _Alloc> 	__string_type;
                      typedef basic_stringbuf<_CharT, _Traits, _Alloc> 	__stringbuf_type;
                      typedef basic_istream<char_type, traits_type>	__istream_type;
                
                    private:
                      __stringbuf_type	_M_stringbuf;
                
                    public:
                      // Constructors:
                      /**
                       *  @brief  Default constructor starts with an empty string buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  @c ios_base::in is automatically included in @a __mode.
                       *
                       *  Initializes @c sb using @c __mode|in, and passes @c &sb to the base
                       *  class initializer.  Does not allocate any buffer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
                      basic_istringstream(ios_base::openmode __mode = ios_base::in)
                      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  Starts with an existing string buffer.
                       *  @param  __str  A string to copy as a starting buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  @c ios_base::in is automatically included in @a mode.
                       *
                       *  Initializes @c sb using @a str and @c mode|in, and passes @c &sb
                       *  to the base class initializer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
                      basic_istringstream(const __string_type& __str,
                			  ios_base::openmode __mode = ios_base::in)
                      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  The destructor does nothing.
                       *
                       *  The buffer is deallocated by the stringbuf object, not the
                       *  formatting stream.
                      */
                      ~basic_istringstream()
                      { }
                
                      // Members:
                      /**
                       *  @brief  Accessing the underlying buffer.
                       *  @return  The current basic_stringbuf buffer.
                       *
                       *  This hides both signatures of std::basic_ios::rdbuf().
                      */
                      __stringbuf_type*
                      rdbuf() const
                      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
                
                      /**
                       *  @brief  Copying out the string buffer.
                       *  @return  @c rdbuf()->str()
                      */
                      __string_type
                      str() const
                      { return _M_stringbuf.str(); }
                
                      /**
                       *  @brief  Setting a new buffer.
                       *  @param  __s  The string to use as a new sequence.
                       *
                       *  Calls @c rdbuf()->str(s).
                      */
                      void
                      str(const __string_type& __s)
                      { _M_stringbuf.str(__s); }
                    };
                
                
                  // [27.7.3] Template class basic_ostringstream
                  /**
                   *  @brief  Controlling output for std::string.
                   *  @ingroup io
                   *
                   *  @tparam _CharT  Type of character stream.
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  This class supports writing to objects of type std::basic_string,
                   *  using the inherited functions from std::basic_ostream.  To control
                   *  the associated sequence, an instance of std::basic_stringbuf is used,
                   *  which this page refers to as @c sb.
                  */
                  template <typename _CharT, typename _Traits, typename _Alloc>
                    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
                    {
                    public:
                      // Types:
                      typedef _CharT 					char_type;
                      typedef _Traits 					traits_type;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 251. basic_stringbuf missing allocator_type
                      typedef _Alloc				       	allocator_type;
                      typedef typename traits_type::int_type 		int_type;
                      typedef typename traits_type::pos_type 		pos_type;
                      typedef typename traits_type::off_type 		off_type;
                
                      // Non-standard types:
                      typedef basic_string<_CharT, _Traits, _Alloc> 	__string_type;
                      typedef basic_stringbuf<_CharT, _Traits, _Alloc> 	__stringbuf_type;
                      typedef basic_ostream<char_type, traits_type>	__ostream_type;
                
                    private:
                      __stringbuf_type	_M_stringbuf;
                
                    public:
                      // Constructors/destructor:
                      /**
                       *  @brief  Default constructor starts with an empty string buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  @c ios_base::out is automatically included in @a mode.
                       *
                       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base
                       *  class initializer.  Does not allocate any buffer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
           1 ->       basic_ostringstream(ios_base::openmode __mode = ios_base::out)
                      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  Starts with an existing string buffer.
                       *  @param  __str  A string to copy as a starting buffer.
                       *  @param  __mode  Whether the buffer can read, or write, or both.
                       *
                       *  @c ios_base::out is automatically included in @a mode.
                       *
                       *  Initializes @c sb using @a str and @c mode|out, and passes @c &sb
                       *  to the base class initializer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
                      basic_ostringstream(const __string_type& __str,
                			  ios_base::openmode __mode = ios_base::out)
                      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  The destructor does nothing.
                       *
                       *  The buffer is deallocated by the stringbuf object, not the
                       *  formatting stream.
                      */
                      ~basic_ostringstream()
                      { }
                
                      // Members:
                      /**
                       *  @brief  Accessing the underlying buffer.
                       *  @return  The current basic_stringbuf buffer.
                       *
                       *  This hides both signatures of std::basic_ios::rdbuf().
                      */
                      __stringbuf_type*
                      rdbuf() const
                      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
                
                      /**
                       *  @brief  Copying out the string buffer.
                       *  @return  @c rdbuf()->str()
                      */
                      __string_type
                      str() const
                      { return _M_stringbuf.str(); }
                
                      /**
                       *  @brief  Setting a new buffer.
                       *  @param  __s  The string to use as a new sequence.
                       *
                       *  Calls @c rdbuf()->str(s).
                      */
                      void
                      str(const __string_type& __s)
                      { _M_stringbuf.str(__s); }
                    };
                
                
                  // [27.7.4] Template class basic_stringstream
                  /**
                   *  @brief  Controlling input and output for std::string.
                   *  @ingroup io
                   *
                   *  @tparam _CharT  Type of character stream.
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  This class supports reading from and writing to objects of type
                   *  std::basic_string, using the inherited functions from
                   *  std::basic_iostream.  To control the associated sequence, an instance
                   *  of std::basic_stringbuf is used, which this page refers to as @c sb.
                  */
                  template <typename _CharT, typename _Traits, typename _Alloc>
                    class basic_stringstream : public basic_iostream<_CharT, _Traits>
                    {
                    public:
                      // Types:
                      typedef _CharT 					char_type;
                      typedef _Traits 					traits_type;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 251. basic_stringbuf missing allocator_type
                      typedef _Alloc				       	allocator_type;
                      typedef typename traits_type::int_type 		int_type;
                      typedef typename traits_type::pos_type 		pos_type;
                      typedef typename traits_type::off_type 		off_type;
                
                      // Non-standard Types:
                      typedef basic_string<_CharT, _Traits, _Alloc> 	__string_type;
                      typedef basic_stringbuf<_CharT, _Traits, _Alloc> 	__stringbuf_type;
                      typedef basic_iostream<char_type, traits_type>	__iostream_type;
                
                    private:
                      __stringbuf_type	_M_stringbuf;
                
                    public:
                      // Constructors/destructors
                      /**
                       *  @brief  Default constructor starts with an empty string buffer.
                       *  @param  __m  Whether the buffer can read, or write, or both.
                       *
                       *  Initializes @c sb using the mode from @c __m, and passes @c
                       *  &sb to the base class initializer.  Does not allocate any
                       *  buffer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
                      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
                      : __iostream_type(), _M_stringbuf(__m)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  Starts with an existing string buffer.
                       *  @param  __str  A string to copy as a starting buffer.
                       *  @param  __m  Whether the buffer can read, or write, or both.
                       *
                       *  Initializes @c sb using @a __str and @c __m, and passes @c &sb
                       *  to the base class initializer.
                       *
                       *  That's a lie.  We initialize the base class with NULL, because the
                       *  string class does its own memory management.
                      */
                      explicit
                      basic_stringstream(const __string_type& __str,
                			 ios_base::openmode __m = ios_base::out | ios_base::in)
                      : __iostream_type(), _M_stringbuf(__str, __m)
                      { this->init(&_M_stringbuf); }
                
                      /**
                       *  @brief  The destructor does nothing.
                       *
                       *  The buffer is deallocated by the stringbuf object, not the
                       *  formatting stream.
                      */
                      ~basic_stringstream()
                      { }
                
                      // Members:
                      /**
                       *  @brief  Accessing the underlying buffer.
                       *  @return  The current basic_stringbuf buffer.
                       *
                       *  This hides both signatures of std::basic_ios::rdbuf().
                      */
                      __stringbuf_type*
                      rdbuf() const
                      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
                
                      /**
                       *  @brief  Copying out the string buffer.
                       *  @return  @c rdbuf()->str()
                      */
                      __string_type
                      str() const
                      { return _M_stringbuf.str(); }
                
                      /**
                       *  @brief  Setting a new buffer.
                       *  @param  __s  The string to use as a new sequence.
                       *
                       *  Calls @c rdbuf()->str(s).
                      */
                      void
                      str(const __string_type& __s)
                      { _M_stringbuf.str(__s); }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #include <bits/sstream.tcc>
                
                #endif /* _GLIBCXX_SSTREAM */


Top 10 Lines:

     Line      Count

      423          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /oasis/scratch/comet/vkotteda/temp_project/Software/trilinos/install/include/BelosTpetraAdapter.hpp:
                //@HEADER
                // ************************************************************************
                //
                //                 Belos: Block Linear Solvers Package
                //                  Copyright 2004 Sandia Corporation
                //
                // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
                // the U.S. Government retains certain rights in this software.
                //
                // Redistribution and use in source and binary forms, with or without
                // modification, are permitted provided that the following conditions are
                // met:
                //
                // 1. Redistributions of source code must retain the above copyright
                // notice, this list of conditions and the following disclaimer.
                //
                // 2. Redistributions in binary form must reproduce the above copyright
                // notice, this list of conditions and the following disclaimer in the
                // documentation and/or other materials provided with the distribution.
                //
                // 3. Neither the name of the Corporation nor the names of the
                // contributors may be used to endorse or promote products derived from
                // this software without specific prior written permission.
                //
                // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
                // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
                // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                //
                // Questions? Contact Michael A. Heroux (maherou@sandia.gov)
                //
                // ************************************************************************
                //@HEADER
                
                #ifndef BELOS_TPETRA_ADAPTER_HPP
                #define BELOS_TPETRA_ADAPTER_HPP
                
                /// \file BelosTpetraAdapter.hpp
                /// \brief Partial specialization of Belos::MultiVecTraits and
                ///   Belos::OperatorTraits for Tpetra objects.
                ///
                /// \section Belos_TpetraAdapter_sum Summary
                ///
                /// If you want to use Belos solvers with Tpetra objects, include this
                /// header file, along with the header file(s) for the solver(s) you
                /// want to use.  "Tpetra objects" means the following:
                ///   - Tpetra::MultiVector for the multivector type (MV)
                ///   - Tpetra::Operator for the operator type (OP)
                ///
                /// You may use any subclass of Tpetra::Operator here, as long as its
                /// template parameters match those of the Tpetra::MultiVector type.
                /// Many different Trilinos packages implement Tpetra::Operator
                /// subclasses.  For example, when solving a linear system Ax=b, you
                /// could use a Tpetra::CrsMatrix or Tpetra::RowMatrix for the matrix
                /// A, and a preconditioner from Ifpack2, Amesos2, or MueLu.
                ///
                /// \section Belos_TpetraAdapter_dev Note to Belos developers
                ///
                /// This partial specialization assumes that the first (Scalar)
                /// template parameter of Belos::MultiVecTraits and
                /// Belos::OperatorTraits matches the first template parameters of
                /// Tpetra::MultiVector and Tpetra::Operator.  In terms of Belos
                /// solvers, this means that the specialization assumes that the
                /// result of an inner product has the same type as any entry of the
                /// multivector or matrix.  This is true for most Scalar types of
                /// interest, but may not necessarily be true for certain Scalar types
                /// implemented in the Stokhos package, or when implementing
                /// mixed-precision solvers in certain ways.  If you don't know what
                /// this means, don't worry about it.  If you <i>do</i> know what this
                /// means, you might need to write your own partial specialization of
                /// Belos::MultiVecTraits and Belos::OperatorTraits, for a Scalar type
                /// different than that of the Tpetra::MultiVector or
                /// Tpetra::Operator.
                
                #include <Tpetra_MultiVector.hpp>
                #include <Tpetra_Operator.hpp>
                
                #include <Teuchos_Array.hpp>
                #include <Teuchos_Assert.hpp>
                #include <Teuchos_DefaultSerialComm.hpp>
                #include <Teuchos_ScalarTraits.hpp>
                
                #include <BelosConfigDefs.hpp>
                #include <BelosTypes.hpp>
                #include <BelosMultiVecTraits.hpp>
                #include <BelosOperatorTraits.hpp>
                
                #ifdef HAVE_BELOS_TSQR
                #  include <Tpetra_TsqrAdaptor.hpp>
                #endif // HAVE_BELOS_TSQR
                
                
                namespace Belos {
                
                  /// \brief Specialization of MultiVecTraits for MV = Tpetra::MultiVector.
                  ///
                  /// This interface lets Belos' solvers work directly with
                  /// Tpetra::MultiVector objects as the MultiVector type.  That type
                  /// corresponds to the MV template parameter, which is the second
                  /// template parameter (after Scalar) of most Belos classes.
                  ///
                  /// The four template parameters of this partial specialization
                  /// correspond exactly to the four template parameters of
                  /// Tpetra::MultiVector.  See the Tpetra::MultiVector documentation
                  /// for more information.
                  template<class Scalar, class LO, class GO, class Node>
                  class MultiVecTraits<Scalar, ::Tpetra::MultiVector<Scalar,LO,GO,Node> > {
                    typedef ::Tpetra::MultiVector<Scalar, LO, GO, Node> MV;
                  public:
                    /// \brief Create a new MultiVector with \c numVecs columns.
                    ///
                    /// The returned Tpetra::MultiVector has the same Tpetra::Map
                    /// (distribution over one or more parallel processes) as \c X.
                    /// Its entries are not initialized and have undefined values.
           9 ->     static Teuchos::RCP<MV> Clone (const MV& X, const int numVecs) {
                      Teuchos::RCP<MV> Y (new MV (X.getMap (), numVecs, false));
                      Y->setCopyOrView (Teuchos::View);
                      return Y;
                    }
                
                    //! Create and return a deep copy of X.
       ##### ->     static Teuchos::RCP<MV> CloneCopy (const MV& X)
                    {
                      // Make a deep copy of X.  The one-argument copy constructor
                      // does a shallow copy by default; the second argument tells it
                      // to do a deep copy.
                      Teuchos::RCP<MV> X_copy (new MV (X, Teuchos::Copy));
                      // Make Tpetra::MultiVector use the new view semantics.  This is
                      // a no-op for the Kokkos refactor version of Tpetra; it only
                      // does something for the "classic" version of Tpetra.  This
                      // shouldn't matter because Belos only handles MV through RCP
                      // and through this interface anyway, but it doesn't hurt to set
                      // it and make sure that it works.
                      X_copy->setCopyOrView (Teuchos::View);
                      return X_copy;
                    }
                
                    /// \brief Create and return a deep copy of the given columns of mv.
                    ///
                    /// \pre \code mv.getNumVectors() != 0 || index.size() == 0 \endcode
                    /// \pre For all k such that <tt>0 <= k < index.size()</tt>,
                    ///   \code
                    ///   0 <= index[k] < mv.getNumVectors();
                    ///   \endcode
                    /// \post If this method returns Y:
                    ///   \code
                    ///   Y->isConstantStride() && Y->getNumVectors() == index.size();
                    ///   \endcode
                    static Teuchos::RCP<MV>
                    CloneCopy (const MV& mv, const std::vector<int>& index)
                    {
                #ifdef HAVE_TPETRA_DEBUG
                      const char fnName[] = "Belos::MultiVecTraits::CloneCopy(mv,index)";
                      const size_t inNumVecs = mv.getNumVectors ();
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        index.size () > 0 && *std::min_element (index.begin (), index.end ()) < 0,
                        std::runtime_error, fnName << ": All indices must be nonnegative.");
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        index.size () > 0 &&
                        static_cast<size_t> (*std::max_element (index.begin (), index.end ())) >= inNumVecs,
                        std::runtime_error,
                        fnName << ": All indices must be strictly less than the number of "
                        "columns " << inNumVecs << " of the input multivector mv.");
                #endif // HAVE_TPETRA_DEBUG
                
                      // Tpetra wants an array of size_t, not of int.
                      Teuchos::Array<size_t> columns (index.size ());
                      for (std::vector<int>::size_type j = 0; j < index.size (); ++j) {
                        columns[j] = index[j];
                      }
                      // mfh 14 Aug 2014: Tpetra already detects and optimizes for a
                      // continuous column index range in MultiVector::subCopy, so we
                      // don't have to check here.
                      Teuchos::RCP<MV> X_copy = mv.subCopy (columns ());
                      X_copy->setCopyOrView (Teuchos::View);
                      return X_copy;
                    }
                
                    /// \brief Create and return a deep copy of the given columns of mv.
                    ///
                    /// \post If this method returns Y:
                    ///   \code
                    ///   Y->isConstantStride() && Y->getNumVectors() == index.size();
                    ///   \endcode
                    static Teuchos::RCP<MV>
                    CloneCopy (const MV& mv, const Teuchos::Range1D& index)
                    {
                      const bool validRange = index.size() > 0 &&
                        index.lbound() >= 0 &&
                        index.ubound() < GetNumberVecs(mv);
                      if (! validRange) { // invalid range; generate error message
                        std::ostringstream os;
                        os << "Belos::MultiVecTraits::CloneCopy(mv,index=["
                           << index.lbound() << "," << index.ubound() << "]): ";
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.size() == 0, std::invalid_argument,
                          os.str() << "Empty index range is not allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.lbound() < 0, std::invalid_argument,
                          os.str() << "Index range includes negative index/ices, which is not "
                          "allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.ubound() >= GetNumberVecs(mv), std::invalid_argument,
                          os.str() << "Index range exceeds number of vectors "
                          << mv.getNumVectors() << " in the input multivector.");
                        TEUCHOS_TEST_FOR_EXCEPTION(true, std::logic_error,
                          os.str() << "Should never get here!");
                      }
                      Teuchos::RCP<MV> X_copy = mv.subCopy (index);
                      X_copy->setCopyOrView (Teuchos::View);
                      return X_copy;
                    }
                
                    static Teuchos::RCP<MV>
           2 ->     CloneViewNonConst (MV& mv, const std::vector<int>& index)
                    {
                #ifdef HAVE_TPETRA_DEBUG
                      const char fnName[] = "Belos::MultiVecTraits::CloneViewNonConst(mv,index)";
                      const size_t numVecs = mv.getNumVectors ();
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        index.size () > 0 && *std::min_element (index.begin (), index.end ()) < 0,
                        std::invalid_argument,
                        fnName << ": All indices must be nonnegative.");
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        index.size () > 0 &&
                        static_cast<size_t> (*std::max_element (index.begin (), index.end ())) >= numVecs,
                        std::invalid_argument,
                        fnName << ": All indices must be strictly less than the number of "
                        "columns " << numVecs << " in the input MultiVector mv.");
                #endif // HAVE_TPETRA_DEBUG
                
                      // Tpetra wants an array of size_t, not of int.
                      Teuchos::Array<size_t> columns (index.size ());
                      for (std::vector<int>::size_type j = 0; j < index.size (); ++j) {
                        columns[j] = index[j];
                      }
                      // mfh 14 Aug 2014: Tpetra already detects and optimizes for a
                      // continuous column index range in
                      // MultiVector::subViewNonConst, so we don't have to check here.
                      Teuchos::RCP<MV> X_view = mv.subViewNonConst (columns ());
                      X_view->setCopyOrView (Teuchos::View);
                      return X_view;
                    }
                
                    static Teuchos::RCP<MV>
       ##### ->     CloneViewNonConst (MV& mv, const Teuchos::Range1D& index)
                    {
                      // NOTE (mfh 11 Jan 2011) We really should check for possible
                      // overflow of int here.  However, the number of columns in a
                      // multivector typically fits in an int.
                      const int numCols = static_cast<int> (mv.getNumVectors());
                      const bool validRange = index.size() > 0 &&
                        index.lbound() >= 0 && index.ubound() < numCols;
                      if (! validRange) {
                        std::ostringstream os;
                        os << "Belos::MultiVecTraits::CloneViewNonConst(mv,index=["
                           << index.lbound() << ", " << index.ubound() << "]): ";
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.size() == 0, std::invalid_argument,
                          os.str() << "Empty index range is not allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.lbound() < 0, std::invalid_argument,
                          os.str() << "Index range includes negative inde{x,ices}, which is "
                          "not allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.ubound() >= numCols, std::invalid_argument,
                          os.str() << "Index range exceeds number of vectors " << numCols
                          << " in the input multivector.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::logic_error,
                          os.str() << "Should never get here!");
                      }
                      Teuchos::RCP<MV> X_view = mv.subViewNonConst (index);
                      X_view->setCopyOrView (Teuchos::View);
                      return X_view;
                    }
                
                    static Teuchos::RCP<const MV>
          37 ->     CloneView (const MV& mv, const std::vector<int>& index)
                    {
                #ifdef HAVE_TPETRA_DEBUG
                      const char fnName[] = "Belos::MultiVecTraits<Scalar, "
                        "Tpetra::MultiVector<...> >::CloneView(mv,index)";
                      const size_t numVecs = mv.getNumVectors ();
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        *std::min_element (index.begin (), index.end ()) < 0,
                        std::invalid_argument,
                        fnName << ": All indices must be nonnegative.");
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        static_cast<size_t> (*std::max_element (index.begin (), index.end ())) >= numVecs,
                        std::invalid_argument,
                        fnName << ": All indices must be strictly less than the number of "
                        "columns " << numVecs << " in the input MultiVector mv.");
                #endif // HAVE_TPETRA_DEBUG
                
                      // Tpetra wants an array of size_t, not of int.
                      Teuchos::Array<size_t> columns (index.size ());
                      for (std::vector<int>::size_type j = 0; j < index.size (); ++j) {
                        columns[j] = index[j];
                      }
                      // mfh 14 Aug 2014: Tpetra already detects and optimizes for a
                      // continuous column index range in MultiVector::subView, so we
                      // don't have to check here.
                      Teuchos::RCP<const MV> X_view = mv.subView (columns);
                      Teuchos::rcp_const_cast<MV> (X_view)->setCopyOrView (Teuchos::View);
                      return X_view;
                    }
                
                    static Teuchos::RCP<const MV>
                    CloneView (const MV& mv, const Teuchos::Range1D& index)
                    {
                      // NOTE (mfh 11 Jan 2011) We really should check for possible
                      // overflow of int here.  However, the number of columns in a
                      // multivector typically fits in an int.
                      const int numCols = static_cast<int> (mv.getNumVectors());
                      const bool validRange = index.size() > 0 &&
                        index.lbound() >= 0 && index.ubound() < numCols;
                      if (! validRange) {
                        std::ostringstream os;
                        os << "Belos::MultiVecTraits::CloneView(mv, index=["
                           << index.lbound () << ", " << index.ubound() << "]): ";
                        TEUCHOS_TEST_FOR_EXCEPTION(index.size() == 0, std::invalid_argument,
                          os.str() << "Empty index range is not allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(index.lbound() < 0, std::invalid_argument,
                          os.str() << "Index range includes negative index/ices, which is not "
                          "allowed.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.ubound() >= numCols, std::invalid_argument,
                          os.str() << "Index range exceeds number of vectors " << numCols
                          << " in the input multivector.");
                        TEUCHOS_TEST_FOR_EXCEPTION(true, std::logic_error,
                          os.str() << "Should never get here!");
                      }
                      Teuchos::RCP<const MV> X_view = mv.subView (index);
                      Teuchos::rcp_const_cast<MV> (X_view)->setCopyOrView (Teuchos::View);
                      return X_view;
                    }
                
                    static ptrdiff_t GetGlobalLength (const MV& mv) {
                      return static_cast<ptrdiff_t> (mv.getGlobalLength ());
                    }
                
                    static int GetNumberVecs (const MV& mv) {
                      return static_cast<int> (mv.getNumVectors ());
                    }
                
                    static bool HasConstantStride (const MV& mv) {
                      return mv.isConstantStride ();
                    }
                
                    static void
                    MvTimesMatAddMv (Scalar alpha,
                                     const MV& A,
                                     const Teuchos::SerialDenseMatrix<int, Scalar>& B,
                                     Scalar beta,
                                     MV& mv)
                    {
                      using Teuchos::ArrayView;
                      using Teuchos::Comm;
                      using Teuchos::rcpFromRef;
                      typedef ::Tpetra::Map<LO, GO, Node> map_type;
                
                #ifdef HAVE_BELOS_TPETRA_TIMERS
                      const std::string timerName ("Belos::MVT::MvTimesMatAddMv");
                      Teuchos::RCP<Teuchos::Time> timer =
                        Teuchos::TimeMonitor::lookupCounter (timerName);
                      if (timer.is_null ()) {
                        timer = Teuchos::TimeMonitor::getNewCounter (timerName);
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        timer.is_null (), std::logic_error,
                        "Belos::MultiVecTraits::MvTimesMatAddMv: "
                        "Failed to look up timer \"" << timerName << "\".  "
                        "Please report this bug to the Belos developers.");
                
                      // This starts the timer.  It will be stopped on scope exit.
                      Teuchos::TimeMonitor timeMon (*timer);
                #endif // HAVE_BELOS_TPETRA_TIMERS
                
                      // Check if B is 1-by-1, in which case we can just call update()
                      if (B.numRows () == 1 && B.numCols () == 1) {
                        mv.update (alpha*B(0,0), A, beta);
                        return;
                      }
                
                      // Create local map
                      Teuchos::SerialComm<int> serialComm;
                      map_type LocalMap (B.numRows (), A.getMap ()->getIndexBase (),
                                         rcpFromRef<const Comm<int> > (serialComm),
                                         ::Tpetra::LocallyReplicated, A.getMap ()->getNode ());
                      // encapsulate Teuchos::SerialDenseMatrix data in ArrayView
                      ArrayView<const Scalar> Bvalues (B.values (), B.stride () * B.numCols ());
                      // create locally replicated MultiVector with a copy of this data
                      MV B_mv (rcpFromRef (LocalMap), Bvalues, B.stride (), B.numCols ());
                      mv.multiply (Teuchos::NO_TRANS, Teuchos::NO_TRANS, alpha, A, B_mv, beta);
                    }
                
                    /// \brief <tt>mv := alpha*A + beta*B</tt>
                    ///
                    /// The Tpetra specialization of this method ignores and
                    /// completely overwrites any NaN or Inf entries in A.  Thus, it
                    /// does <i>not</i> mean the same thing as <tt>mv := 0*mv +
                    /// alpha*A + beta*B</tt> in IEEE 754 floating-point arithmetic.
                    /// (Remember that NaN*0 = NaN.)
                    static void
                    MvAddMv (Scalar alpha,
                             const MV& A,
                             Scalar beta,
                             const MV& B,
                             MV& mv)
                    {
                      mv.update (alpha, A, beta, B, Teuchos::ScalarTraits<Scalar>::zero ());
                    }
                
                    static void MvScale (MV& mv, Scalar alpha) {
                      mv.scale (alpha);
                    }
                
                    static void MvScale (MV& mv, const std::vector<Scalar>& alphas) {
                      mv.scale (alphas);
                    }
                
                    static void
                    MvTransMv (const Scalar alpha,
                               const MV& A,
                               const MV& B,
                               Teuchos::SerialDenseMatrix<int,Scalar>& C)
                    {
                      using ::Tpetra::LocallyReplicated;
                      using Teuchos::Comm;
                      using Teuchos::RCP;
                      using Teuchos::rcp;
                      using Teuchos::TimeMonitor;
                      typedef ::Tpetra::Map<LO,GO,Node> map_type;
                
                #ifdef HAVE_BELOS_TPETRA_TIMERS
                      const std::string timerName ("Belos::MVT::MvTransMv");
                      RCP<Teuchos::Time> timer = TimeMonitor::lookupCounter (timerName);
                      if (timer.is_null ()) {
                        timer = TimeMonitor::getNewCounter (timerName);
                      }
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        timer.is_null (), std::logic_error, "Belos::MvTransMv: "
                        "Failed to look up timer \"" << timerName << "\".  "
                        "Please report this bug to the Belos developers.");
                
                      // This starts the timer.  It will be stopped on scope exit.
                      TimeMonitor timeMon (*timer);
                #endif // HAVE_BELOS_TPETRA_TIMERS
                
                      // Form alpha * A^H * B, then copy into the SerialDenseMatrix.
                      // We will create a multivector C_mv from a a local map.  This
                      // map has a serial comm, the purpose being to short-circuit the
                      // MultiVector::reduce() call at the end of
                      // MultiVector::multiply().  Otherwise, the reduced multivector
                      // data would be copied back to the GPU, only to turn around and
                      // have to get it back here.  This saves us a round trip for
                      // this data.
                      const int numRowsC = C.numRows ();
                      const int numColsC = C.numCols ();
                      const int strideC  = C.stride ();
                
                      // Check if numRowsC == numColsC == 1, in which case we can call dot()
                      if (numRowsC == 1 && numColsC == 1) {
                        if (alpha == Teuchos::ScalarTraits<Scalar>::zero ()) {
                          // Short-circuit, as required by BLAS semantics.
                          C(0,0) = alpha;
                          return;
                        }
                        A.dot (B, Teuchos::ArrayView<Scalar> (C.values (), 1));
                        if (alpha != Teuchos::ScalarTraits<Scalar>::one ()) {
                          C(0,0) *= alpha;
                        }
                        return;
                      }
                
                      // get comm
                      RCP<const Comm<int> > pcomm = A.getMap ()->getComm ();
                
                      // create local map with comm
                      RCP<const map_type> LocalMap =
                        rcp (new map_type (numRowsC, 0, pcomm, LocallyReplicated,
                                           A.getMap ()->getNode ()));
                      // create local multivector to hold the result
                      const bool INIT_TO_ZERO = true;
                      MV C_mv (LocalMap, numColsC, INIT_TO_ZERO);
                
                      // multiply result into local multivector
                      C_mv.multiply (Teuchos::CONJ_TRANS, Teuchos::NO_TRANS, alpha, A, B,
                                     Teuchos::ScalarTraits<Scalar>::zero ());
                
                      // create arrayview encapsulating the Teuchos::SerialDenseMatrix
                      Teuchos::ArrayView<Scalar> C_view (C.values (), strideC * numColsC);
                
                      // No accumulation to do (since Tpetra has already done it);
                      // simply extract the multivector data into C.
                      // Extract a copy of the result into the array view
                      // (and therefore, the SerialDenseMatrix).
                      C_mv.get1dCopy (C_view, strideC);
                    }
                
                    //! For all columns j of A, set <tt>dots[j] := A[j]^T * B[j]</tt>.
                    static void
          12 ->     MvDot (const MV& A, const MV& B, std::vector<Scalar> &dots)
                    {
                      const size_t numVecs = A.getNumVectors ();
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        numVecs != B.getNumVectors (), std::invalid_argument,
                        "Belos::MultiVecTraits::MvDot(A,B,dots): "
                        "A and B must have the same number of columns.  "
                        "A has " << numVecs << " column(s), "
                        "but B has " << B.getNumVectors () << " column(s).");
                #ifdef HAVE_TPETRA_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        dots.size() < numVecs, std::invalid_argument,
                        "Belos::MultiVecTraits::MvDot(A,B,dots): "
                        "The output array 'dots' must have room for all dot products.  "
                        "A and B each have " << numVecs << " column(s), "
                        "but 'dots' only has " << dots.size() << " entry(/ies).");
                #endif // HAVE_TPETRA_DEBUG
                
                      Teuchos::ArrayView<Scalar> av (dots);
                      A.dot (B, av (0, numVecs));
                    }
                
                    //! For all columns j of mv, set <tt>normvec[j] = norm(mv[j])</tt>.
                    static void
           5 ->     MvNorm (const MV& mv,
                            std::vector<typename Teuchos::ScalarTraits<Scalar>::magnitudeType>& normvec,
                            NormType type=TwoNorm)
                    {
                      typedef typename Teuchos::ScalarTraits<Scalar>::magnitudeType magnitude_type;
                #ifdef HAVE_TPETRA_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        normvec.size () < static_cast<std::vector<int>::size_type> (mv.getNumVectors ()),
                        std::invalid_argument,
                        "Belos::MultiVecTraits::MvNorm(mv,normvec): The normvec output "
                        "argument must have at least as many entries as the number of vectors "
                        "(columns) in the MultiVector mv.  normvec.size() = " << normvec.size ()
                        << " < mv.getNumVectors() = " << mv.getNumVectors () << ".");
                #endif // HAVE_TPETRA_DEBUG
                      Teuchos::ArrayView<magnitude_type> av (normvec);
                      switch (type) {
                      case OneNorm:
                        mv.norm1 (av (0, mv.getNumVectors ()));
                        break;
                      case TwoNorm:
                        mv.norm2 (av (0, mv.getNumVectors ()));
                        break;
                      case InfNorm:
                        mv.normInf (av (0,mv.getNumVectors ()));
                        break;
                      default:
                        // Throw logic_error rather than invalid_argument, because if
                        // we get here, it's probably the fault of a Belos solver,
                        // rather than a user giving Belos an invalid input.
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::logic_error,
                          "Belos::MultiVecTraits::MvNorm: Invalid NormType value " << type
                          << ".  Valid values are OneNorm=" << OneNorm << ", TwoNorm="
                          << TwoNorm <<", and InfNorm=" << InfNorm << ".  If you are a Belos "
                          "user and have not modified Belos in any way, and you get this "
                          "message, then this is probably a bug in the Belos solver you were "
                          "using.  Please report this to the Belos developers.");
                      }
                    }
                
                    static void
                    SetBlock (const MV& A, const std::vector<int>& index, MV& mv)
                    {
                      using Teuchos::Range1D;
                      using Teuchos::RCP;
                      const size_t inNumVecs = A.getNumVectors ();
                #ifdef HAVE_TPETRA_DEBUG
                      TEUCHOS_TEST_FOR_EXCEPTION(
                        inNumVecs < static_cast<size_t> (index.size ()), std::invalid_argument,
                        "Belos::MultiVecTraits::SetBlock(A,index,mv): 'index' argument must "
                        "have no more entries as the number of columns in the input MultiVector"
                        " A.  A.getNumVectors() = " << inNumVecs << " < index.size () = "
                        << index.size () << ".");
                #endif // HAVE_TPETRA_DEBUG
                      RCP<MV> mvsub = CloneViewNonConst (mv, index);
                      if (inNumVecs > static_cast<size_t> (index.size ())) {
                        RCP<const MV> Asub = A.subView (Range1D (0, index.size () - 1));
                        ::Tpetra::deep_copy (*mvsub, *Asub);
                      } else {
                        ::Tpetra::deep_copy (*mvsub, A);
                      }
                    }
                
                    static void
                    SetBlock (const MV& A, const Teuchos::Range1D& index, MV& mv)
                    {
                      // Range1D bounds are signed; size_t is unsigned.
                      // Assignment of Tpetra::MultiVector is a deep copy.
                
                      // Tpetra::MultiVector::getNumVectors() returns size_t.  It's
                      // fair to assume that the number of vectors won't overflow int,
                      // since the typical use case of multivectors involves few
                      // columns, but it's friendly to check just in case.
                      const size_t maxInt =
                        static_cast<size_t> (Teuchos::OrdinalTraits<int>::max ());
                      const bool overflow =
                        maxInt < A.getNumVectors () && maxInt < mv.getNumVectors ();
                      if (overflow) {
                        std::ostringstream os;
                        os << "Belos::MultiVecTraits::SetBlock(A, index=[" << index.lbound ()
                           << ", " << index.ubound () << "], mv): ";
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          maxInt < A.getNumVectors (), std::range_error, os.str () << "Number "
                          "of columns (size_t) in the input MultiVector 'A' overflows int.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          maxInt < mv.getNumVectors (), std::range_error, os.str () << "Number "
                          "of columns (size_t) in the output MultiVector 'mv' overflows int.");
                      }
                      // We've already validated the static casts above.
                      const int numColsA = static_cast<int> (A.getNumVectors ());
                      const int numColsMv = static_cast<int> (mv.getNumVectors ());
                      // 'index' indexes into mv; it's the index set of the target.
                      const bool validIndex =
                        index.lbound () >= 0 && index.ubound () < numColsMv;
                      // We can't take more columns out of A than A has.
                      const bool validSource = index.size () <= numColsA;
                
                      if (! validIndex || ! validSource) {
                        std::ostringstream os;
                        os << "Belos::MultiVecTraits::SetBlock(A, index=[" << index.lbound ()
                           << ", " << index.ubound () << "], mv): ";
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.lbound() < 0, std::invalid_argument,
                          os.str() << "Range lower bound must be nonnegative.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.ubound() >= numColsMv, std::invalid_argument,
                          os.str() << "Range upper bound must be less than the number of "
                          "columns " << numColsA << " in the 'mv' output argument.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          index.size() > numColsA, std::invalid_argument,
                          os.str() << "Range must have no more elements than the number of "
                          "columns " << numColsA << " in the 'A' input argument.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::logic_error, "Should never get here!");
                      }
                
                      // View of the relevant column(s) of the target multivector mv.
                      // We avoid view creation overhead by only creating a view if
                      // the index range is different than [0, (# columns in mv) - 1].
                      Teuchos::RCP<MV> mv_view;
                      if (index.lbound () == 0 && index.ubound () + 1 == numColsMv) {
                        mv_view = Teuchos::rcpFromRef (mv); // Non-const, non-owning RCP
                      } else {
                        mv_view = CloneViewNonConst (mv, index);
                      }
                
                      // View of the relevant column(s) of the source multivector A.
                      // If A has fewer columns than mv_view, then create a view of
                      // the first index.size() columns of A.
                      Teuchos::RCP<const MV> A_view;
                      if (index.size () == numColsA) {
                        A_view = Teuchos::rcpFromRef (A); // Const, non-owning RCP
                      } else {
                        A_view = CloneView (A, Teuchos::Range1D (0, index.size () - 1));
                      }
                
                      ::Tpetra::deep_copy (*mv_view, *A_view);
                    }
                
           2 ->     static void Assign (const MV& A, MV& mv)
                    {
                      const char errPrefix[] = "Belos::MultiVecTraits::Assign(A, mv): ";
                
                      // Range1D bounds are signed; size_t is unsigned.
                      // Assignment of Tpetra::MultiVector is a deep copy.
                
                      // Tpetra::MultiVector::getNumVectors() returns size_t.  It's
                      // fair to assume that the number of vectors won't overflow int,
                      // since the typical use case of multivectors involves few
                      // columns, but it's friendly to check just in case.
                      const size_t maxInt =
                        static_cast<size_t> (Teuchos::OrdinalTraits<int>::max ());
                      const bool overflow =
                        maxInt < A.getNumVectors () && maxInt < mv.getNumVectors ();
                      if (overflow) {
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          maxInt < A.getNumVectors(), std::range_error,
                          errPrefix << "Number of columns in the input multivector 'A' "
                          "(a size_t) overflows int.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          maxInt < mv.getNumVectors(), std::range_error,
                          errPrefix << "Number of columns in the output multivector 'mv' "
                          "(a size_t) overflows int.");
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::logic_error, "Should never get here!");
                      }
                      // We've already validated the static casts above.
                      const int numColsA = static_cast<int> (A.getNumVectors ());
                      const int numColsMv = static_cast<int> (mv.getNumVectors ());
                      if (numColsA > numColsMv) {
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          numColsA > numColsMv, std::invalid_argument,
                          errPrefix << "Input multivector 'A' has " << numColsA << " columns, "
                          "but output multivector 'mv' has only " << numColsMv << " columns.");
                        TEUCHOS_TEST_FOR_EXCEPTION(true, std::logic_error, "Should never get here!");
                      }
                      if (numColsA == numColsMv) {
                        ::Tpetra::deep_copy (mv, A);
                      } else {
                        Teuchos::RCP<MV> mv_view =
                          CloneViewNonConst (mv, Teuchos::Range1D (0, numColsA - 1));
                        ::Tpetra::deep_copy (*mv_view, A);
                      }
                    }
                
                    static void MvRandom (MV& mv) {
                      mv.randomize ();
                    }
                
                    static void
                    MvInit (MV& mv, const Scalar alpha = Teuchos::ScalarTraits<Scalar>::zero ())
                    {
                      mv.putScalar (alpha);
                    }
                
                    static void MvPrint (const MV& mv, std::ostream& os) {
                      Teuchos::FancyOStream fos (Teuchos::rcpFromRef (os));
                      mv.describe (fos, Teuchos::VERB_EXTREME);
                    }
                
                #ifdef HAVE_BELOS_TSQR
                    /// \typedef tsqr_adaptor_type
                    /// \brief TsqrAdaptor specialization for Tpetra::MultiVector
                    typedef ::Tpetra::TsqrAdaptor< ::Tpetra::MultiVector<Scalar, LO, GO, Node> > tsqr_adaptor_type;
                #endif // HAVE_BELOS_TSQR
                  };
                
                  //! Partial specialization of OperatorTraits for Tpetra objects.
                  template <class Scalar, class LO, class GO, class Node>
                  class OperatorTraits<Scalar,
                                       ::Tpetra::MultiVector<Scalar,LO,GO,Node>,
                                       ::Tpetra::Operator<Scalar,LO,GO,Node> >
                  {
                  public:
                    static void
                    Apply (const ::Tpetra::Operator<Scalar,LO,GO,Node>& Op,
                           const ::Tpetra::MultiVector<Scalar,LO,GO,Node>& X,
                           ::Tpetra::MultiVector<Scalar,LO,GO,Node>& Y,
                           const ETrans trans = NOTRANS)
                    {
                      Teuchos::ETransp teuchosTrans = Teuchos::NO_TRANS;
                      if (trans == NOTRANS) {
                        teuchosTrans = Teuchos::NO_TRANS;
                      } else if (trans == TRANS) {
                        teuchosTrans = Teuchos::TRANS;
                      } else if (trans == CONJTRANS) {
                        teuchosTrans = Teuchos::CONJ_TRANS;
                      } else {
                        TEUCHOS_TEST_FOR_EXCEPTION(
                          true, std::invalid_argument, "Belos::OperatorTraits::Apply: Invalid "
                          "'trans' value " << trans << ".  Valid values are NOTRANS=" << NOTRANS
                          << ", TRANS=" << TRANS << ", and CONJTRANS=" << CONJTRANS << ".");
                      }
                      Op.apply (X, Y, teuchosTrans);
                    }
                
                    static bool
                    HasApplyTranspose (const ::Tpetra::Operator<Scalar,LO,GO,Node>& Op)
                    {
                      return Op.hasTransposeApply ();
                    }
                  };
                
                } // namespace Belos
                
                #endif // BELOS_TPETRA_ADAPTER_HPP


Top 10 Lines:

     Line      Count

      286         37
      511         12
      122          9
      535          5
      222          2
      674          2

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

       67   Total number of line executions
     8.38   Average executions per line
